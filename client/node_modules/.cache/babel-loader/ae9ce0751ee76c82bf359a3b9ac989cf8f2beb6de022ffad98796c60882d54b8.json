{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { Color4 } from \"../Maths/math.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext.js\";\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL.js\";\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL.js\";\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper.js\";\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager.js\";\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { WebGPURenderPassWrapper } from \"./WebGPU/webgpuRenderPassWrapper.js\";\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler.js\";\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree.js\";\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer.js\";\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext.js\";\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext.js\";\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups.js\";\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad.js\";\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList.js\";\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery.js\";\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner.js\";\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM.js\";\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering.js\";\nimport { PerformanceConfigurator } from \"./performanceConfigurator.js\";\n/**\n * The web GPU engine class provides support for WebGPU version of babylon.js.\n * @since 5.0.0\n */\nexport class WebGPUEngine extends Engine {\n  /**\n   * Create a new instance of the gpu engine.\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   */\n  constructor(canvas, options = {}) {\n    var _a, _b, _c, _d;\n    super(null);\n    // Page Life cycle and constants\n    this._uploadEncoderDescriptor = {\n      label: \"upload\"\n    };\n    this._renderEncoderDescriptor = {\n      label: \"render\"\n    };\n    this._renderTargetEncoderDescriptor = {\n      label: \"renderTarget\"\n    };\n    /** @internal */\n    this._clearDepthValue = 1;\n    /** @internal */\n    this._clearReverseDepthValue = 0;\n    /** @internal */\n    this._clearStencilValue = 0;\n    this._defaultSampleCount = 4; // Only supported value for now.\n    this._glslang = null;\n    this._tintWASM = null;\n    /** @internal */\n    this._compiledComputeEffects = {};\n    /** @internal */\n    this._counters = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Counters from last frame\n     */\n    this.countersLastFrame = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Max number of uncaptured error messages to log\n     */\n    this.numMaxUncapturedErrors = 20;\n    this._commandBuffers = [null, null, null];\n    // Frame Buffer Life Cycle (recreated for each render target pass)\n    /** @internal */\n    this._currentRenderPass = null;\n    /** @internal */\n    this._mainRenderPassWrapper = new WebGPURenderPassWrapper();\n    /** @internal */\n    this._rttRenderPassWrapper = new WebGPURenderPassWrapper();\n    /** @internal */\n    this._pendingDebugCommands = [];\n    /** @internal */\n    this._onAfterUnbindFrameBufferObservable = new Observable();\n    this._currentOverrideVertexBuffers = null;\n    this._currentIndexBuffer = null;\n    this._colorWriteLocal = true;\n    this._forceEnableEffect = false;\n    // TODO WEBGPU remove those variables when code stabilized\n    /** @internal */\n    this.dbgShowShaderCode = false;\n    /** @internal */\n    this.dbgSanityChecks = true;\n    /** @internal */\n    this.dbgVerboseLogsForFirstFrames = false;\n    /** @internal */\n    this.dbgVerboseLogsNumFrames = 10;\n    /** @internal */\n    this.dbgLogIfNotDrawWrapper = true;\n    /** @internal */\n    this.dbgShowEmptyEnableEffectCalls = true;\n    //------------------------------------------------------------------------------\n    //                              Dynamic WebGPU States\n    //------------------------------------------------------------------------------\n    // index 0 is for main render pass, 1 for RTT render pass\n    this._viewportsCurrent = [{\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }, {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }];\n    this._scissorsCurrent = [{\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }, {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }];\n    this._scissorCached = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: 0\n    };\n    this._stencilRefsCurrent = [-1, -1];\n    this._blendColorsCurrent = [[null, null, null, null], [null, null, null, null]];\n    this._name = \"WebGPU\";\n    this.isNDCHalfZRange = true;\n    this.hasOriginBottomLeft = false;\n    options.deviceDescriptor = options.deviceDescriptor || {};\n    options.antialiasing = options.antialiasing === undefined ? true : options.antialiasing;\n    options.stencil = (_a = options.stencil) !== null && _a !== void 0 ? _a : true;\n    options.enableGPUDebugMarkers = (_b = options.enableGPUDebugMarkers) !== null && _b !== void 0 ? _b : false;\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\n    Logger.Log(`Babylon.js v${Engine.Version} - ${this.description} engine`);\n    if (!navigator.gpu) {\n      Logger.Error(\"WebGPU is not supported by your browser.\");\n      return;\n    }\n    options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();\n    this._isWebGPU = true;\n    this._shaderPlatformName = \"WEBGPU\";\n    if (options.deterministicLockstep === undefined) {\n      options.deterministicLockstep = false;\n    }\n    if (options.lockstepMaxSteps === undefined) {\n      options.lockstepMaxSteps = 4;\n    }\n    if (options.audioEngine === undefined) {\n      options.audioEngine = true;\n    }\n    this._deterministicLockstep = options.deterministicLockstep;\n    this._lockstepMaxSteps = options.lockstepMaxSteps;\n    this._timeStep = options.timeStep || 1 / 60;\n    this._doNotHandleContextLost = !!options.doNotHandleContextLost;\n    this._canvas = canvas;\n    this._options = options;\n    this.premultipliedAlpha = (_c = options.premultipliedAlpha) !== null && _c !== void 0 ? _c : true;\n    const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\n    const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\n    const adaptToDeviceRatio = (_d = options.adaptToDeviceRatio) !== null && _d !== void 0 ? _d : false;\n    this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\n    this._mainPassSampleCount = options.antialiasing ? this._defaultSampleCount : 1;\n    this._isStencilEnable = options.stencil;\n    this._sharedInit(canvas, !!options.doNotHandleTouchAction, options.audioEngine);\n    this._shaderProcessor = new WebGPUShaderProcessorGLSL();\n    this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\n  }\n  /**\n   * Gets or sets the snapshot rendering mode\n   */\n  get snapshotRenderingMode() {\n    return this._snapshotRendering.mode;\n  }\n  set snapshotRenderingMode(mode) {\n    this._snapshotRendering.mode = mode;\n  }\n  /**\n   * Creates a new snapshot at the next frame using the current snapshotRenderingMode\n   */\n  snapshotRenderingReset() {\n    this._snapshotRendering.reset();\n  }\n  /**\n   * Enables or disables the snapshot rendering mode\n   * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\n   */\n  get snapshotRendering() {\n    return this._snapshotRendering.enabled;\n  }\n  set snapshotRendering(activate) {\n    this._snapshotRendering.enabled = activate;\n  }\n  /**\n   * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\n   */\n  get disableCacheSamplers() {\n    return this._cacheSampler ? this._cacheSampler.disabled : false;\n  }\n  set disableCacheSamplers(disable) {\n    if (this._cacheSampler) {\n      this._cacheSampler.disabled = disable;\n    }\n  }\n  /**\n   * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\n   */\n  get disableCacheRenderPipelines() {\n    return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\n  }\n  set disableCacheRenderPipelines(disable) {\n    if (this._cacheRenderPipeline) {\n      this._cacheRenderPipeline.disabled = disable;\n    }\n  }\n  /**\n   * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\n   */\n  get disableCacheBindGroups() {\n    return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\n  }\n  set disableCacheBindGroups(disable) {\n    if (this._cacheBindGroups) {\n      this._cacheBindGroups.disabled = disable;\n    }\n  }\n  /**\n   * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\n   */\n  static get IsSupportedAsync() {\n    return !navigator.gpu ? Promise.resolve(false) : navigator.gpu.requestAdapter().then(adapter => !!adapter, () => false).catch(() => false);\n  }\n  /**\n   * Not supported by WebGPU, you should call IsSupportedAsync instead!\n   */\n  static get IsSupported() {\n    Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\n    return false;\n  }\n  /**\n   * Gets a boolean indicating that the engine supports uniform buffers\n   */\n  get supportsUniformBuffers() {\n    return true;\n  }\n  /** Gets the supported extensions by the WebGPU adapter */\n  get supportedExtensions() {\n    return this._adapterSupportedExtensions;\n  }\n  /** Gets the currently enabled extensions on the WebGPU device */\n  get enabledExtensions() {\n    return this._deviceEnabledExtensions;\n  }\n  /**\n   * Returns a string describing the current engine\n   */\n  get description() {\n    const description = this.name + this.version;\n    return description;\n  }\n  /**\n   * Returns the version of the engine\n   */\n  get version() {\n    return 1;\n  }\n  /**\n   * Gets an object containing information about the current engine context\n   * @returns an object containing the vendor, the renderer and the version of the current engine context\n   */\n  getInfo() {\n    return {\n      vendor: \"unknown vendor\",\n      renderer: \"unknown renderer\",\n      version: \"unknown version\"\n    };\n  }\n  /**\n   * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\n   * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\n   * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\n   */\n  get compatibilityMode() {\n    return this._compatibilityMode;\n  }\n  set compatibilityMode(mode) {\n    this._compatibilityMode = mode;\n  }\n  /** @internal */\n  get currentSampleCount() {\n    return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\n  }\n  /**\n   * Create a new instance of the gpu engine asynchronously\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   * @returns a promise that resolves with the created engine\n   */\n  static CreateAsync(canvas, options = {}) {\n    const engine = new WebGPUEngine(canvas, options);\n    return new Promise(resolve => {\n      engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\n    });\n  }\n  //------------------------------------------------------------------------------\n  //                              Initialization\n  //------------------------------------------------------------------------------\n  /**\n   * Initializes the WebGPU context and dependencies.\n   * @param glslangOptions Defines the GLSLang compiler options if necessary\n   * @param twgslOptions Defines the Twgsl compiler options if necessary\n   * @returns a promise notifying the readiness of the engine.\n   */\n  initAsync(glslangOptions, twgslOptions) {\n    var _a;\n    return this._initGlslang(glslangOptions !== null && glslangOptions !== void 0 ? glslangOptions : (_a = this._options) === null || _a === void 0 ? void 0 : _a.glslangOptions).then(glslang => {\n      var _a;\n      this._glslang = glslang;\n      this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;\n      return this._tintWASM ? this._tintWASM.initTwgsl(twgslOptions !== null && twgslOptions !== void 0 ? twgslOptions : (_a = this._options) === null || _a === void 0 ? void 0 : _a.twgslOptions).then(() => {\n        return navigator.gpu.requestAdapter(this._options);\n      }, msg => {\n        Logger.Error(\"Can not initialize twgsl!\");\n        Logger.Error(msg);\n        throw Error(\"WebGPU initializations stopped.\");\n      }) : navigator.gpu.requestAdapter(this._options);\n    }, msg => {\n      Logger.Error(\"Can not initialize glslang!\");\n      Logger.Error(msg);\n      throw Error(\"WebGPU initializations stopped.\");\n    }).then(adapter => {\n      var _a;\n      if (!adapter) {\n        throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\n      } else {\n        this._adapter = adapter;\n        this._adapterSupportedExtensions = [];\n        (_a = this._adapter.features) === null || _a === void 0 ? void 0 : _a.forEach(feature => this._adapterSupportedExtensions.push(feature));\n        const deviceDescriptor = this._options.deviceDescriptor;\n        if (deviceDescriptor === null || deviceDescriptor === void 0 ? void 0 : deviceDescriptor.requiredFeatures) {\n          const requestedExtensions = deviceDescriptor.requiredFeatures;\n          const validExtensions = [];\n          for (const extension of requestedExtensions) {\n            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\n              validExtensions.push(extension);\n            }\n          }\n          deviceDescriptor.requiredFeatures = validExtensions;\n        }\n        return this._adapter.requestDevice(this._options.deviceDescriptor);\n      }\n    }).then(device => {\n      var _a, _b;\n      this._device = device;\n      this._deviceEnabledExtensions = [];\n      (_a = this._device.features) === null || _a === void 0 ? void 0 : _a.forEach(feature => this._deviceEnabledExtensions.push(feature));\n      let numUncapturedErrors = -1;\n      this._device.addEventListener(\"uncapturederror\", event => {\n        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\n          Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${event.error} - ${event.error.message}`);\n        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\n          Logger.Warn(`WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`);\n        }\n      });\n      if (!this._doNotHandleContextLost) {\n        (_b = this._device.lost) === null || _b === void 0 ? void 0 : _b.then(info => {\n          this._contextWasLost = true;\n          Logger.Warn(\"WebGPU context lost. \" + info);\n          this.onContextLostObservable.notifyObservers(this);\n          this._restoreEngineAfterContextLost(this.initAsync.bind(this));\n        });\n      }\n    }, e => {\n      Logger.Error(\"Could not retrieve a WebGPU device.\");\n      Logger.Error(e);\n    }).then(() => {\n      this._bufferManager = new WebGPUBufferManager(this._device);\n      this._textureHelper = new WebGPUTextureHelper(this._device, this._glslang, this._tintWASM, this._bufferManager);\n      this._cacheSampler = new WebGPUCacheSampler(this._device);\n      this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\n      this._timestampQuery = new WebGPUTimestampQuery(this._device, this._bufferManager);\n      this._occlusionQuery = this._device.createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : undefined;\n      this._bundleList = new WebGPUBundleList(this._device);\n      this._bundleListRenderTarget = new WebGPUBundleList(this._device);\n      this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList, this._bundleListRenderTarget);\n      this._ubInvertY = this._bufferManager.createBuffer(new Float32Array([-1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\n      this._ubDontInvertY = this._bufferManager.createBuffer(new Float32Array([1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n          console.log(\"%c frame #\" + this._count + \" - begin\", \"background: #ffff00\");\n        }\n      }\n      this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\n      this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\n      this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\n      this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", false, false, 1, false, 0, 1);\n      this._initializeLimits();\n      this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer, !this._caps.textureFloatLinearFiltering);\n      this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\n      this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\n      this._stencilStateComposer.stencilGlobal = this._stencilState;\n      this._depthCullingState.depthTest = true;\n      this._depthCullingState.depthFunc = 515;\n      this._depthCullingState.depthMask = true;\n      this._textureHelper.setCommandEncoder(this._uploadEncoder);\n      this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\n      this._defaultDrawContext = this.createDrawContext();\n      this._currentDrawContext = this._defaultDrawContext;\n      this._defaultMaterialContext = this.createMaterialContext();\n      this._currentMaterialContext = this._defaultMaterialContext;\n      this._initializeContextAndSwapChain();\n      this._initializeMainAttachments();\n      this.resize();\n    }).catch(e => {\n      Logger.Error(\"Can not create WebGPU Device and/or context.\");\n      Logger.Error(e);\n      if (console.trace) {\n        console.trace();\n      }\n    });\n  }\n  _initGlslang(glslangOptions) {\n    glslangOptions = glslangOptions || {};\n    glslangOptions = {\n      ...WebGPUEngine._GLSLslangDefaultOptions,\n      ...glslangOptions\n    };\n    if (glslangOptions.glslang) {\n      return Promise.resolve(glslangOptions.glslang);\n    }\n    if (self.glslang) {\n      return self.glslang(glslangOptions.wasmPath);\n    }\n    if (glslangOptions.jsPath && glslangOptions.wasmPath) {\n      if (IsWindowObjectExist()) {\n        return Tools.LoadScriptAsync(glslangOptions.jsPath).then(() => {\n          return self.glslang(glslangOptions.wasmPath);\n        });\n      } else {\n        importScripts(glslangOptions.jsPath);\n        return self.glslang(glslangOptions.wasmPath);\n      }\n    }\n    return Promise.reject(\"gslang is not available.\");\n  }\n  _initializeLimits() {\n    // Init caps\n    // TODO WEBGPU Real Capability check once limits will be working.\n    this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 8192,\n      maxCubemapTextureSize: 2048,\n      maxRenderTextureSize: 8192,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 15,\n      maxFragmentUniformVectors: 1024,\n      maxVertexUniformVectors: 1024,\n      standardDerivatives: true,\n      astc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined,\n      s3tc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      pvrtc: null,\n      etc1: null,\n      etc2: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined,\n      bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      maxAnisotropy: 4,\n      uintIndices: true,\n      fragmentDepthSupported: true,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: true,\n      textureFloat: true,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: true,\n      textureHalfFloat: true,\n      textureHalfFloatLinearFiltering: true,\n      textureHalfFloatRender: true,\n      textureLOD: true,\n      drawBuffersExtension: true,\n      depthTextureExtension: true,\n      vertexArrayObject: false,\n      instancedArrays: true,\n      timerQuery: typeof BigUint64Array !== \"undefined\" && this.enabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? true : undefined,\n      supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\n      canUseTimestampForTimerQuery: true,\n      multiview: false,\n      oculusMultiview: false,\n      parallelShaderCompile: undefined,\n      blendMinMax: true,\n      maxMSAASamples: 4,\n      canUseGLInstanceID: true,\n      canUseGLVertexID: true,\n      supportComputeShaders: true,\n      supportSRGBBuffers: true,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: true,\n      texture2DArrayMaxLayerCount: 2048\n    };\n    this._caps.parallelShaderCompile = null;\n    this._features = {\n      forceBitmapOverHTMLImageElement: true,\n      supportRenderAndCopyToLodForFloatTextures: true,\n      supportDepthStencilTexture: true,\n      supportShadowSamplers: true,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: true,\n      trackUbosInFrame: true,\n      checkUbosContentBeforeUpload: true,\n      supportCSM: true,\n      basisNeedsPOT: false,\n      support3DTextures: true,\n      needTypeSuffixInShaderConstants: true,\n      supportMSAA: true,\n      supportSSAO2: true,\n      supportExtendedTextureFormats: true,\n      supportSwitchCaseInShader: true,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: false,\n      useUBOBindingCache: false,\n      needShaderCodeInlining: true,\n      needToAlwaysBindUniformBuffers: true,\n      supportRenderPasses: true,\n      supportSpriteInstancing: true,\n      _collectUbosUpdatedInFrame: false\n    };\n  }\n  _initializeContextAndSwapChain() {\n    this._context = this._canvas.getContext(\"webgpu\");\n    this._configureContext();\n    this._colorFormat = this._options.swapChainFormat;\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format = this._colorFormat;\n  }\n  // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\n  _initializeMainAttachments() {\n    if (!this._bufferManager) {\n      return;\n    }\n    this.flushFramebuffer(false);\n    this._mainTextureExtends = {\n      width: this.getRenderWidth(),\n      height: this.getRenderHeight(),\n      depthOrArrayLayers: 1\n    };\n    const bufferDataUpdate = new Float32Array([this.getRenderHeight()]);\n    this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\n    this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\n    let mainColorAttachments;\n    if (this._options.antialiasing) {\n      const mainTextureDescriptor = {\n        label: \"Texture_MainColor_antialiasing\",\n        size: this._mainTextureExtends,\n        mipLevelCount: 1,\n        sampleCount: this._mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: this._options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.RenderAttachment\n      };\n      if (this._mainTexture) {\n        this._textureHelper.releaseTexture(this._mainTexture);\n      }\n      this._mainTexture = this._device.createTexture(mainTextureDescriptor);\n      mainColorAttachments = [{\n        view: this._mainTexture.createView(),\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\n      }];\n    } else {\n      mainColorAttachments = [{\n        view: undefined,\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }];\n    }\n    this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n    const depthTextureDescriptor = {\n      label: \"Texture_MainDepthStencil\",\n      size: this._mainTextureExtends,\n      mipLevelCount: 1,\n      sampleCount: this._mainPassSampleCount,\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format: this._mainRenderPassWrapper.depthTextureFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment\n    };\n    if (this._depthTexture) {\n      this._textureHelper.releaseTexture(this._depthTexture);\n    }\n    this._depthTexture = this._device.createTexture(depthTextureDescriptor);\n    const mainDepthAttachment = {\n      view: this._depthTexture.createView(),\n      depthClearValue: this._clearDepthValue,\n      depthLoadOp: WebGPUConstants.LoadOp.Clear,\n      depthStoreOp: WebGPUConstants.StoreOp.Store,\n      stencilClearValue: this._clearStencilValue,\n      stencilLoadOp: !this.isStencilEnable ? undefined : WebGPUConstants.LoadOp.Clear,\n      stencilStoreOp: !this.isStencilEnable ? undefined : WebGPUConstants.StoreOp.Store\n    };\n    this._mainRenderPassWrapper.renderPassDescriptor = {\n      colorAttachments: mainColorAttachments,\n      depthStencilAttachment: mainDepthAttachment\n    };\n  }\n  _configureContext() {\n    this._context.configure({\n      device: this._device,\n      format: this._options.swapChainFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\n      alphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasAlphaMode.Premultiplied : WebGPUConstants.CanvasAlphaMode.Opaque\n    });\n  }\n  /**\n   * Force a specific size of the canvas\n   * @param width defines the new canvas' width\n   * @param height defines the new canvas' height\n   * @param forceSetSize true to force setting the sizes of the underlying canvas\n   * @returns true if the size was changed\n   */\n  setSize(width, height, forceSetSize = false) {\n    if (!super.setSize(width, height, forceSetSize)) {\n      return false;\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - setSize called -\", width, height);\n      }\n    }\n    this._initializeMainAttachments();\n    if (this.snapshotRendering) {\n      // reset snapshot rendering so that the next frame will record a new list of bundles\n      this.snapshotRenderingReset();\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _getShaderProcessor(shaderLanguage) {\n    if (shaderLanguage === ShaderLanguage.WGSL) {\n      return this._shaderProcessorWGSL;\n    }\n    return this._shaderProcessor;\n  }\n  /**\n   * @internal\n   */\n  _getShaderProcessingContext(shaderLanguage) {\n    return new WebGPUShaderProcessingContext(shaderLanguage);\n  }\n  //------------------------------------------------------------------------------\n  //                          Static Pipeline WebGPU States\n  //------------------------------------------------------------------------------\n  /** @internal */\n  applyStates() {\n    this._stencilStateComposer.apply();\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\n  }\n  /**\n   * Force the entire cache to be cleared\n   * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n   */\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames && !bruteForce) {\n      return;\n    }\n    //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\n    // _forceEnableEffect = true assumes the role of _currentEffect = null\n    this._forceEnableEffect = true;\n    this._currentIndexBuffer = null;\n    this._currentOverrideVertexBuffers = null;\n    this._cacheRenderPipeline.setBuffers(null, null, null);\n    if (bruteForce) {\n      this._stencilStateComposer.reset();\n      this._depthCullingState.reset();\n      this._depthCullingState.depthFunc = 515;\n      this._alphaState.reset();\n      this._alphaMode = 1;\n      this._alphaEquation = 0;\n      this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\n      this._cacheRenderPipeline.setAlphaBlendEnabled(false);\n      this.setColorWrite(true);\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  /**\n   * Enable or disable color writing\n   * @param enable defines the state to set\n   */\n  setColorWrite(enable) {\n    this._colorWriteLocal = enable;\n    this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\n  }\n  /**\n   * Gets a boolean indicating if color writing is enabled\n   * @returns the current color writing state\n   */\n  getColorWrite() {\n    return this._colorWriteLocal;\n  }\n  _resetCurrentViewport(index) {\n    this._viewportsCurrent[index].x = 0;\n    this._viewportsCurrent[index].y = 0;\n    this._viewportsCurrent[index].w = 0;\n    this._viewportsCurrent[index].h = 0;\n    if (index === 1) {\n      this._viewportCached.x = 0;\n      this._viewportCached.y = 0;\n      this._viewportCached.z = 0;\n      this._viewportCached.w = 0;\n    }\n  }\n  _mustUpdateViewport(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const x = this._viewportCached.x,\n      y = this._viewportCached.y,\n      w = this._viewportCached.z,\n      h = this._viewportCached.w;\n    const update = this._viewportsCurrent[index].x !== x || this._viewportsCurrent[index].y !== y || this._viewportsCurrent[index].w !== w || this._viewportsCurrent[index].h !== h;\n    if (update) {\n      this._viewportsCurrent[index].x = this._viewportCached.x;\n      this._viewportsCurrent[index].y = this._viewportCached.y;\n      this._viewportsCurrent[index].w = this._viewportCached.z;\n      this._viewportsCurrent[index].h = this._viewportCached.w;\n    }\n    return update;\n  }\n  _applyViewport(renderPass) {\n    let y = Math.floor(this._viewportCached.y);\n    const h = Math.floor(this._viewportCached.w);\n    if (!this._currentRenderTarget) {\n      y = this.getRenderHeight() - y - h;\n    }\n    renderPass.setViewport(Math.floor(this._viewportCached.x), y, Math.floor(this._viewportCached.z), h, 0, 1);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - viewport applied - (\", this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w, \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass));\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _viewport(x, y, width, height) {\n    this._viewportCached.x = x;\n    this._viewportCached.y = y;\n    this._viewportCached.z = width;\n    this._viewportCached.w = height;\n  }\n  _resetCurrentScissor(index) {\n    this._scissorsCurrent[index].x = 0;\n    this._scissorsCurrent[index].y = 0;\n    this._scissorsCurrent[index].w = 0;\n    this._scissorsCurrent[index].h = 0;\n  }\n  _mustUpdateScissor(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const x = this._scissorCached.x,\n      y = this._scissorCached.y,\n      w = this._scissorCached.z,\n      h = this._scissorCached.w;\n    const update = this._scissorsCurrent[index].x !== x || this._scissorsCurrent[index].y !== y || this._scissorsCurrent[index].w !== w || this._scissorsCurrent[index].h !== h;\n    if (update) {\n      this._scissorsCurrent[index].x = this._scissorCached.x;\n      this._scissorsCurrent[index].y = this._scissorCached.y;\n      this._scissorsCurrent[index].w = this._scissorCached.z;\n      this._scissorsCurrent[index].h = this._scissorCached.w;\n    }\n    return update;\n  }\n  _applyScissor(renderPass) {\n    renderPass.setScissorRect(this._scissorCached.x, this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y, this._scissorCached.z, this._scissorCached.w);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - scissor applied - (\", this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w, \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass));\n      }\n    }\n  }\n  _scissorIsActive() {\n    return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\n  }\n  enableScissor(x, y, width, height) {\n    this._scissorCached.x = x;\n    this._scissorCached.y = y;\n    this._scissorCached.z = width;\n    this._scissorCached.w = height;\n  }\n  disableScissor() {\n    this._scissorCached.x = 0;\n    this._scissorCached.y = 0;\n    this._scissorCached.z = 0;\n    this._scissorCached.w = 0;\n    this._resetCurrentScissor(0);\n    this._resetCurrentScissor(1);\n  }\n  _resetCurrentStencilRef(index) {\n    this._stencilRefsCurrent[index] = -1;\n  }\n  _mustUpdateStencilRef(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent[index];\n    if (update) {\n      this._stencilRefsCurrent[index] = this._stencilStateComposer.funcRef;\n    }\n    return update;\n  }\n  /**\n   * @internal\n   */\n  _applyStencilRef(renderPass) {\n    var _a;\n    renderPass.setStencilReference((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0);\n  }\n  _resetCurrentColorBlend(index) {\n    this._blendColorsCurrent[index][0] = this._blendColorsCurrent[index][1] = this._blendColorsCurrent[index][2] = this._blendColorsCurrent[index][3] = null;\n  }\n  _mustUpdateBlendColor(renderPass) {\n    const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n    const colorBlend = this._alphaState._blendConstants;\n    const update = colorBlend[0] !== this._blendColorsCurrent[index][0] || colorBlend[1] !== this._blendColorsCurrent[index][1] || colorBlend[2] !== this._blendColorsCurrent[index][2] || colorBlend[3] !== this._blendColorsCurrent[index][3];\n    if (update) {\n      this._blendColorsCurrent[index][0] = colorBlend[0];\n      this._blendColorsCurrent[index][1] = colorBlend[1];\n      this._blendColorsCurrent[index][2] = colorBlend[2];\n      this._blendColorsCurrent[index][3] = colorBlend[3];\n    }\n    return update;\n  }\n  _applyBlendColor(renderPass) {\n    renderPass.setBlendConstant(this._alphaState._blendConstants);\n  }\n  /**\n   * Clear the current render buffer or the current render target (if any is set up)\n   * @param color defines the color to use\n   * @param backBuffer defines if the back buffer must be cleared\n   * @param depth defines if the depth buffer must be cleared\n   * @param stencil defines if the stencil buffer must be cleared\n   */\n  clear(color, backBuffer, depth, stencil = false) {\n    // Some PGs are using color3...\n    if (color && color.a === undefined) {\n      color.a = 1;\n    }\n    const hasScissor = this._scissorIsActive();\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - clear called - backBuffer=\", backBuffer, \" depth=\", depth, \" stencil=\", stencil, \" scissor is active=\", hasScissor);\n      }\n    }\n    // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n    if (this._currentRenderTarget) {\n      if (hasScissor) {\n        if (!this._rttRenderPassWrapper.renderPass) {\n          this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);\n        }\n        if (!this.compatibilityMode) {\n          this._bundleListRenderTarget.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n        } else {\n          this._applyScissor(this._currentRenderPass);\n        }\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      } else {\n        if (this._currentRenderPass) {\n          this._endRenderTargetRenderPass();\n        }\n        this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);\n      }\n    } else {\n      if (!this._mainRenderPassWrapper.renderPass || !hasScissor) {\n        this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\n      }\n      if (hasScissor) {\n        if (!this.compatibilityMode) {\n          this._bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n        } else {\n          this._applyScissor(this._currentRenderPass);\n        }\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      }\n    }\n  }\n  _clearFullQuad(clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n    const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\n    const renderPassIndex = this._getCurrentRenderPassIndex();\n    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\n    this._clearQuad.setColorFormat(this._colorFormat);\n    this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\n    this._clearQuad.setMRTAttachments((_a = this._cacheRenderPipeline.mrtAttachments) !== null && _a !== void 0 ? _a : [], (_b = this._cacheRenderPipeline.mrtTextureArray) !== null && _b !== void 0 ? _b : [], this._cacheRenderPipeline.mrtTextureCount);\n    if (!this.compatibilityMode) {\n      bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\n    } else {\n      renderPass.setStencilReference(this._clearStencilValue);\n    }\n    const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\n    if (!this.compatibilityMode) {\n      bundleList.addBundle(bundle);\n      bundleList.addItem(new WebGPURenderItemStencilRef((_c = this._stencilStateComposer.funcRef) !== null && _c !== void 0 ? _c : 0));\n      this._reportDrawCall();\n    } else {\n      this._applyStencilRef(renderPass);\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                              Vertex/Index/Storage Buffers\n  //------------------------------------------------------------------------------\n  /**\n   * Creates a vertex buffer\n   * @param data the data for the vertex buffer\n   * @returns the new buffer\n   */\n  createVertexBuffer(data) {\n    let view;\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst);\n    return dataBuffer;\n  }\n  /**\n   * Creates a vertex buffer\n   * @param data the data for the dynamic vertex buffer\n   * @returns the new buffer\n   */\n  createDynamicVertexBuffer(data) {\n    return this.createVertexBuffer(data);\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the content of the index buffer\n   * @returns a new buffer\n   */\n  createIndexBuffer(indices) {\n    let is32Bits = true;\n    let view;\n    if (indices instanceof Uint32Array || indices instanceof Int32Array) {\n      view = indices;\n    } else if (indices instanceof Uint16Array) {\n      view = indices;\n      is32Bits = false;\n    } else {\n      if (indices.length > 65535) {\n        view = new Uint32Array(indices);\n      } else {\n        view = new Uint16Array(indices);\n        is32Bits = false;\n      }\n    }\n    const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst);\n    dataBuffer.is32Bits = is32Bits;\n    return dataBuffer;\n  }\n  /**\n   * @internal\n   */\n  _createBuffer(data, creationFlags) {\n    let view;\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    let flags = 0;\n    if (creationFlags & 1) {\n      flags |= WebGPUConstants.BufferUsage.CopySrc;\n    }\n    if (creationFlags & 2) {\n      flags |= WebGPUConstants.BufferUsage.CopyDst;\n    }\n    if (creationFlags & 4) {\n      flags |= WebGPUConstants.BufferUsage.Uniform;\n    }\n    if (creationFlags & 8) {\n      flags |= WebGPUConstants.BufferUsage.Vertex;\n    }\n    if (creationFlags & 16) {\n      flags |= WebGPUConstants.BufferUsage.Index;\n    }\n    if (creationFlags & 32) {\n      flags |= WebGPUConstants.BufferUsage.Storage;\n    }\n    return this._bufferManager.createBuffer(view, flags);\n  }\n  /**\n   * @internal\n   */\n  bindBuffersDirectly() {\n    throw \"Not implemented on WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  updateAndBindInstancesBuffer() {\n    throw \"Not implemented on WebGPU\";\n  }\n  /**\n   * Bind a list of vertex buffers with the engine\n   * @param vertexBuffers defines the list of vertex buffers to bind\n   * @param indexBuffer defines the index buffer to bind\n   * @param effect defines the effect associated with the vertex buffers\n   * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\n   */\n  bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    this._currentIndexBuffer = indexBuffer;\n    this._currentOverrideVertexBuffers = overrideVertexBuffers !== null && overrideVertexBuffers !== void 0 ? overrideVertexBuffers : null;\n    this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);\n  }\n  /**\n   * @internal\n   */\n  _releaseBuffer(buffer) {\n    return this._bufferManager.releaseBuffer(buffer);\n  }\n  //------------------------------------------------------------------------------\n  //                              Effects\n  //------------------------------------------------------------------------------\n  /**\n   * Create a new effect (used to store vertex/fragment shaders)\n   * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\n   * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\n   * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\n   * @param samplers defines an array of string used to represent textures\n   * @param defines defines the string containing the defines to use to compile the shaders\n   * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   * @returns the new Effect\n   */\n  createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = ShaderLanguage.GLSL) {\n    var _a;\n    const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\n    const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\n    const globalDefines = this._getGlobalDefines();\n    let fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : \"\";\n    if (globalDefines) {\n      fullDefines += \"\\n\" + globalDefines;\n    }\n    const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\n    if (this._compiledEffects[name]) {\n      const compiledEffect = this._compiledEffects[name];\n      if (onCompiled && compiledEffect.isReady()) {\n        onCompiled(compiledEffect);\n      }\n      return compiledEffect;\n    }\n    const effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, shaderLanguage);\n    this._compiledEffects[name] = effect;\n    return effect;\n  }\n  _compileRawShaderToSpirV(source, type) {\n    return this._glslang.compileGLSL(source, type);\n  }\n  _compileShaderToSpirV(source, type, defines, shaderVersion) {\n    return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\n  }\n  _getWGSLShader(source, type, defines) {\n    if (defines) {\n      defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\n    } else {\n      defines = \"\";\n    }\n    return defines + source;\n  }\n  _createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage) {\n    if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\n      vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader);\n      fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader);\n    }\n    return {\n      vertexStage: {\n        module: this._device.createShaderModule({\n          code: vertexShader\n        }),\n        entryPoint: \"main\"\n      },\n      fragmentStage: {\n        module: this._device.createShaderModule({\n          code: fragmentShader\n        }),\n        entryPoint: \"main\"\n      }\n    };\n  }\n  _compileRawPipelineStageDescriptor(vertexCode, fragmentCode, shaderLanguage) {\n    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\n    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\n    return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\n  }\n  _compilePipelineStageDescriptor(vertexCode, fragmentCode, defines, shaderLanguage) {\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    const shaderVersion = \"#version 450\\n\";\n    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\n    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion) : this._getWGSLShader(fragmentCode, \"fragment\", defines);\n    const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  }\n  /**\n   * @internal\n   */\n  createRawShaderProgram() {\n    throw \"Not available on WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  createShaderProgram() {\n    throw \"Not available on WebGPU\";\n  }\n  /**\n   * Inline functions in shader code that are marked to be inlined\n   * @param code code to inline\n   * @returns inlined code\n   */\n  inlineShaderCode(code) {\n    const sci = new ShaderCodeInliner(code);\n    sci.debug = false;\n    sci.processCode();\n    return sci.code;\n  }\n  /**\n   * Creates a new pipeline context\n   * @param shaderProcessingContext defines the shader processing context used during the processing if available\n   * @returns the new pipeline\n   */\n  createPipelineContext(shaderProcessingContext) {\n    return new WebGPUPipelineContext(shaderProcessingContext, this);\n  }\n  /**\n   * Creates a new material context\n   * @returns the new context\n   */\n  createMaterialContext() {\n    return new WebGPUMaterialContext();\n  }\n  /**\n   * Creates a new draw context\n   * @returns the new context\n   */\n  createDrawContext() {\n    return new WebGPUDrawContext(this._bufferManager);\n  }\n  /**\n   * @internal\n   */\n  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines) {\n    const webGpuContext = pipelineContext;\n    const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\n    if (this.dbgShowShaderCode) {\n      console.log(defines);\n      console.log(vertexSourceCode);\n      console.log(fragmentSourceCode);\n      console.log(\"***********************************************\");\n    }\n    webGpuContext.sources = {\n      fragment: fragmentSourceCode,\n      vertex: vertexSourceCode,\n      rawVertex: rawVertexSourceCode,\n      rawFragment: rawFragmentSourceCode\n    };\n    if (createAsRaw) {\n      webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\n    } else {\n      webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\n    }\n  }\n  /**\n   * Gets the list of active attributes for a given WebGPU program\n   * @param pipelineContext defines the pipeline context to use\n   * @param attributesNames defines the list of attribute names to get\n   * @returns an array of indices indicating the offset of each attribute\n   */\n  getAttributes(pipelineContext, attributesNames) {\n    const results = new Array(attributesNames.length);\n    const gpuPipelineContext = pipelineContext;\n    for (let i = 0; i < attributesNames.length; i++) {\n      const attributeName = attributesNames[i];\n      const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\n      if (attributeLocation === undefined) {\n        continue;\n      }\n      results[i] = attributeLocation;\n    }\n    return results;\n  }\n  /**\n   * Activates an effect, making it the current one (ie. the one used for rendering)\n   * @param effect defines the effect to activate\n   */\n  enableEffect(effect) {\n    if (!effect) {\n      return;\n    }\n    let isNewEffect = true;\n    if (!DrawWrapper.IsWrapper(effect)) {\n      isNewEffect = effect !== this._currentEffect;\n      this._currentEffect = effect;\n      this._currentMaterialContext = this._defaultMaterialContext;\n      this._currentDrawContext = this._defaultDrawContext;\n      this._counters.numEnableEffects++;\n      if (this.dbgLogIfNotDrawWrapper) {\n        Logger.Warn(`enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${effect.name.vertex}, effect.name.fragment=${effect.name.fragment}`, 10);\n      }\n    } else if (!effect.effect || effect.effect === this._currentEffect && effect.materialContext === this._currentMaterialContext && effect.drawContext === this._currentDrawContext && !this._forceEnableEffect) {\n      if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\n        console.error(\"drawWrapper=\", effect);\n        throw \"Invalid call to enableEffect: the effect property is empty!\";\n      }\n      return;\n    } else {\n      isNewEffect = effect.effect !== this._currentEffect;\n      this._currentEffect = effect.effect;\n      this._currentMaterialContext = effect.materialContext;\n      this._currentDrawContext = effect.drawContext;\n      this._counters.numEnableDrawWrapper++;\n      if (!this._currentMaterialContext) {\n        console.error(\"drawWrapper=\", effect);\n        throw `Invalid call to enableEffect: the materialContext property is empty!`;\n      }\n    }\n    this._stencilStateComposer.stencilMaterial = undefined;\n    this._forceEnableEffect = isNewEffect || this._forceEnableEffect ? false : this._forceEnableEffect;\n    if (isNewEffect) {\n      if (this._currentEffect.onBind) {\n        this._currentEffect.onBind(this._currentEffect);\n      }\n      if (this._currentEffect._onBindObservable) {\n        this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _releaseEffect(effect) {\n    if (this._compiledEffects[effect._key]) {\n      delete this._compiledEffects[effect._key];\n      this._deletePipelineContext(effect.getPipelineContext());\n    }\n  }\n  /**\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n   */\n  releaseEffects() {\n    for (const name in this._compiledEffects) {\n      const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext();\n      this._deletePipelineContext(webGPUPipelineContext);\n    }\n    this._compiledEffects = {};\n  }\n  _deletePipelineContext(pipelineContext) {\n    const webgpuPipelineContext = pipelineContext;\n    if (webgpuPipelineContext) {\n      pipelineContext.dispose();\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                              Textures\n  //------------------------------------------------------------------------------\n  /**\n   * Gets a boolean indicating that only power of 2 textures are supported\n   * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\n   */\n  get needPOTTextures() {\n    return false;\n  }\n  /** @internal */\n  _createHardwareTexture() {\n    return new WebGPUHardwareTexture();\n  }\n  /**\n   * @internal\n   */\n  _releaseTexture(texture) {\n    const index = this._internalTexturesCache.indexOf(texture);\n    if (index !== -1) {\n      this._internalTexturesCache.splice(index, 1);\n    }\n    this._textureHelper.releaseTexture(texture);\n  }\n  /**\n   * @internal\n   */\n  _getRGBABufferInternalSizedFormat() {\n    return 5;\n  }\n  updateTextureComparisonFunction(texture, comparisonFunction) {\n    texture._comparisonFunction = comparisonFunction;\n  }\n  /**\n   * Creates an internal texture without binding it to a framebuffer\n   * @internal\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\n   * @param source source type of the texture\n   * @returns a new internal texture\n   */\n  _createInternalTexture(size, options, delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {\n    var _a, _b, _c;\n    const fullOptions = {};\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      fullOptions.format = options.format === undefined ? 5 : options.format;\n      fullOptions.samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;\n      fullOptions.creationFlags = (_b = options.creationFlags) !== null && _b !== void 0 ? _b : 0;\n      fullOptions.useSRGBBuffer = (_c = options.useSRGBBuffer) !== null && _c !== void 0 ? _c : false;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n      fullOptions.format = 5;\n      fullOptions.samples = 1;\n      fullOptions.creationFlags = 0;\n      fullOptions.useSRGBBuffer = false;\n    }\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    }\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\n      fullOptions.type = 0;\n      Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\n    }\n    const texture = new InternalTexture(this, source);\n    const width = size.width || size;\n    const height = size.height || size;\n    const layers = size.layers || 0;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = layers;\n    texture.isReady = true;\n    texture.samples = fullOptions.samples;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture.format = fullOptions.format;\n    texture.is2DArray = layers > 0;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n    texture._useSRGBBuffer = fullOptions.useSRGBBuffer;\n    this._internalTexturesCache.push(texture);\n    if (!delayGPUTextureCreation) {\n      this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\n    }\n    return texture;\n  }\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a hardware texture\n   * @param url defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {\n    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, (texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction) => {\n      var _a;\n      const imageBitmap = img; // we will never get an HTMLImageElement in WebGPU\n      texture.baseWidth = imageBitmap.width;\n      texture.baseHeight = imageBitmap.height;\n      texture.width = imageBitmap.width;\n      texture.height = imageBitmap.height;\n      texture.format = format !== null && format !== void 0 ? format : -1;\n      processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\n      if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n        // the texture could have been created before reaching this point so don't recreate it if already existing\n        const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\n          this._textureHelper.updateTexture(imageBitmap, texture, imageBitmap.width, imageBitmap.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n          if (!noMipmap && !isCompressed) {\n            this._generateMipmaps(texture, this._uploadEncoder);\n          }\n        }\n      } else if (!noMipmap && !isCompressed) {\n        this._generateMipmaps(texture, this._uploadEncoder);\n      }\n      if (scene) {\n        scene.removePendingData(texture);\n      }\n      texture.isReady = true;\n      texture.onLoadedObservable.notifyObservers(texture);\n      texture.onLoadedObservable.clear();\n    }, () => false, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);\n  }\n  /**\n   * Wraps an external web gpu texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @returns the babylon internal texture\n   */\n  wrapWebGPUTexture(texture) {\n    const hardwareTexture = new WebGPUHardwareTexture(texture);\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.isReady = true;\n    return internalTexture;\n  }\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @returns the babylon internal texture\n   */\n  wrapWebGLTexture() {\n    throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\n  }\n  generateMipMapsForCubemap(texture) {\n    var _a;\n    if (texture.generateMipMaps) {\n      const gpuTexture = (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource;\n      if (!gpuTexture) {\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\n      }\n      this._generateMipmaps(texture, texture.source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? this._renderTargetEncoder : undefined);\n    }\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param samplingMode defines the required sampling mode\n   * @param texture defines the texture to update\n   * @param generateMipMaps defines whether to generate mipmaps for the texture\n   */\n  updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {\n    if (generateMipMaps) {\n      texture.generateMipMaps = true;\n      this._generateMipmaps(texture);\n    }\n    texture.samplingMode = samplingMode;\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param texture defines the texture to update\n   * @param wrapU defines the texture wrap mode of the u coordinates\n   * @param wrapV defines the texture wrap mode of the v coordinates\n   * @param wrapR defines the texture wrap mode of the r coordinates\n   */\n  updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {\n    if (wrapU !== null) {\n      texture._cachedWrapU = wrapU;\n    }\n    if (wrapV !== null) {\n      texture._cachedWrapV = wrapV;\n    }\n    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\n      texture._cachedWrapR = wrapR;\n    }\n  }\n  /**\n   * Update the dimensions of a texture\n   * @param texture texture to update\n   * @param width new width of the texture\n   * @param height new height of the texture\n   * @param depth new depth of the texture\n   */\n  updateTextureDimensions(texture, width, height, depth = 1) {\n    if (!texture._hardwareTexture) {\n      // the gpu texture is not created yet, so when it is it will be created with the right dimensions\n      return;\n    }\n    if (texture.width === width && texture.height === height && texture.depth === depth) {\n      return;\n    }\n    const additionalUsages = texture._hardwareTexture.textureAdditionalUsages;\n    texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\n  }\n  /**\n   * @internal\n   */\n  _setInternalTexture(name, texture, baseName) {\n    baseName = baseName !== null && baseName !== void 0 ? baseName : name;\n    if (this._currentEffect) {\n      const webgpuPipelineContext = this._currentEffect._pipelineContext;\n      const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\n      this._currentMaterialContext.setTexture(name, texture);\n      if (availableTexture && availableTexture.autoBindSampler) {\n        const samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;\n        this._currentMaterialContext.setSampler(samplerName, texture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\n      }\n    }\n  }\n  /**\n   * Sets a texture to the according uniform.\n   * @param channel The texture channel\n   * @param unused unused parameter\n   * @param texture The texture to apply\n   * @param name The name of the uniform in the effect\n   */\n  setTexture(channel, unused, texture, name) {\n    this._setTexture(channel, texture, false, false, name, name);\n  }\n  /**\n   * Sets an array of texture to the WebGPU context\n   * @param channel defines the channel where the texture array must be set\n   * @param unused unused parameter\n   * @param textures defines the array of textures to bind\n   * @param name name of the channel\n   */\n  setTextureArray(channel, unused, textures, name) {\n    for (let index = 0; index < textures.length; index++) {\n      this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\n    }\n  }\n  _setTexture(channel, texture,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isPartOfTextureArray = false, depthStencilTexture = false, name = \"\", baseName) {\n    // name == baseName for a texture that is not part of a texture array\n    // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\n    // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\n    // name is used to look up the texture in the _currentMaterialContext.textures map\n    baseName = baseName !== null && baseName !== void 0 ? baseName : name;\n    if (this._currentEffect) {\n      if (!texture) {\n        this._currentMaterialContext.setTexture(name, null);\n        return false;\n      }\n      // Video\n      if (texture.video) {\n        texture.update();\n      } else if (texture.delayLoadState === 4) {\n        // Delay loading\n        texture.delayLoad();\n        return false;\n      }\n      let internalTexture = null;\n      if (depthStencilTexture) {\n        internalTexture = texture.depthStencilTexture;\n      } else if (texture.isReady()) {\n        internalTexture = texture.getInternalTexture();\n      } else if (texture.isCube) {\n        internalTexture = this.emptyCubeTexture;\n      } else if (texture.is3D) {\n        internalTexture = this.emptyTexture3D;\n      } else if (texture.is2DArray) {\n        internalTexture = this.emptyTexture2DArray;\n      } else {\n        internalTexture = this.emptyTexture;\n      }\n      if (internalTexture && !internalTexture.isMultiview) {\n        // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\n        if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\n          internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\n          const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;\n          texture.wrapU = textureWrapMode;\n          texture.wrapV = textureWrapMode;\n        }\n        internalTexture._cachedWrapU = texture.wrapU;\n        internalTexture._cachedWrapV = texture.wrapV;\n        if (internalTexture.is3D) {\n          internalTexture._cachedWrapR = texture.wrapR;\n        }\n        this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\n      }\n      this._setInternalTexture(name, internalTexture, baseName);\n    } else {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - _setTexture called with a null _currentEffect! texture=\", texture);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {\n    if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\n      internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\n    }\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture, name) {\n    if (channel === undefined) {\n      return;\n    }\n    this._setInternalTexture(name, texture);\n  }\n  /**\n   * Generates the mipmaps for a texture\n   * @param texture texture to generate the mipmaps for\n   */\n  generateMipmaps(texture) {\n    this._generateMipmaps(texture, this._renderTargetEncoder);\n  }\n  /**\n   * @internal\n   */\n  _generateMipmaps(texture, commandEncoder) {\n    const gpuHardwareTexture = texture._hardwareTexture;\n    if (!gpuHardwareTexture) {\n      return;\n    }\n    // try as much as possible to use the command encoder corresponding to the current pass.\n    // If not possible (because the pass is started - generateMipmaps itself creates a pass and it's not allowed to have a pass inside a pass), use _uploadEncoder\n    commandEncoder = commandEncoder !== null && commandEncoder !== void 0 ? commandEncoder : this._currentRenderTarget && !this._currentRenderPass ? this._renderTargetEncoder : !this._currentRenderPass ? this._renderEncoder : this._uploadEncoder;\n    const format = texture._hardwareTexture.format;\n    const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - generate mipmaps called - width=\", texture.width, \"height=\", texture.height, \"isCube=\", texture.isCube);\n      }\n    }\n    if (texture.isCube) {\n      this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\n    } else {\n      this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);\n    }\n  }\n  /**\n   * Update a portion of an internal texture\n   * @param texture defines the texture to update\n   * @param imageData defines the data to store into the texture\n   * @param xOffset defines the x coordinates of the update rectangle\n   * @param yOffset defines the y coordinates of the update rectangle\n   * @param width defines the width of the update rectangle\n   * @param height defines the height of the update rectangle\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\n   * @param lod defines the lod level to update (0 by default)\n   * @param generateMipMaps defines whether to generate mipmaps or not\n   */\n  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {\n    var _a;\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\n    if (generateMipMaps) {\n      this._generateMipmaps(texture, this._renderTargetEncoder);\n    }\n  }\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, imageData, faceIndex = 0, lod = 0) {\n    var _a;\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      texture.format = internalFormat;\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\n  }\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {\n    var _a;\n    const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\n    const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\n    const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\n    const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  }\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {\n    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\n  }\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {\n    var _a;\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource)) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n    if (image instanceof HTMLImageElement) {\n      throw \"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!\";\n    }\n    const bitmap = image; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\n    const width = Math.ceil(texture.width / (1 << lod));\n    const height = Math.ceil(texture.height / (1 << lod));\n    this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  }\n  /**\n   * Reads pixels from the current frame buffer. Please note that this function can be slow\n   * @param x defines the x coordinate of the rectangle where pixels must be read\n   * @param y defines the y coordinate of the rectangle where pixels must be read\n   * @param width defines the width of the rectangle where pixels must be read\n   * @param height defines the height of the rectangle where pixels must be read\n   * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true) {\n    const renderPassWrapper = this._rttRenderPassWrapper.renderPass ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\n    const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];\n    if (!hardwareTexture) {\n      // we are calling readPixels for a render pass with no color texture bound\n      return Promise.resolve(new Uint8Array(0));\n    }\n    const gpuTexture = hardwareTexture.underlyingResource;\n    const gpuTextureFormat = hardwareTexture.format;\n    if (!gpuTexture) {\n      // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\n      return Promise.resolve(new Uint8Array(0));\n    }\n    if (flushRenderer) {\n      this.flushFramebuffer();\n    }\n    return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);\n  }\n  //------------------------------------------------------------------------------\n  //                              Frame management\n  //------------------------------------------------------------------------------\n  /**\n   * Begin a new frame\n   */\n  beginFrame() {\n    super.beginFrame();\n  }\n  /**\n   * End the current frame\n   */\n  endFrame() {\n    this._snapshotRendering.endFrame(this._mainRenderPassWrapper.renderPass);\n    this._endMainRenderPass();\n    this._timestampQuery.endFrame(this._renderEncoder);\n    this.flushFramebuffer(false);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - counters\");\n      }\n    }\n    this._textureHelper.destroyDeferredTextures();\n    this._bufferManager.destroyDeferredBuffers();\n    if (this._features._collectUbosUpdatedInFrame) {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          const list = [];\n          for (const name in UniformBuffer._UpdatedUbosInFrame) {\n            list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\n          }\n          console.log(\"frame #\" + this._count + \" - updated ubos -\", list.join(\", \"));\n        }\n      }\n      UniformBuffer._UpdatedUbosInFrame = {};\n    }\n    this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\n    this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\n    this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\n    this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\n    this._counters.numEnableEffects = 0;\n    this._counters.numEnableDrawWrapper = 0;\n    this._counters.numBundleCreationNonCompatMode = 0;\n    this._counters.numBundleReuseNonCompatMode = 0;\n    this._cacheRenderPipeline.endFrame();\n    this._cacheBindGroups.endFrame();\n    this._pendingDebugCommands.length = 0;\n    super.endFrame();\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"%c frame #\" + this._count + \" - end\", \"background: #ffff00\");\n      }\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        this._count++;\n        if (this._count !== this.dbgVerboseLogsNumFrames) {\n          console.log(\"%c frame #\" + this._count + \" - begin\", \"background: #ffff00\");\n        }\n      }\n    }\n  }\n  /**\n   * Force a WebGPU flush (ie. a flush of all waiting commands)\n   * @param reopenPass true to reopen at the end of the function the pass that was active when entering the function\n   */\n  flushFramebuffer(reopenPass = true) {\n    // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\n    const currentRenderPassIsNULL = !this._currentRenderPass;\n    let currentPasses = 0; // 0 if no pass, 1 for rtt, 2 for main pass\n    if (this._currentRenderPass && this._currentRenderTarget) {\n      currentPasses |= 1;\n      this._endRenderTargetRenderPass();\n    }\n    if (this._mainRenderPassWrapper.renderPass) {\n      currentPasses |= 2;\n      this._endMainRenderPass();\n    }\n    this._commandBuffers[0] = this._uploadEncoder.finish();\n    this._commandBuffers[1] = this._renderTargetEncoder.finish();\n    this._commandBuffers[2] = this._renderEncoder.finish();\n    this._device.queue.submit(this._commandBuffers);\n    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\n    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\n    this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\n    this._timestampQuery.startFrame(this._uploadEncoder);\n    this._textureHelper.setCommandEncoder(this._uploadEncoder);\n    this._bundleList.reset();\n    this._bundleListRenderTarget.reset();\n    // restart the render pass\n    if (reopenPass) {\n      if (currentPasses & 2) {\n        this._startMainRenderPass(false);\n      }\n      if (currentPasses & 1) {\n        this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\n      }\n      if (currentRenderPassIsNULL && this._currentRenderTarget) {\n        this._currentRenderPass = null;\n      }\n    }\n  }\n  /** @internal */\n  _currentFrameBufferIsDefaultFrameBuffer() {\n    return this._currentRenderTarget === null;\n  }\n  //------------------------------------------------------------------------------\n  //                              Render Pass\n  //------------------------------------------------------------------------------\n  _startRenderTargetRenderPass(renderTargetWrapper, setClearStates, clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n    const rtWrapper = renderTargetWrapper;\n    const depthStencilTexture = rtWrapper._depthStencilTexture;\n    const gpuDepthStencilWrapper = depthStencilTexture === null || depthStencilTexture === void 0 ? void 0 : depthStencilTexture._hardwareTexture;\n    const gpuDepthStencilTexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.underlyingResource;\n    const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper === null || gpuDepthStencilWrapper === void 0 ? void 0 : gpuDepthStencilWrapper.msaaTexture;\n    const depthTextureView = gpuDepthStencilTexture === null || gpuDepthStencilTexture === void 0 ? void 0 : gpuDepthStencilTexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    const depthMSAATextureView = gpuDepthStencilMSAATexture === null || gpuDepthStencilMSAATexture === void 0 ? void 0 : gpuDepthStencilMSAATexture.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;\n    const colorAttachments = [];\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n    const mustClearColor = setClearStates && clearColor;\n    const mustClearDepth = setClearStates && clearDepth;\n    const mustClearStencil = setClearStates && clearStencil;\n    if (rtWrapper._attachments && rtWrapper.isMulti) {\n      // multi render targets\n      if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\n        this._mrtAttachments = rtWrapper._defaultAttachments;\n      }\n      for (let i = 0; i < this._mrtAttachments.length; ++i) {\n        const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\n        const mrtTexture = rtWrapper.textures[i];\n        const gpuMRTWrapper = mrtTexture === null || mrtTexture === void 0 ? void 0 : mrtTexture._hardwareTexture;\n        const gpuMRTTexture = gpuMRTWrapper === null || gpuMRTWrapper === void 0 ? void 0 : gpuMRTWrapper.underlyingResource;\n        if (gpuMRTWrapper && gpuMRTTexture) {\n          const viewDescriptor = {\n            ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\n            format: gpuMRTWrapper.format\n          };\n          const gpuMSAATexture = gpuMRTWrapper.msaaTexture;\n          const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\n          const colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(viewDescriptor);\n          colorAttachments.push({\n            view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n            resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n            clearValue: index !== 0 && mustClearColor ? clearColor : undefined,\n            loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n            storeOp: WebGPUConstants.StoreOp.Store\n          });\n        }\n      }\n      this._cacheRenderPipeline.setMRT(rtWrapper.textures, this._mrtAttachments.length);\n      this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n    } else {\n      // single render target\n      const internalTexture = rtWrapper.texture;\n      if (internalTexture) {\n        const gpuWrapper = internalTexture._hardwareTexture;\n        const gpuTexture = gpuWrapper.underlyingResource;\n        const gpuMSAATexture = gpuWrapper.msaaTexture;\n        const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n        const colorMSAATextureView = gpuMSAATexture === null || gpuMSAATexture === void 0 ? void 0 : gpuMSAATexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n        colorAttachments.push({\n          view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n          resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n          clearValue: mustClearColor ? clearColor : undefined,\n          loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        });\n      } else {\n        colorAttachments.push(null);\n      }\n    }\n    (_a = this._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(this, \"render target pass\", 1);\n    this._rttRenderPassWrapper.renderPassDescriptor = {\n      colorAttachments,\n      depthStencilAttachment: depthStencilTexture && gpuDepthStencilTexture ? {\n        view: depthMSAATextureView ? depthMSAATextureView : depthTextureView,\n        depthClearValue: mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined,\n        depthLoadOp: mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\n        stencilLoadOp: !depthTextureHasStencil ? undefined : rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        stencilStoreOp: !depthTextureHasStencil ? undefined : WebGPUConstants.StoreOp.Store\n      } : undefined,\n      occlusionQuerySet: ((_b = this._occlusionQuery) === null || _b === void 0 ? void 0 : _b.hasQueries) ? this._occlusionQuery.querySet : undefined\n    };\n    this._rttRenderPassWrapper.renderPass = this._renderTargetEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        const internalTexture = rtWrapper.texture;\n        console.log(\"frame #\" + this._count + \" - render target begin pass - internalTexture.uniqueId=\", internalTexture.uniqueId, \"width=\", internalTexture.width, \"height=\", internalTexture.height, this._rttRenderPassWrapper.renderPassDescriptor);\n      }\n    }\n    this._currentRenderPass = this._rttRenderPassWrapper.renderPass;\n    (_c = this._debugFlushPendingCommands) === null || _c === void 0 ? void 0 : _c.call(this);\n    this._resetCurrentViewport(1);\n    this._resetCurrentScissor(1);\n    this._resetCurrentStencilRef(1);\n    this._resetCurrentColorBlend(1);\n    if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\n      this._stencilStateComposer.enabled = false;\n    }\n  }\n  /** @internal */\n  _endRenderTargetRenderPass() {\n    var _a, _b, _c, _d;\n    if (this._currentRenderPass) {\n      const gpuWrapper = (_a = this._currentRenderTarget.texture) === null || _a === void 0 ? void 0 : _a._hardwareTexture;\n      if (gpuWrapper && !this._snapshotRendering.endRenderTargetPass(this._currentRenderPass, gpuWrapper) && !this.compatibilityMode) {\n        this._bundleListRenderTarget.run(this._currentRenderPass);\n        this._bundleListRenderTarget.reset();\n      }\n      this._currentRenderPass.end();\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - render target end pass - internalTexture.uniqueId=\", (_c = (_b = this._currentRenderTarget) === null || _b === void 0 ? void 0 : _b.texture) === null || _c === void 0 ? void 0 : _c.uniqueId);\n        }\n      }\n      (_d = this._debugPopGroup) === null || _d === void 0 ? void 0 : _d.call(this, 1);\n      this._resetCurrentViewport(1);\n      this._resetCurrentScissor(1);\n      this._resetCurrentStencilRef(1);\n      this._resetCurrentColorBlend(1);\n      this._currentRenderPass = null;\n      this._rttRenderPassWrapper.reset();\n    }\n  }\n  _getCurrentRenderPass() {\n    if (this._currentRenderTarget && !this._currentRenderPass) {\n      // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\n      this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\n    } else if (!this._currentRenderPass) {\n      this._startMainRenderPass(false);\n    }\n    return this._currentRenderPass;\n  }\n  /** @internal */\n  _getCurrentRenderPassIndex() {\n    return this._currentRenderPass === null ? -1 : this._currentRenderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\n  }\n  _startMainRenderPass(setClearStates, clearColor, clearDepth, clearStencil) {\n    var _a, _b, _c;\n    if (this._mainRenderPassWrapper.renderPass) {\n      this.flushFramebuffer(false);\n    }\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n    const mustClearColor = setClearStates && clearColor;\n    const mustClearDepth = setClearStates && clearDepth;\n    const mustClearStencil = setClearStates && clearStencil;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].clearValue = mustClearColor ? clearColor : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthClearValue = mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilLoadOp = !this.isStencilEnable ? undefined : mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet = ((_a = this._occlusionQuery) === null || _a === void 0 ? void 0 : _a.hasQueries) ? this._occlusionQuery.querySet : undefined;\n    const swapChainTexture = this._context.getCurrentTexture();\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].set(swapChainTexture);\n    // Resolve in case of MSAA\n    if (this._options.antialiasing) {\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].resolveTarget = swapChainTexture.createView();\n    } else {\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView();\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - main begin pass - texture width=\" + this._mainTextureExtends.width, \" height=\" + this._mainTextureExtends.height, this._mainRenderPassWrapper.renderPassDescriptor);\n      }\n    }\n    (_b = this._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(this, \"main pass\", 0);\n    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor);\n    this._mainRenderPassWrapper.renderPass = this._currentRenderPass;\n    (_c = this._debugFlushPendingCommands) === null || _c === void 0 ? void 0 : _c.call(this);\n    this._resetCurrentViewport(0);\n    this._resetCurrentScissor(0);\n    this._resetCurrentStencilRef(0);\n    this._resetCurrentColorBlend(0);\n    if (!this._isStencilEnable) {\n      this._stencilStateComposer.enabled = false;\n    }\n  }\n  _endMainRenderPass() {\n    var _a;\n    if (this._mainRenderPassWrapper.renderPass !== null) {\n      this._snapshotRendering.endMainRenderPass();\n      if (!this.compatibilityMode && !this._snapshotRendering.play) {\n        this._bundleList.run(this._mainRenderPassWrapper.renderPass);\n        this._bundleList.reset();\n      }\n      this._mainRenderPassWrapper.renderPass.end();\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          console.log(\"frame #\" + this._count + \" - main end pass\");\n        }\n      }\n      (_a = this._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(this, 0);\n      this._resetCurrentViewport(0);\n      this._resetCurrentScissor(0);\n      this._resetCurrentStencilRef(0);\n      this._resetCurrentColorBlend(0);\n      if (this._mainRenderPassWrapper.renderPass === this._currentRenderPass) {\n        this._currentRenderPass = null;\n      }\n      this._mainRenderPassWrapper.reset(false);\n    }\n  }\n  /**\n   * Binds the frame buffer to the specified texture.\n   * @param texture The render target wrapper to render to\n   * @param faceIndex The face of the texture to render to in case of cube texture\n   * @param requiredWidth The width of the target to render to\n   * @param requiredHeight The height of the target to render to\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n   * @param lodLevel defines the lod level to bind to the frame buffer\n   * @param layer defines the 2d array index to bind to frame buffer to\n   */\n  bindFramebuffer(texture, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {\n    var _a, _b;\n    const hardwareTexture = (_a = texture.texture) === null || _a === void 0 ? void 0 : _a._hardwareTexture;\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n    this._currentRenderTarget = texture;\n    if (hardwareTexture) {\n      hardwareTexture._currentLayer = texture.isCube ? layer * 6 + faceIndex : layer;\n    }\n    this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\n    this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format) : undefined;\n    this._setDepthTextureFormat(this._rttRenderPassWrapper);\n    this._setColorFormat(this._rttRenderPassWrapper);\n    this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\n      format: this._colorFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: lodLevel,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n    this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\n      format: this._depthTextureFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: 0,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - bindFramebuffer called - internalTexture.uniqueId=\", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId, \"face=\", faceIndex, \"lodLevel=\", lodLevel, \"layer=\", layer, this._rttRenderPassWrapper.colorAttachmentViewDescriptor, this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n      }\n    }\n    this._currentRenderPass = null; // lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\n    if (this.snapshotRendering && this.snapshotRenderingMode === 1) {\n      // force the creation of the render pass as we know in fast snapshot rendering mode clear() won't be called\n      this._getCurrentRenderPass();\n    }\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    } else {\n      if (!requiredWidth) {\n        requiredWidth = texture.width;\n        if (lodLevel) {\n          requiredWidth = requiredWidth / Math.pow(2, lodLevel);\n        }\n      }\n      if (!requiredHeight) {\n        requiredHeight = texture.height;\n        if (lodLevel) {\n          requiredHeight = requiredHeight / Math.pow(2, lodLevel);\n        }\n      }\n      this._viewport(0, 0, requiredWidth, requiredHeight);\n    }\n    this.wipeCaches();\n  }\n  /**\n   * Unbind the current render target texture from the WebGPU context\n   * @param texture defines the render target wrapper to unbind\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\n   */\n  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {\n    var _a, _b;\n    const saveCRT = this._currentRenderTarget;\n    this._currentRenderTarget = null; // to be iso with thinEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._currentRenderTarget = saveCRT;\n    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\n      this._endRenderTargetRenderPass();\n    }\n    if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture.texture);\n    }\n    this._currentRenderTarget = null;\n    this._onAfterUnbindFrameBufferObservable.notifyObservers(this);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        console.log(\"frame #\" + this._count + \" - unBindFramebuffer called - internalTexture.uniqueId=\", (_b = texture.texture) === null || _b === void 0 ? void 0 : _b.uniqueId);\n      }\n    }\n    this._mrtAttachments = [];\n    this._cacheRenderPipeline.setMRT([]);\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n    this._setColorFormat(this._mainRenderPassWrapper);\n  }\n  /**\n   * Unbind the current render target and bind the default framebuffer\n   */\n  restoreDefaultFramebuffer() {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    } else {\n      this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n      this._setDepthTextureFormat(this._mainRenderPassWrapper);\n      this._setColorFormat(this._mainRenderPassWrapper);\n    }\n    if (this._currentRenderPass) {\n      if (this._cachedViewport) {\n        this.setViewport(this._cachedViewport);\n      }\n    }\n    this.wipeCaches();\n  }\n  //------------------------------------------------------------------------------\n  //                              Render\n  //------------------------------------------------------------------------------\n  /**\n   * @internal\n   */\n  _setColorFormat(wrapper) {\n    var _a, _b;\n    const format = (_b = (_a = wrapper.colorAttachmentGPUTextures[0]) === null || _a === void 0 ? void 0 : _a.format) !== null && _b !== void 0 ? _b : null;\n    this._cacheRenderPipeline.setColorFormat(format);\n    if (this._colorFormat === format) {\n      return;\n    }\n    this._colorFormat = format;\n  }\n  /**\n   * @internal\n   */\n  _setDepthTextureFormat(wrapper) {\n    this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\n    if (this._depthTextureFormat === wrapper.depthTextureFormat) {\n      return;\n    }\n    this._depthTextureFormat = wrapper.depthTextureFormat;\n  }\n  setDitheringState() {\n    // Does not exist in WebGPU\n  }\n  setRasterizerState() {\n    // Does not exist in WebGPU\n  }\n  /**\n   * Set various states to the webGL context\n   * @param culling defines culling state: true to enable culling, false to disable it\n   * @param zOffset defines the value to apply to zOffset (0 by default)\n   * @param force defines if states must be applied even if cache is up to date\n   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n   * @param stencil stencil states to set\n   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n   */\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {\n    var _a, _b;\n    // Culling\n    if (this._depthCullingState.cull !== culling || force) {\n      this._depthCullingState.cull = culling;\n    }\n    // Cull face\n    const cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? 1 : 2;\n    if (this._depthCullingState.cullFace !== cullFace || force) {\n      this._depthCullingState.cullFace = cullFace;\n    }\n    // Z offset\n    this.setZOffset(zOffset);\n    this.setZOffsetUnits(zOffsetUnits);\n    // Front face\n    const frontFace = reverseSide ? this._currentRenderTarget ? 1 : 2 : this._currentRenderTarget ? 2 : 1;\n    if (this._depthCullingState.frontFace !== frontFace || force) {\n      this._depthCullingState.frontFace = frontFace;\n    }\n    this._stencilStateComposer.stencilMaterial = stencil;\n  }\n  _applyRenderPassChanges(renderPass, bundleList) {\n    var _a;\n    const mustUpdateViewport = this._mustUpdateViewport(renderPass);\n    const mustUpdateScissor = this._mustUpdateScissor(renderPass);\n    const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef(renderPass);\n    const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor(renderPass);\n    if (bundleList) {\n      if (mustUpdateViewport) {\n        bundleList.addItem(new WebGPURenderItemViewport(this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w));\n      }\n      if (mustUpdateScissor) {\n        bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\n      }\n      if (mustUpdateStencilRef) {\n        bundleList.addItem(new WebGPURenderItemStencilRef((_a = this._stencilStateComposer.funcRef) !== null && _a !== void 0 ? _a : 0));\n      }\n      if (mustUpdateBlendColor) {\n        bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\n      }\n    } else {\n      if (mustUpdateViewport) {\n        this._applyViewport(renderPass);\n      }\n      if (mustUpdateScissor) {\n        this._applyScissor(renderPass);\n      }\n      if (mustUpdateStencilRef) {\n        this._applyStencilRef(renderPass);\n      }\n      if (mustUpdateBlendColor) {\n        this._applyBlendColor(renderPass);\n      }\n    }\n  }\n  _draw(drawType, fillMode, start, count, instancesCount) {\n    var _a;\n    const renderPass = this._getCurrentRenderPass();\n    const renderPassIndex = this._getCurrentRenderPassIndex();\n    const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\n    this.applyStates();\n    const webgpuPipelineContext = this._currentEffect._pipelineContext;\n    this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\n    if (webgpuPipelineContext.uniformBuffer) {\n      webgpuPipelineContext.uniformBuffer.update();\n      this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer(), 0, WebGPUShaderProcessor.LeftOvertUBOName);\n    }\n    if (this._snapshotRendering.play) {\n      this._reportDrawCall();\n      return;\n    }\n    if (!this.compatibilityMode && (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)) {\n      this._currentDrawContext.fastBundle = undefined;\n    }\n    const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\n    let renderPass2 = renderPass;\n    if (useFastPath || this._snapshotRendering.record) {\n      this._applyRenderPassChanges(renderPass, bundleList);\n      if (!this._snapshotRendering.record) {\n        this._counters.numBundleReuseNonCompatMode++;\n        if (this._currentDrawContext.indirectDrawBuffer) {\n          this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n        }\n        bundleList.addBundle(this._currentDrawContext.fastBundle);\n        this._reportDrawCall();\n        return;\n      }\n      renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\n      bundleList.numDrawCalls++;\n    }\n    let textureState = 0;\n    if (!this._caps.textureFloatLinearFiltering && this._currentMaterialContext.hasFloatTextures) {\n      let bitVal = 1;\n      for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\n        const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\n        const texture = (_a = this._currentMaterialContext.textures[textureName]) === null || _a === void 0 ? void 0 : _a.texture;\n        if ((texture === null || texture === void 0 ? void 0 : texture.type) === 1) {\n          textureState |= bitVal;\n        }\n        bitVal = bitVal << 1;\n      }\n    }\n    const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect, this.currentSampleCount, textureState);\n    const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\n    if (!this._snapshotRendering.record) {\n      this._applyRenderPassChanges(renderPass, !this.compatibilityMode ? bundleList : null);\n      if (!this.compatibilityMode) {\n        this._counters.numBundleCreationNonCompatMode++;\n        renderPass2 = this._device.createRenderBundleEncoder({\n          colorFormats: this._cacheRenderPipeline.colorFormats,\n          depthStencilFormat: this._depthTextureFormat,\n          sampleCount: this.currentSampleCount\n        });\n      }\n    }\n    // bind pipeline\n    renderPass2.setPipeline(pipeline);\n    // bind index/vertex buffers\n    if (this._currentIndexBuffer) {\n      renderPass2.setIndexBuffer(this._currentIndexBuffer.underlyingResource, this._currentIndexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16, 0);\n    }\n    const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\n    for (let index = 0; index < vertexBuffers.length; index++) {\n      const vertexBuffer = vertexBuffers[index];\n      const buffer = vertexBuffer.getBuffer();\n      if (buffer) {\n        renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\n      }\n    }\n    // bind bind groups\n    for (let i = 0; i < bindGroups.length; i++) {\n      renderPass2.setBindGroup(i, bindGroups[i]);\n    }\n    // draw\n    const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\n    if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {\n      this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n      if (drawType === 0) {\n        renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      } else {\n        renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      }\n    } else if (drawType === 0) {\n      renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\n    } else {\n      renderPass2.draw(count, instancesCount || 1, start, 0);\n    }\n    if (nonCompatMode) {\n      this._currentDrawContext.fastBundle = renderPass2.finish();\n      bundleList.addBundle(this._currentDrawContext.fastBundle);\n    }\n    this._reportDrawCall();\n  }\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount = 1) {\n    this._draw(0, fillMode, indexStart, indexCount, instancesCount);\n  }\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount = 1) {\n    this._currentIndexBuffer = null;\n    this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\n  }\n  //------------------------------------------------------------------------------\n  //                              Dispose\n  //------------------------------------------------------------------------------\n  /**\n   * Dispose and release all associated resources\n   */\n  dispose() {\n    var _a, _b;\n    (_a = this._mainTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this._depthTexture) === null || _b === void 0 ? void 0 : _b.destroy();\n    super.dispose();\n  }\n  //------------------------------------------------------------------------------\n  //                              Misc\n  //------------------------------------------------------------------------------\n  /**\n   * Gets the current render width\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render width\n   */\n  getRenderWidth(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return this._canvas.width;\n  }\n  /**\n   * Gets the current render height\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render height\n   */\n  getRenderHeight(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return this._canvas.height;\n  }\n  /**\n   * Gets the HTML canvas attached with the current WebGPU context\n   * @returns a HTML canvas\n   */\n  getRenderingCanvas() {\n    return this._canvas;\n  }\n  //------------------------------------------------------------------------------\n  //                              Errors\n  //------------------------------------------------------------------------------\n  /**\n   * Get the current error code of the WebGPU context\n   * @returns the error code\n   */\n  getError() {\n    // TODO WEBGPU. from the webgpu errors.\n    return 0;\n  }\n  //------------------------------------------------------------------------------\n  //                              Unused WebGPU\n  //------------------------------------------------------------------------------\n  /**\n   * @internal\n   */\n  bindSamplers() {}\n  /**\n   * @internal\n   */\n  _bindTextureDirectly() {\n    return false;\n  }\n  /**\n   * Gets a boolean indicating if all created effects are ready\n   * @returns always true - No parallel shader compilation\n   */\n  areAllEffectsReady() {\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {\n    // No parallel shader compilation.\n    // No Async, so direct launch\n    action();\n  }\n  /**\n   * @internal\n   */\n  _isRenderingStateCompiled() {\n    // No parallel shader compilation.\n    return true;\n  }\n  /** @internal */\n  _getUnpackAlignement() {\n    return 1;\n  }\n  /**\n   * @internal\n   */\n  _unpackFlipY() {}\n  /**\n   * @internal\n   */\n  _bindUnboundFramebuffer() {\n    throw \"_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead\";\n  }\n  // TODO WEBGPU. All of the below should go once engine split with baseEngine.\n  /**\n   * @internal\n   */\n  _getSamplingParameters() {\n    throw \"_getSamplingParameters is not available in WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  getUniforms() {\n    return [];\n  }\n  /**\n   * @internal\n   */\n  setIntArray() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray4() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray4() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrices() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrix3x3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrix2x2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat4() {\n    return false;\n  }\n}\n// Default glslang options.\nWebGPUEngine._GLSLslangDefaultOptions = {\n  jsPath: \"https://preview.babylonjs.com/glslang/glslang.js\",\n  wasmPath: \"https://preview.babylonjs.com/glslang/glslang.wasm\"\n};\n/** true to enable using TintWASM to convert Spir-V to WGSL */\nWebGPUEngine.UseTWGSL = true;","map":{"version":3,"mappings":"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","names":["Logger","IsWindowObjectExist","Color4","Engine","InternalTexture","InternalTextureSource","Effect","WebGPUConstants","VertexBuffer","WebGPUPipelineContext","WebGPUShaderProcessorGLSL","WebGPUShaderProcessorWGSL","WebGPUShaderProcessingContext","Tools","WebGPUTextureHelper","WebGPUBufferManager","WebGPUHardwareTexture","UniformBuffer","WebGPURenderPassWrapper","WebGPUCacheSampler","WebGPUCacheRenderPipelineTree","WebGPUStencilStateComposer","WebGPUDepthCullingState","DrawWrapper","WebGPUMaterialContext","WebGPUDrawContext","WebGPUCacheBindGroups","WebGPUClearQuad","WebGPURenderItemBlendColor","WebGPURenderItemScissor","WebGPURenderItemStencilRef","WebGPURenderItemViewport","WebGPUBundleList","WebGPUTimestampQuery","WebGPUOcclusionQuery","Observable","ShaderCodeInliner","WebGPUTintWASM","WebGPUShaderProcessor","ShaderLanguage","WebGPUSnapshotRendering","PerformanceConfigurator","WebGPUEngine","constructor","canvas","options","label","numEnableEffects","numEnableDrawWrapper","numBundleCreationNonCompatMode","numBundleReuseNonCompatMode","x","y","w","h","z","_name","isNDCHalfZRange","hasOriginBottomLeft","deviceDescriptor","antialiasing","undefined","stencil","enableGPUDebugMarkers","SetMatrixPrecision","useHighPrecisionMatrix","Log","Version","description","navigator","gpu","Error","swapChainFormat","getPreferredCanvasFormat","_isWebGPU","_shaderPlatformName","deterministicLockstep","lockstepMaxSteps","audioEngine","_deterministicLockstep","_lockstepMaxSteps","_timeStep","timeStep","_doNotHandleContextLost","doNotHandleContextLost","_canvas","_options","premultipliedAlpha","devicePixelRatio","window","limitDeviceRatio","adaptToDeviceRatio","_hardwareScalingLevel","Math","min","_mainPassSampleCount","_defaultSampleCount","_isStencilEnable","_sharedInit","doNotHandleTouchAction","_shaderProcessor","_shaderProcessorWGSL","snapshotRenderingMode","_snapshotRendering","mode","snapshotRenderingReset","reset","snapshotRendering","enabled","activate","disableCacheSamplers","_cacheSampler","disabled","disable","disableCacheRenderPipelines","_cacheRenderPipeline","disableCacheBindGroups","_cacheBindGroups","IsSupportedAsync","Promise","resolve","requestAdapter","then","adapter","catch","IsSupported","Warn","supportsUniformBuffers","supportedExtensions","_adapterSupportedExtensions","enabledExtensions","_deviceEnabledExtensions","name","version","getInfo","vendor","renderer","compatibilityMode","_compatibilityMode","currentSampleCount","_currentRenderTarget","samples","CreateAsync","engine","initAsync","glslangOptions","twgslOptions","_initGlslang","glslang","_glslang","_tintWASM","UseTWGSL","initTwgsl","msg","_adapter","features","forEach","feature","push","requiredFeatures","requestedExtensions","validExtensions","extension","indexOf","requestDevice","device","_device","numUncapturedErrors","addEventListener","event","numMaxUncapturedErrors","error","message","lost","info","_contextWasLost","onContextLostObservable","notifyObservers","_restoreEngineAfterContextLost","bind","e","_bufferManager","_textureHelper","_timestampQuery","_occlusionQuery","createQuerySet","_bundleList","_bundleListRenderTarget","_snapshotRenderingMode","_ubInvertY","createBuffer","Float32Array","BufferUsage","Uniform","CopyDst","_ubDontInvertY","dbgVerboseLogsForFirstFrames","_count","console","log","_uploadEncoder","createCommandEncoder","_uploadEncoderDescriptor","_renderEncoder","_renderEncoderDescriptor","_renderTargetEncoder","_renderTargetEncoderDescriptor","_emptyVertexBuffer","_initializeLimits","_caps","textureFloatLinearFiltering","_depthCullingState","_stencilStateComposer","stencilGlobal","_stencilState","depthTest","depthFunc","depthMask","setCommandEncoder","_clearQuad","_defaultDrawContext","createDrawContext","_currentDrawContext","_defaultMaterialContext","createMaterialContext","_currentMaterialContext","_initializeContextAndSwapChain","_initializeMainAttachments","resize","trace","_GLSLslangDefaultOptions","self","wasmPath","jsPath","LoadScriptAsync","importScripts","reject","maxTexturesImageUnits","maxVertexTextureImageUnits","maxCombinedTexturesImageUnits","maxTextureSize","maxCubemapTextureSize","maxRenderTextureSize","maxVertexAttribs","maxVaryingVectors","maxFragmentUniformVectors","maxVertexUniformVectors","standardDerivatives","astc","FeatureName","TextureCompressionASTC","s3tc","TextureCompressionBC","pvrtc","etc1","etc2","TextureCompressionETC2","bptc","maxAnisotropy","uintIndices","fragmentDepthSupported","highPrecisionShaderSupported","colorBufferFloat","textureFloat","textureFloatRender","textureHalfFloat","textureHalfFloatLinearFiltering","textureHalfFloatRender","textureLOD","drawBuffersExtension","depthTextureExtension","vertexArrayObject","instancedArrays","timerQuery","BigUint64Array","TimestampQuery","supportOcclusionQuery","canUseTimestampForTimerQuery","multiview","oculusMultiview","parallelShaderCompile","blendMinMax","maxMSAASamples","canUseGLInstanceID","canUseGLVertexID","supportComputeShaders","supportSRGBBuffers","supportTransformFeedbacks","textureMaxLevel","texture2DArrayMaxLayerCount","_features","forceBitmapOverHTMLImageElement","supportRenderAndCopyToLodForFloatTextures","supportDepthStencilTexture","supportShadowSamplers","uniformBufferHardCheckMatrix","allowTexturePrefiltering","trackUbosInFrame","checkUbosContentBeforeUpload","supportCSM","basisNeedsPOT","support3DTextures","needTypeSuffixInShaderConstants","supportMSAA","supportSSAO2","supportExtendedTextureFormats","supportSwitchCaseInShader","supportSyncTextureRead","needsInvertingBitmap","useUBOBindingCache","needShaderCodeInlining","needToAlwaysBindUniformBuffers","supportRenderPasses","supportSpriteInstancing","_collectUbosUpdatedInFrame","_context","getContext","_configureContext","_colorFormat","_mainRenderPassWrapper","colorAttachmentGPUTextures","format","flushFramebuffer","_mainTextureExtends","width","getRenderWidth","height","getRenderHeight","depthOrArrayLayers","bufferDataUpdate","setSubData","mainColorAttachments","mainTextureDescriptor","size","mipLevelCount","sampleCount","dimension","TextureDimension","E2d","usage","TextureUsage","RenderAttachment","_mainTexture","releaseTexture","createTexture","view","createView","clearValue","loadOp","LoadOp","Clear","storeOp","StoreOp","Store","depthTextureFormat","isStencilEnable","TextureFormat","Depth24PlusStencil8","Depth32Float","_setDepthTextureFormat","depthTextureDescriptor","_depthTexture","mainDepthAttachment","depthClearValue","_clearDepthValue","depthLoadOp","depthStoreOp","stencilClearValue","_clearStencilValue","stencilLoadOp","stencilStoreOp","renderPassDescriptor","colorAttachments","depthStencilAttachment","configure","CopySrc","alphaMode","CanvasAlphaMode","Premultiplied","Opaque","setSize","forceSetSize","dbgVerboseLogsNumFrames","_getShaderProcessor","shaderLanguage","WGSL","_getShaderProcessingContext","applyStates","apply","setAlphaBlendEnabled","_alphaState","alphaBlend","wipeCaches","bruteForce","preventCacheWipeBetweenFrames","_forceEnableEffect","_currentIndexBuffer","_currentOverrideVertexBuffers","setBuffers","_alphaMode","_alphaEquation","setAlphaBlendFactors","_blendFunctionParameters","_blendEquationParameters","setColorWrite","_cachedVertexBuffers","_cachedIndexBuffer","_cachedEffectForVertexBuffers","enable","_colorWriteLocal","setWriteMask","getColorWrite","_resetCurrentViewport","index","_viewportsCurrent","_viewportCached","_mustUpdateViewport","renderPass","update","_applyViewport","floor","setViewport","_viewport","_resetCurrentScissor","_scissorsCurrent","_mustUpdateScissor","_scissorCached","_applyScissor","setScissorRect","_scissorIsActive","enableScissor","disableScissor","_resetCurrentStencilRef","_stencilRefsCurrent","_mustUpdateStencilRef","funcRef","_applyStencilRef","setStencilReference","_resetCurrentColorBlend","_blendColorsCurrent","_mustUpdateBlendColor","colorBlend","_blendConstants","_applyBlendColor","setBlendConstant","clear","color","backBuffer","depth","a","hasScissor","_rttRenderPassWrapper","_startRenderTargetRenderPass","addItem","_currentRenderPass","_clearFullQuad","_endRenderTargetRenderPass","_startMainRenderPass","clearColor","clearDepth","clearStencil","_getCurrentRenderPass","renderPassIndex","_getCurrentRenderPassIndex","bundleList","setColorFormat","setDepthStencilFormat","_depthTextureFormat","setMRTAttachments","mrtAttachments","mrtTextureArray","mrtTextureCount","bundle","addBundle","_reportDrawCall","createVertexBuffer","data","Array","ArrayBuffer","Uint8Array","dataBuffer","Vertex","createDynamicVertexBuffer","createIndexBuffer","indices","is32Bits","Uint32Array","Int32Array","Uint16Array","length","Index","_createBuffer","creationFlags","flags","Storage","bindBuffersDirectly","updateAndBindInstancesBuffer","bindBuffers","vertexBuffers","indexBuffer","effect","overrideVertexBuffers","_releaseBuffer","buffer","releaseBuffer","createEffect","baseName","attributesNamesOrOptions","uniformsNamesOrEngine","samplers","defines","fallbacks","onCompiled","onError","indexParameters","GLSL","vertex","vertexElement","vertexToken","vertexSource","fragment","fragmentElement","fragmentToken","fragmentSource","globalDefines","_getGlobalDefines","fullDefines","_compiledEffects","compiledEffect","isReady","_compileRawShaderToSpirV","source","type","compileGLSL","_compileShaderToSpirV","shaderVersion","_getWGSLShader","split","join","_createPipelineStageDescriptor","vertexShader","fragmentShader","convertSpirV2WGSL","vertexStage","module","createShaderModule","code","entryPoint","fragmentStage","_compileRawPipelineStageDescriptor","vertexCode","fragmentCode","_compilePipelineStageDescriptor","onBeforeShaderCompilationObservable","program","onAfterShaderCompilationObservable","createRawShaderProgram","createShaderProgram","inlineShaderCode","sci","debug","processCode","createPipelineContext","shaderProcessingContext","_preparePipelineContext","pipelineContext","vertexSourceCode","fragmentSourceCode","createAsRaw","rawVertexSourceCode","rawFragmentSourceCode","rebuildRebind","webGpuContext","dbgShowShaderCode","sources","rawVertex","rawFragment","stages","getAttributes","attributesNames","results","gpuPipelineContext","i","attributeName","attributeLocation","availableAttributes","enableEffect","isNewEffect","IsWrapper","_currentEffect","_counters","dbgLogIfNotDrawWrapper","uniqueId","materialContext","drawContext","dbgShowEmptyEnableEffectCalls","stencilMaterial","onBind","_onBindObservable","_releaseEffect","_key","_deletePipelineContext","getPipelineContext","releaseEffects","webGPUPipelineContext","webgpuPipelineContext","dispose","needPOTTextures","_createHardwareTexture","_releaseTexture","texture","_internalTexturesCache","splice","_getRGBABufferInternalSizedFormat","updateTextureComparisonFunction","comparisonFunction","_comparisonFunction","_createInternalTexture","delayGPUTextureCreation","Unknown","fullOptions","generateMipMaps","samplingMode","useSRGBBuffer","layers","baseWidth","baseHeight","is2DArray","_cachedWrapU","_cachedWrapV","_useSRGBBuffer","createGPUTextureForInternalTexture","url","noMipmap","invertY","scene","mimeType","loaderOptions","_createTextureBase","onLoad","img","isCompressed","processFunction","imageBitmap","_hardwareTexture","underlyingResource","gpuTextureWrapper","IsImageBitmap","updateTexture","_generateMipmaps","removePendingData","onLoadedObservable","fallback","forcedExtension","wrapWebGPUTexture","hardwareTexture","internalTexture","wrapWebGLTexture","generateMipMapsForCubemap","gpuTexture","RenderTarget","MultiRenderTarget","updateTextureSamplingMode","updateTextureWrappingMode","wrapU","wrapV","wrapR","is3D","_cachedWrapR","updateTextureDimensions","additionalUsages","textureAdditionalUsages","release","_setInternalTexture","_pipelineContext","availableTexture","availableTextures","setTexture","autoBindSampler","samplerName","AutoSamplerSuffix","setSampler","channel","unused","_setTexture","setTextureArray","textures","toString","isPartOfTextureArray","depthStencilTexture","video","delayLoadState","delayLoad","getInternalTexture","isCube","emptyCubeTexture","emptyTexture3D","emptyTexture2DArray","emptyTexture","isMultiview","_cachedCoordinatesMode","coordinatesMode","textureWrapMode","_setAnisotropicLevel","anisotropicFilteringLevel","target","_cachedAnisotropicFilteringLevel","_bindTexture","generateMipmaps","commandEncoder","gpuHardwareTexture","mipmapCount","ComputeNumMipmapLevels","generateCubeMipmaps","updateTextureData","imageData","xOffset","yOffset","faceIndex","lod","byteOffset","byteLength","_uploadCompressedDataToTextureDirectly","internalFormat","_uploadDataToTextureDirectly","babylonInternalFormat","useTextureWidthAndHeight","lodMaxWidth","round","LOG2E","lodMaxHeight","pow","max","_uploadArrayBufferViewToTexture","_uploadImageToTexture","image","HTMLImageElement","bitmap","ceil","readPixels","hasAlpha","flushRenderer","renderPassWrapper","gpuTextureFormat","beginFrame","endFrame","_endMainRenderPass","destroyDeferredTextures","destroyDeferredBuffers","list","_UpdatedUbosInFrame","countersLastFrame","_pendingDebugCommands","reopenPass","currentRenderPassIsNULL","currentPasses","_commandBuffers","finish","queue","submit","startFrame","_currentFrameBufferIsDefaultFrameBuffer","renderTargetWrapper","setClearStates","rtWrapper","_depthStencilTexture","gpuDepthStencilWrapper","gpuDepthStencilTexture","gpuDepthStencilMSAATexture","msaaTexture","depthTextureView","depthAttachmentViewDescriptor","depthMSAATextureView","depthTextureHasStencil","HasStencilAspect","useReverseDepthBuffer","setDepthFunctionToGreaterOrEqual","mustClearColor","mustClearDepth","mustClearStencil","_attachments","isMulti","_mrtAttachments","_defaultAttachments","mrtTexture","gpuMRTWrapper","gpuMRTTexture","viewDescriptor","colorAttachmentViewDescriptor","gpuMSAATexture","colorTextureView","colorMSAATextureView","resolveTarget","Load","setMRT","gpuWrapper","_debugPushGroup","_clearReverseDepthValue","_depthStencilTextureWithStencil","occlusionQuerySet","hasQueries","querySet","beginRenderPass","_debugFlushPendingCommands","endRenderTargetPass","run","end","_debugPopGroup","swapChainTexture","getCurrentTexture","set","endMainRenderPass","play","bindFramebuffer","requiredWidth","requiredHeight","forceFullscreenViewport","lodLevel","layer","unBindFramebuffer","_currentLayer","GetWebGPUTextureFormat","_setColorFormat","TextureViewDimension","baseArrayLayer","baseMipLevel","arrayLayerCount","aspect","TextureAspect","All","_cachedViewport","disableGenerateMipMaps","onBeforeUnbind","saveCRT","_onAfterUnbindFrameBufferObservable","restoreDefaultFramebuffer","wrapper","setDitheringState","setRasterizerState","setState","culling","zOffset","force","reverseSide","cullBackFaces","zOffsetUnits","cull","cullFace","setZOffset","setZOffsetUnits","frontFace","_applyRenderPassChanges","mustUpdateViewport","mustUpdateScissor","mustUpdateStencilRef","mustUpdateBlendColor","slice","_draw","drawType","fillMode","start","count","instancesCount","bindUniformBufferBase","InternalsUBOName","uniformBuffer","getBuffer","LeftOvertUBOName","isDirty","updateId","forceBindGroupCreation","fastBundle","useFastPath","renderPass2","record","indirectDrawBuffer","setIndirectData","getBundleEncoder","colorFormats","numDrawCalls","textureState","hasFloatTextures","bitVal","textureNames","textureName","pipeline","getRenderPipeline","bindGroups","getBindGroups","createRenderBundleEncoder","depthStencilFormat","setPipeline","setIndexBuffer","IndexFormat","Uint32","Uint16","vertexBuffer","setVertexBuffer","_validOffsetRange","setBindGroup","nonCompatMode","drawIndexedIndirect","drawIndirect","drawIndexed","draw","drawElementsType","indexStart","indexCount","drawArraysType","verticesStart","verticesCount","destroy","useScreen","getRenderingCanvas","getError","bindSamplers","_bindTextureDirectly","areAllEffectsReady","_executeWhenRenderingStateIsCompiled","action","_isRenderingStateCompiled","_getUnpackAlignement","_unpackFlipY","_bindUnboundFramebuffer","_getSamplingParameters","getUniforms","setIntArray","setIntArray2","setIntArray3","setIntArray4","setArray","setArray2","setArray3","setArray4","setMatrices","setMatrix3x3","setMatrix2x2","setFloat","setFloat2","setFloat3","setFloat4"],"sourceRoot":"","sources":["../../../../lts/core/generated/Engines/webgpuEngine.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable, DataArray, IndicesArray, Immutable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IEffectCreationOptions } from \"../Materials/effect\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { Constants } from \"./constants\";\r\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IWebGPURenderPipelineStageDescriptor } from \"./WebGPU/webgpuPipelineContext\";\r\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL\";\r\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport type { ISceneLike } from \"./thinEngine\";\r\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { IColor4Like } from \"../Maths/math.like\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { WebGPURenderPassWrapper } from \"./WebGPU/webgpuRenderPassWrapper\";\r\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./WebGPU/webgpuCacheRenderPipeline\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree\";\r\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer\";\r\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext\";\r\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext\";\r\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups\";\r\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { ComputeEffect } from \"../Compute/computeEffect\";\r\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport type { TwgslOptions } from \"./WebGPU/webgpuTintWASM\";\r\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM\";\r\nimport type { ExternalTexture } from \"../Materials/Textures/externalTexture\";\r\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport type { WebGPUDataBuffer } from \"../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\nimport { PerformanceConfigurator } from \"./performanceConfigurator\";\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\n\r\ndeclare type VideoTexture = import(\"../Materials/Textures/videoTexture\").VideoTexture;\r\ndeclare type RenderTargetTexture = import(\"../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type RenderTargetWrapper = import(\"./renderTargetWrapper\").RenderTargetWrapper;\r\n\r\n/**\r\n * Options to load the associated Glslang library\r\n */\r\nexport interface GlslangOptions {\r\n    /**\r\n     * Defines an existing instance of Glslang (useful in modules who do not access the global instance).\r\n     */\r\n    glslang?: any;\r\n    /**\r\n     * Defines the URL of the glslang JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the glslang WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/**\r\n * Options to create the WebGPU engine\r\n */\r\nexport interface WebGPUEngineOptions extends GPURequestAdapterOptions {\r\n    /**\r\n     * If delta time between frames should be constant\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    deterministicLockstep?: boolean;\r\n\r\n    /**\r\n     * Maximum about of steps between frames (Default: 4)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    lockstepMaxSteps?: number;\r\n\r\n    /**\r\n     * Defines the seconds between each deterministic lock step\r\n     */\r\n    timeStep?: number;\r\n\r\n    /**\r\n     * Defines that engine should ignore context lost events\r\n     * If this event happens when this parameter is true, you will have to reload the page to restore rendering\r\n     */\r\n    doNotHandleContextLost?: boolean;\r\n\r\n    /**\r\n     * Defines that engine should ignore modifying touch action attribute and style\r\n     * If not handle, you might need to set it up on your side for expected touch devices behavior.\r\n     */\r\n    doNotHandleTouchAction?: boolean;\r\n\r\n    /**\r\n     * Defines if webaudio should be initialized as well\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n     */\r\n    audioEngine?: boolean;\r\n\r\n    /**\r\n     * Defines the category of adapter to use.\r\n     * Is it the discrete or integrated device.\r\n     */\r\n    powerPreference?: GPUPowerPreference;\r\n\r\n    /**\r\n     * Defines the device descriptor used to create a device.\r\n     */\r\n    deviceDescriptor?: GPUDeviceDescriptor;\r\n\r\n    /**\r\n     * Defines the requested Swap Chain Format.\r\n     */\r\n    swapChainFormat?: GPUTextureFormat;\r\n\r\n    /**\r\n     * Defines whether MSAA is enabled on the canvas.\r\n     */\r\n    antialiasing?: boolean;\r\n\r\n    /**\r\n     * Defines whether the stencil buffer should be enabled.\r\n     */\r\n    stencil?: boolean;\r\n\r\n    /**\r\n     * Defines whether we should generate debug markers in the gpu command lists (can be seen with PIX for eg)\r\n     */\r\n    enableGPUDebugMarkers?: boolean;\r\n\r\n    /**\r\n     * Options to load the associated Glslang library\r\n     */\r\n    glslangOptions?: GlslangOptions;\r\n\r\n    /**\r\n     * Options to load the associated Twgsl library\r\n     */\r\n    twgslOptions?: TwgslOptions;\r\n\r\n    /**\r\n     * Defines if the engine should no exceed a specified device ratio\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\r\n     */\r\n    limitDeviceRatio?: number;\r\n\r\n    /**\r\n     * Defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n\r\n    /**\r\n     * Defines whether the canvas should be created in \"premultiplied\" mode (if false, the canvas is created in the \"opaque\" mode) (true by default)\r\n     */\r\n    premultipliedAlpha?: boolean;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n}\r\n\r\n/**\r\n * The web GPU engine class provides support for WebGPU version of babylon.js.\r\n * @since 5.0.0\r\n */\r\nexport class WebGPUEngine extends Engine {\r\n    // Default glslang options.\r\n    private static readonly _GLSLslangDefaultOptions: GlslangOptions = {\r\n        jsPath: \"https://preview.babylonjs.com/glslang/glslang.js\",\r\n        wasmPath: \"https://preview.babylonjs.com/glslang/glslang.wasm\",\r\n    };\r\n\r\n    /** true to enable using TintWASM to convert Spir-V to WGSL */\r\n    public static UseTWGSL = true;\r\n\r\n    // Page Life cycle and constants\r\n    private readonly _uploadEncoderDescriptor = { label: \"upload\" };\r\n    private readonly _renderEncoderDescriptor = { label: \"render\" };\r\n    private readonly _renderTargetEncoderDescriptor = { label: \"renderTarget\" };\r\n    /** @internal */\r\n    public readonly _clearDepthValue = 1;\r\n    /** @internal */\r\n    public readonly _clearReverseDepthValue = 0;\r\n    /** @internal */\r\n    public readonly _clearStencilValue = 0;\r\n    private readonly _defaultSampleCount = 4; // Only supported value for now.\r\n\r\n    // Engine Life Cycle\r\n    private _canvas: HTMLCanvasElement;\r\n    /** @internal */\r\n    public _options: WebGPUEngineOptions;\r\n    private _glslang: any = null;\r\n    private _tintWASM: Nullable<WebGPUTintWASM> = null;\r\n    private _adapter: GPUAdapter;\r\n    private _adapterSupportedExtensions: GPUFeatureName[];\r\n    /** @internal */\r\n    public _device: GPUDevice;\r\n    private _deviceEnabledExtensions: GPUFeatureName[];\r\n    private _context: GPUCanvasContext;\r\n    private _mainPassSampleCount: number;\r\n    /** @internal */\r\n    public _textureHelper: WebGPUTextureHelper;\r\n    /** @internal */\r\n    public _bufferManager: WebGPUBufferManager;\r\n    private _clearQuad: WebGPUClearQuad;\r\n    /** @internal */\r\n    public _cacheSampler: WebGPUCacheSampler;\r\n    /** @internal */\r\n    public _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    private _cacheBindGroups: WebGPUCacheBindGroups;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    /** @internal */\r\n    public _mrtAttachments: number[];\r\n    /** @internal */\r\n    public _timestampQuery: WebGPUTimestampQuery;\r\n    /** @internal */\r\n    public _occlusionQuery: WebGPUOcclusionQuery;\r\n    /** @internal */\r\n    public _compiledComputeEffects: { [key: string]: ComputeEffect } = {};\r\n    /** @internal */\r\n    public _counters: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Counters from last frame\r\n     */\r\n    public readonly countersLastFrame: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Max number of uncaptured error messages to log\r\n     */\r\n    public numMaxUncapturedErrors = 20;\r\n\r\n    // Some of the internal state might change during the render pass.\r\n    // This happens mainly during clear for the state\r\n    // And when the frame starts to swap the target texture from the swap chain\r\n    private _mainTexture: GPUTexture;\r\n    private _depthTexture: GPUTexture;\r\n    private _mainTextureExtends: GPUExtent3D;\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _colorFormat: GPUTextureFormat | null;\r\n    /** @internal */\r\n    public _ubInvertY: WebGPUDataBuffer;\r\n    /** @internal */\r\n    public _ubDontInvertY: WebGPUDataBuffer;\r\n\r\n    // Frame Life Cycle (recreated each frame)\r\n    /** @internal */\r\n    public _uploadEncoder: GPUCommandEncoder;\r\n    /** @internal */\r\n    public _renderEncoder: GPUCommandEncoder;\r\n    /** @internal */\r\n    public _renderTargetEncoder: GPUCommandEncoder;\r\n\r\n    private _commandBuffers: GPUCommandBuffer[] = [null as any, null as any, null as any];\r\n\r\n    // Frame Buffer Life Cycle (recreated for each render target pass)\r\n    /** @internal */\r\n    public _currentRenderPass: Nullable<GPURenderPassEncoder> = null;\r\n    /** @internal */\r\n    public _mainRenderPassWrapper: WebGPURenderPassWrapper = new WebGPURenderPassWrapper();\r\n    /** @internal */\r\n    public _rttRenderPassWrapper: WebGPURenderPassWrapper = new WebGPURenderPassWrapper();\r\n    /** @internal */\r\n    public _pendingDebugCommands: Array<[string, Nullable<string>]> = [];\r\n    /** @internal */\r\n    public _bundleList: WebGPUBundleList;\r\n    /** @internal */\r\n    public _bundleListRenderTarget: WebGPUBundleList;\r\n    /** @internal */\r\n    public _onAfterUnbindFrameBufferObservable = new Observable<WebGPUEngine>();\r\n\r\n    // DrawCall Life Cycle\r\n    // Effect is on the parent class\r\n    // protected _currentEffect: Nullable<Effect> = null;\r\n    private _defaultDrawContext: WebGPUDrawContext;\r\n    private _defaultMaterialContext: WebGPUMaterialContext;\r\n    /** @internal */\r\n    public _currentDrawContext: WebGPUDrawContext;\r\n    /** @internal */\r\n    public _currentMaterialContext: WebGPUMaterialContext;\r\n    private _currentOverrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }> = null;\r\n    private _currentIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _colorWriteLocal = true;\r\n    private _forceEnableEffect = false;\r\n\r\n    // TODO WEBGPU remove those variables when code stabilized\r\n    /** @internal */\r\n    public dbgShowShaderCode = false;\r\n    /** @internal */\r\n    public dbgSanityChecks = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsForFirstFrames = false;\r\n    /** @internal */\r\n    public dbgVerboseLogsNumFrames = 10;\r\n    /** @internal */\r\n    public dbgLogIfNotDrawWrapper = true;\r\n    /** @internal */\r\n    public dbgShowEmptyEnableEffectCalls = true;\r\n\r\n    private _snapshotRendering: WebGPUSnapshotRendering;\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public get snapshotRenderingMode(): number {\r\n        return this._snapshotRendering.mode;\r\n    }\r\n\r\n    public set snapshotRenderingMode(mode: number) {\r\n        this._snapshotRendering.mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Creates a new snapshot at the next frame using the current snapshotRenderingMode\r\n     */\r\n    public snapshotRenderingReset(): void {\r\n        this._snapshotRendering.reset();\r\n    }\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public get snapshotRendering(): boolean {\r\n        return this._snapshotRendering.enabled;\r\n    }\r\n\r\n    public set snapshotRendering(activate) {\r\n        this._snapshotRendering.enabled = activate;\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheSamplers(): boolean {\r\n        return this._cacheSampler ? this._cacheSampler.disabled : false;\r\n    }\r\n\r\n    public set disableCacheSamplers(disable: boolean) {\r\n        if (this._cacheSampler) {\r\n            this._cacheSampler.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheRenderPipelines(): boolean {\r\n        return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\r\n    }\r\n\r\n    public set disableCacheRenderPipelines(disable: boolean) {\r\n        if (this._cacheRenderPipeline) {\r\n            this._cacheRenderPipeline.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheBindGroups(): boolean {\r\n        return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\r\n    }\r\n\r\n    public set disableCacheBindGroups(disable: boolean) {\r\n        if (this._cacheBindGroups) {\r\n            this._cacheBindGroups.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\r\n     */\r\n    public static get IsSupportedAsync(): Promise<boolean> {\r\n        return !navigator.gpu\r\n            ? Promise.resolve(false)\r\n            : navigator.gpu\r\n                  .requestAdapter()\r\n                  .then(\r\n                      (adapter: GPUAdapter | null) => !!adapter,\r\n                      () => false\r\n                  )\r\n                  .catch(() => false);\r\n    }\r\n\r\n    /**\r\n     * Not supported by WebGPU, you should call IsSupportedAsync instead!\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public get supportsUniformBuffers(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** Gets the supported extensions by the WebGPU adapter */\r\n    public get supportedExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._adapterSupportedExtensions;\r\n    }\r\n\r\n    /** Gets the currently enabled extensions on the WebGPU device */\r\n    public get enabledExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._deviceEnabledExtensions;\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public get description(): string {\r\n        const description = this.name + this.version;\r\n\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public get version(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets an object containing information about the current engine context\r\n     * @returns an object containing the vendor, the renderer and the version of the current engine context\r\n     */\r\n    public getInfo() {\r\n        return {\r\n            vendor: \"unknown vendor\",\r\n            renderer: \"unknown renderer\",\r\n            version: \"unknown version\",\r\n        };\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public set compatibilityMode(mode: boolean) {\r\n        this._compatibilityMode = mode;\r\n    }\r\n\r\n    /** @internal */\r\n    public get currentSampleCount(): number {\r\n        return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine asynchronously\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     * @returns a promise that resolves with the created engine\r\n     */\r\n    public static CreateAsync(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}): Promise<WebGPUEngine> {\r\n        const engine = new WebGPUEngine(canvas, options);\r\n\r\n        return new Promise((resolve) => {\r\n            engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine.\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     */\r\n    public constructor(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}) {\r\n        super(null);\r\n        this._name = \"WebGPU\";\r\n\r\n        (this.isNDCHalfZRange as any) = true;\r\n        (this.hasOriginBottomLeft as any) = false;\r\n\r\n        options.deviceDescriptor = options.deviceDescriptor || {};\r\n        options.antialiasing = options.antialiasing === undefined ? true : options.antialiasing;\r\n        options.stencil = options.stencil ?? true;\r\n        options.enableGPUDebugMarkers = options.enableGPUDebugMarkers ?? false;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        Logger.Log(`Babylon.js v${Engine.Version} - ${this.description} engine`);\r\n        if (!navigator.gpu) {\r\n            Logger.Error(\"WebGPU is not supported by your browser.\");\r\n            return;\r\n        }\r\n\r\n        options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();\r\n\r\n        this._isWebGPU = true;\r\n        this._shaderPlatformName = \"WEBGPU\";\r\n\r\n        if (options.deterministicLockstep === undefined) {\r\n            options.deterministicLockstep = false;\r\n        }\r\n\r\n        if (options.lockstepMaxSteps === undefined) {\r\n            options.lockstepMaxSteps = 4;\r\n        }\r\n\r\n        if (options.audioEngine === undefined) {\r\n            options.audioEngine = true;\r\n        }\r\n\r\n        this._deterministicLockstep = options.deterministicLockstep;\r\n        this._lockstepMaxSteps = options.lockstepMaxSteps;\r\n        this._timeStep = options.timeStep || 1 / 60;\r\n\r\n        this._doNotHandleContextLost = !!options.doNotHandleContextLost;\r\n\r\n        this._canvas = canvas;\r\n        this._options = options;\r\n        this.premultipliedAlpha = options.premultipliedAlpha ?? true;\r\n\r\n        const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n        const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\r\n        const adaptToDeviceRatio = options.adaptToDeviceRatio ?? false;\r\n\r\n        this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\r\n        this._mainPassSampleCount = options.antialiasing ? this._defaultSampleCount : 1;\r\n        this._isStencilEnable = options.stencil;\r\n\r\n        this._sharedInit(canvas, !!options.doNotHandleTouchAction, options.audioEngine);\r\n\r\n        this._shaderProcessor = new WebGPUShaderProcessorGLSL();\r\n        this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Initialization\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Initializes the WebGPU context and dependencies.\r\n     * @param glslangOptions Defines the GLSLang compiler options if necessary\r\n     * @param twgslOptions Defines the Twgsl compiler options if necessary\r\n     * @returns a promise notifying the readiness of the engine.\r\n     */\r\n    public initAsync(glslangOptions?: GlslangOptions, twgslOptions?: TwgslOptions): Promise<void> {\r\n        return this._initGlslang(glslangOptions ?? this._options?.glslangOptions)\r\n            .then(\r\n                (glslang: any) => {\r\n                    this._glslang = glslang;\r\n                    this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;\r\n                    return this._tintWASM\r\n                        ? this._tintWASM.initTwgsl(twgslOptions ?? this._options?.twgslOptions).then(\r\n                              () => {\r\n                                  return navigator.gpu!.requestAdapter(this._options);\r\n                              },\r\n                              (msg: string) => {\r\n                                  Logger.Error(\"Can not initialize twgsl!\");\r\n                                  Logger.Error(msg);\r\n                                  throw Error(\"WebGPU initializations stopped.\");\r\n                              }\r\n                          )\r\n                        : navigator.gpu!.requestAdapter(this._options);\r\n                },\r\n                (msg: string) => {\r\n                    Logger.Error(\"Can not initialize glslang!\");\r\n                    Logger.Error(msg);\r\n                    throw Error(\"WebGPU initializations stopped.\");\r\n                }\r\n            )\r\n            .then((adapter: GPUAdapter | null) => {\r\n                if (!adapter) {\r\n                    throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\r\n                } else {\r\n                    this._adapter = adapter!;\r\n                    this._adapterSupportedExtensions = [];\r\n                    this._adapter.features?.forEach((feature) => this._adapterSupportedExtensions.push(feature as WebGPUConstants.FeatureName));\r\n\r\n                    const deviceDescriptor = this._options.deviceDescriptor;\r\n\r\n                    if (deviceDescriptor?.requiredFeatures) {\r\n                        const requestedExtensions = deviceDescriptor.requiredFeatures;\r\n                        const validExtensions: GPUFeatureName[] = [];\r\n\r\n                        for (const extension of requestedExtensions) {\r\n                            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\r\n                                validExtensions.push(extension);\r\n                            }\r\n                        }\r\n\r\n                        deviceDescriptor.requiredFeatures = validExtensions;\r\n                    }\r\n\r\n                    return this._adapter.requestDevice(this._options.deviceDescriptor);\r\n                }\r\n            })\r\n            .then(\r\n                (device: GPUDevice) => {\r\n                    this._device = device;\r\n                    this._deviceEnabledExtensions = [];\r\n                    this._device.features?.forEach((feature) => this._deviceEnabledExtensions.push(feature as WebGPUConstants.FeatureName));\r\n\r\n                    let numUncapturedErrors = -1;\r\n                    this._device.addEventListener(\"uncapturederror\", (event) => {\r\n                        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${(<GPUUncapturedErrorEvent>event).error} - ${(<any>event).error.message}`);\r\n                        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(\r\n                                `WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    if (!this._doNotHandleContextLost) {\r\n                        this._device.lost?.then((info) => {\r\n                            this._contextWasLost = true;\r\n                            Logger.Warn(\"WebGPU context lost. \" + info);\r\n                            this.onContextLostObservable.notifyObservers(this);\r\n                            this._restoreEngineAfterContextLost(this.initAsync.bind(this));\r\n                        });\r\n                    }\r\n                },\r\n                (e: any) => {\r\n                    Logger.Error(\"Could not retrieve a WebGPU device.\");\r\n                    Logger.Error(e);\r\n                }\r\n            )\r\n            .then(() => {\r\n                this._bufferManager = new WebGPUBufferManager(this._device);\r\n                this._textureHelper = new WebGPUTextureHelper(this._device, this._glslang, this._tintWASM, this._bufferManager);\r\n                this._cacheSampler = new WebGPUCacheSampler(this._device);\r\n                this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\r\n                this._timestampQuery = new WebGPUTimestampQuery(this._device, this._bufferManager);\r\n                this._occlusionQuery = (this._device as any).createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : (undefined as any);\r\n                this._bundleList = new WebGPUBundleList(this._device);\r\n                this._bundleListRenderTarget = new WebGPUBundleList(this._device);\r\n                this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList, this._bundleListRenderTarget);\r\n\r\n                this._ubInvertY = this._bufferManager.createBuffer(new Float32Array([-1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\r\n                this._ubDontInvertY = this._bufferManager.createBuffer(new Float32Array([1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst);\r\n\r\n                if (this.dbgVerboseLogsForFirstFrames) {\r\n                    if ((this as any)._count === undefined) {\r\n                        (this as any)._count = 0;\r\n                        console.log(\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\");\r\n                    }\r\n                }\r\n\r\n                this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n                this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n                this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\r\n\r\n                this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", false, false, 1, false, 0, 1);\r\n\r\n                this._initializeLimits();\r\n\r\n                this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer, !this._caps.textureFloatLinearFiltering);\r\n\r\n                this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\r\n                this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\r\n                this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n                this._depthCullingState.depthTest = true;\r\n                this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n                this._depthCullingState.depthMask = true;\r\n\r\n                this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n                this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\r\n                this._defaultDrawContext = this.createDrawContext()!;\r\n                this._currentDrawContext = this._defaultDrawContext;\r\n                this._defaultMaterialContext = this.createMaterialContext()!;\r\n                this._currentMaterialContext = this._defaultMaterialContext;\r\n\r\n                this._initializeContextAndSwapChain();\r\n                this._initializeMainAttachments();\r\n                this.resize();\r\n            })\r\n            .catch((e: any) => {\r\n                Logger.Error(\"Can not create WebGPU Device and/or context.\");\r\n                Logger.Error(e);\r\n                if (console.trace) {\r\n                    console.trace();\r\n                }\r\n            });\r\n    }\r\n\r\n    private _initGlslang(glslangOptions?: GlslangOptions): Promise<any> {\r\n        glslangOptions = glslangOptions || {};\r\n        glslangOptions = {\r\n            ...WebGPUEngine._GLSLslangDefaultOptions,\r\n            ...glslangOptions,\r\n        };\r\n\r\n        if (glslangOptions.glslang) {\r\n            return Promise.resolve(glslangOptions.glslang);\r\n        }\r\n\r\n        if ((self as any).glslang) {\r\n            return (self as any).glslang(glslangOptions!.wasmPath);\r\n        }\r\n\r\n        if (glslangOptions.jsPath && glslangOptions.wasmPath) {\r\n            if (IsWindowObjectExist()) {\r\n                return Tools.LoadScriptAsync(glslangOptions.jsPath).then(() => {\r\n                    return (self as any).glslang(glslangOptions!.wasmPath);\r\n                });\r\n            } else {\r\n                importScripts(glslangOptions.jsPath);\r\n                return (self as any).glslang(glslangOptions!.wasmPath);\r\n            }\r\n        }\r\n\r\n        return Promise.reject(\"gslang is not available.\");\r\n    }\r\n\r\n    private _initializeLimits(): void {\r\n        // Init caps\r\n        // TODO WEBGPU Real Capability check once limits will be working.\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: 8192,\r\n            maxCubemapTextureSize: 2048,\r\n            maxRenderTextureSize: 8192,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 15,\r\n            maxFragmentUniformVectors: 1024,\r\n            maxVertexUniformVectors: 1024,\r\n            standardDerivatives: true,\r\n            astc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined) as any,\r\n            s3tc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined) as any,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined) as any,\r\n            bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\r\n            maxAnisotropy: 4, // the spec only supports values of 1 and 4\r\n            uintIndices: true,\r\n            fragmentDepthSupported: true,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: true,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: false, // WebGPU does not allow filtering 32 bits float textures\r\n            textureFloatRender: true,\r\n            textureHalfFloat: true,\r\n            textureHalfFloatLinearFiltering: true,\r\n            textureHalfFloatRender: true,\r\n            textureLOD: true,\r\n            drawBuffersExtension: true,\r\n            depthTextureExtension: true,\r\n            vertexArrayObject: false,\r\n            instancedArrays: true,\r\n            timerQuery: typeof BigUint64Array !== \"undefined\" && this.enabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? (true as any) : undefined,\r\n            supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\r\n            canUseTimestampForTimerQuery: true,\r\n            multiview: false,\r\n            oculusMultiview: false,\r\n            parallelShaderCompile: undefined,\r\n            blendMinMax: true,\r\n            maxMSAASamples: 4,\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: true,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: true,\r\n            texture2DArrayMaxLayerCount: 2048,\r\n        };\r\n\r\n        this._caps.parallelShaderCompile = null as any;\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: true,\r\n            supportRenderAndCopyToLodForFloatTextures: true,\r\n            supportDepthStencilTexture: true,\r\n            supportShadowSamplers: true,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: true,\r\n            trackUbosInFrame: true,\r\n            checkUbosContentBeforeUpload: true,\r\n            supportCSM: true,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: true,\r\n            needTypeSuffixInShaderConstants: true,\r\n            supportMSAA: true,\r\n            supportSSAO2: true,\r\n            supportExtendedTextureFormats: true,\r\n            supportSwitchCaseInShader: true,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: false,\r\n            useUBOBindingCache: false,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: true,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: true,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n    }\r\n\r\n    private _initializeContextAndSwapChain(): void {\r\n        this._context = this._canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n        this._configureContext();\r\n        this._colorFormat = this._options.swapChainFormat!;\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.format = this._colorFormat;\r\n    }\r\n\r\n    // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\r\n    private _initializeMainAttachments(): void {\r\n        if (!this._bufferManager) {\r\n            return;\r\n        }\r\n\r\n        this.flushFramebuffer(false);\r\n\r\n        this._mainTextureExtends = {\r\n            width: this.getRenderWidth(),\r\n            height: this.getRenderHeight(),\r\n            depthOrArrayLayers: 1,\r\n        };\r\n\r\n        const bufferDataUpdate = new Float32Array([this.getRenderHeight()]);\r\n\r\n        this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\r\n        this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\r\n\r\n        let mainColorAttachments: GPURenderPassColorAttachment[];\r\n\r\n        if (this._options.antialiasing) {\r\n            const mainTextureDescriptor: GPUTextureDescriptor = {\r\n                label: \"Texture_MainColor_antialiasing\",\r\n                size: this._mainTextureExtends,\r\n                mipLevelCount: 1,\r\n                sampleCount: this._mainPassSampleCount,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._options.swapChainFormat!,\r\n                usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n            };\r\n\r\n            if (this._mainTexture) {\r\n                this._textureHelper.releaseTexture(this._mainTexture);\r\n            }\r\n            this._mainTexture = this._device.createTexture(mainTextureDescriptor);\r\n            mainColorAttachments = [\r\n                {\r\n                    view: this._mainTexture.createView(),\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store, // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\r\n                },\r\n            ];\r\n        } else {\r\n            mainColorAttachments = [\r\n                {\r\n                    view: undefined as any,\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ];\r\n        }\r\n\r\n        this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\r\n\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n\r\n        const depthTextureDescriptor: GPUTextureDescriptor = {\r\n            label: \"Texture_MainDepthStencil\",\r\n            size: this._mainTextureExtends,\r\n            mipLevelCount: 1,\r\n            sampleCount: this._mainPassSampleCount,\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format: this._mainRenderPassWrapper.depthTextureFormat,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n        };\r\n\r\n        if (this._depthTexture) {\r\n            this._textureHelper.releaseTexture(this._depthTexture);\r\n        }\r\n        this._depthTexture = this._device.createTexture(depthTextureDescriptor);\r\n        const mainDepthAttachment: GPURenderPassDepthStencilAttachment = {\r\n            view: this._depthTexture.createView(),\r\n\r\n            depthClearValue: this._clearDepthValue,\r\n            depthLoadOp: WebGPUConstants.LoadOp.Clear,\r\n            depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n            stencilClearValue: this._clearStencilValue,\r\n            stencilLoadOp: !this.isStencilEnable ? undefined : WebGPUConstants.LoadOp.Clear,\r\n            stencilStoreOp: !this.isStencilEnable ? undefined : WebGPUConstants.StoreOp.Store,\r\n        };\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor = {\r\n            colorAttachments: mainColorAttachments,\r\n            depthStencilAttachment: mainDepthAttachment,\r\n        };\r\n    }\r\n\r\n    private _configureContext(): void {\r\n        this._context.configure({\r\n            device: this._device,\r\n            format: this._options.swapChainFormat!,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\r\n            alphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasAlphaMode.Premultiplied : WebGPUConstants.CanvasAlphaMode.Opaque,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!super.setSize(width, height, forceSetSize)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - setSize called -\", width, height);\r\n            }\r\n        }\r\n\r\n        this._initializeMainAttachments();\r\n\r\n        if (this.snapshotRendering) {\r\n            // reset snapshot rendering so that the next frame will record a new list of bundles\r\n            this.snapshotRenderingReset();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _shaderProcessorWGSL: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            return this._shaderProcessorWGSL;\r\n        }\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessingContext(shaderLanguage: ShaderLanguage): Nullable<ShaderProcessingContext> {\r\n        return new WebGPUShaderProcessingContext(shaderLanguage);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                          Static Pipeline WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    /** @internal */\r\n    public applyStates() {\r\n        this._stencilStateComposer.apply();\r\n        this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\r\n    }\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames && !bruteForce) {\r\n            return;\r\n        }\r\n\r\n        //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\r\n        // _forceEnableEffect = true assumes the role of _currentEffect = null\r\n        this._forceEnableEffect = true;\r\n        this._currentIndexBuffer = null;\r\n        this._currentOverrideVertexBuffers = null;\r\n        this._cacheRenderPipeline.setBuffers(null, null, null);\r\n\r\n        if (bruteForce) {\r\n            this._stencilStateComposer.reset();\r\n\r\n            this._depthCullingState.reset();\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n\r\n            this._alphaState.reset();\r\n            this._alphaMode = Constants.ALPHA_ADD;\r\n            this._alphaEquation = Constants.ALPHA_DISABLE;\r\n            this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n            this._cacheRenderPipeline.setAlphaBlendEnabled(false);\r\n\r\n            this.setColorWrite(true);\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        this._colorWriteLocal = enable;\r\n        this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWriteLocal;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dynamic WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    // index 0 is for main render pass, 1 for RTT render pass\r\n    private _viewportsCurrent: Array<{ x: number; y: number; w: number; h: number }> = [\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n    ];\r\n\r\n    private _resetCurrentViewport(index: number) {\r\n        this._viewportsCurrent[index].x = 0;\r\n        this._viewportsCurrent[index].y = 0;\r\n        this._viewportsCurrent[index].w = 0;\r\n        this._viewportsCurrent[index].h = 0;\r\n\r\n        if (index === 1) {\r\n            this._viewportCached.x = 0;\r\n            this._viewportCached.y = 0;\r\n            this._viewportCached.z = 0;\r\n            this._viewportCached.w = 0;\r\n        }\r\n    }\r\n\r\n    private _mustUpdateViewport(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n\r\n        const x = this._viewportCached.x,\r\n            y = this._viewportCached.y,\r\n            w = this._viewportCached.z,\r\n            h = this._viewportCached.w;\r\n\r\n        const update =\r\n            this._viewportsCurrent[index].x !== x || this._viewportsCurrent[index].y !== y || this._viewportsCurrent[index].w !== w || this._viewportsCurrent[index].h !== h;\r\n\r\n        if (update) {\r\n            this._viewportsCurrent[index].x = this._viewportCached.x;\r\n            this._viewportsCurrent[index].y = this._viewportCached.y;\r\n            this._viewportsCurrent[index].w = this._viewportCached.z;\r\n            this._viewportsCurrent[index].h = this._viewportCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyViewport(renderPass: GPURenderPassEncoder): void {\r\n        let y = Math.floor(this._viewportCached.y);\r\n        const h = Math.floor(this._viewportCached.w);\r\n\r\n        if (!this._currentRenderTarget) {\r\n            y = this.getRenderHeight() - y - h;\r\n        }\r\n\r\n        renderPass.setViewport(Math.floor(this._viewportCached.x), y, Math.floor(this._viewportCached.z), h, 0, 1);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - viewport applied - (\",\r\n                    this._viewportCached.x,\r\n                    this._viewportCached.y,\r\n                    this._viewportCached.z,\r\n                    this._viewportCached.w,\r\n                    \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _viewport(x: number, y: number, width: number, height: number): void {\r\n        this._viewportCached.x = x;\r\n        this._viewportCached.y = y;\r\n        this._viewportCached.z = width;\r\n        this._viewportCached.w = height;\r\n    }\r\n\r\n    private _scissorsCurrent: Array<{ x: number; y: number; w: number; h: number }> = [\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n        { x: 0, y: 0, w: 0, h: 0 },\r\n    ];\r\n    protected _scissorCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    private _resetCurrentScissor(index: number) {\r\n        this._scissorsCurrent[index].x = 0;\r\n        this._scissorsCurrent[index].y = 0;\r\n        this._scissorsCurrent[index].w = 0;\r\n        this._scissorsCurrent[index].h = 0;\r\n    }\r\n\r\n    private _mustUpdateScissor(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n\r\n        const x = this._scissorCached.x,\r\n            y = this._scissorCached.y,\r\n            w = this._scissorCached.z,\r\n            h = this._scissorCached.w;\r\n\r\n        const update = this._scissorsCurrent[index].x !== x || this._scissorsCurrent[index].y !== y || this._scissorsCurrent[index].w !== w || this._scissorsCurrent[index].h !== h;\r\n\r\n        if (update) {\r\n            this._scissorsCurrent[index].x = this._scissorCached.x;\r\n            this._scissorsCurrent[index].y = this._scissorCached.y;\r\n            this._scissorsCurrent[index].w = this._scissorCached.z;\r\n            this._scissorsCurrent[index].h = this._scissorCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyScissor(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setScissorRect(\r\n            this._scissorCached.x,\r\n            this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y,\r\n            this._scissorCached.z,\r\n            this._scissorCached.w\r\n        );\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - scissor applied - (\",\r\n                    this._scissorCached.x,\r\n                    this._scissorCached.y,\r\n                    this._scissorCached.z,\r\n                    this._scissorCached.w,\r\n                    \") current pass is main pass=\" + (renderPass === this._mainRenderPassWrapper.renderPass)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    private _scissorIsActive() {\r\n        return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\r\n    }\r\n\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        this._scissorCached.x = x;\r\n        this._scissorCached.y = y;\r\n        this._scissorCached.z = width;\r\n        this._scissorCached.w = height;\r\n    }\r\n\r\n    public disableScissor() {\r\n        this._scissorCached.x = 0;\r\n        this._scissorCached.y = 0;\r\n        this._scissorCached.z = 0;\r\n        this._scissorCached.w = 0;\r\n\r\n        this._resetCurrentScissor(0);\r\n        this._resetCurrentScissor(1);\r\n    }\r\n\r\n    private _stencilRefsCurrent: Array<number> = [-1, -1];\r\n\r\n    private _resetCurrentStencilRef(index: number): void {\r\n        this._stencilRefsCurrent[index] = -1;\r\n    }\r\n\r\n    private _mustUpdateStencilRef(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n        const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent[index];\r\n        if (update) {\r\n            this._stencilRefsCurrent[index] = this._stencilStateComposer.funcRef;\r\n        }\r\n        return update;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _applyStencilRef(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setStencilReference(this._stencilStateComposer.funcRef ?? 0);\r\n    }\r\n\r\n    private _blendColorsCurrent: Array<Array<Nullable<number>>> = [\r\n        [null, null, null, null],\r\n        [null, null, null, null],\r\n    ];\r\n\r\n    private _resetCurrentColorBlend(index: number): void {\r\n        this._blendColorsCurrent[index][0] = this._blendColorsCurrent[index][1] = this._blendColorsCurrent[index][2] = this._blendColorsCurrent[index][3] = null;\r\n    }\r\n\r\n    private _mustUpdateBlendColor(renderPass: GPURenderPassEncoder): boolean {\r\n        const index = renderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n        const colorBlend = this._alphaState._blendConstants;\r\n\r\n        const update =\r\n            colorBlend[0] !== this._blendColorsCurrent[index][0] ||\r\n            colorBlend[1] !== this._blendColorsCurrent[index][1] ||\r\n            colorBlend[2] !== this._blendColorsCurrent[index][2] ||\r\n            colorBlend[3] !== this._blendColorsCurrent[index][3];\r\n\r\n        if (update) {\r\n            this._blendColorsCurrent[index][0] = colorBlend[0];\r\n            this._blendColorsCurrent[index][1] = colorBlend[1];\r\n            this._blendColorsCurrent[index][2] = colorBlend[2];\r\n            this._blendColorsCurrent[index][3] = colorBlend[3];\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyBlendColor(renderPass: GPURenderPassEncoder): void {\r\n        renderPass.setBlendConstant(this._alphaState._blendConstants as GPUColor);\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n        // Some PGs are using color3...\r\n        if (color && color.a === undefined) {\r\n            color.a = 1;\r\n        }\r\n\r\n        const hasScissor = this._scissorIsActive();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - clear called - backBuffer=\",\r\n                    backBuffer,\r\n                    \" depth=\",\r\n                    depth,\r\n                    \" stencil=\",\r\n                    stencil,\r\n                    \" scissor is active=\",\r\n                    hasScissor\r\n                );\r\n            }\r\n        }\r\n\r\n        // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\r\n        if (this._currentRenderTarget) {\r\n            if (hasScissor) {\r\n                if (!this._rttRenderPassWrapper.renderPass) {\r\n                    this._startRenderTargetRenderPass(this._currentRenderTarget!, false, backBuffer ? color : null, depth, stencil);\r\n                }\r\n                if (!this.compatibilityMode) {\r\n                    this._bundleListRenderTarget.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n                } else {\r\n                    this._applyScissor(this._currentRenderPass!);\r\n                }\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            } else {\r\n                if (this._currentRenderPass) {\r\n                    this._endRenderTargetRenderPass();\r\n                }\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget!, true, backBuffer ? color : null, depth, stencil);\r\n            }\r\n        } else {\r\n            if (!this._mainRenderPassWrapper.renderPass || !hasScissor) {\r\n                this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\r\n            }\r\n            if (hasScissor) {\r\n                if (!this.compatibilityMode) {\r\n                    this._bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n                } else {\r\n                    this._applyScissor(this._currentRenderPass!);\r\n                }\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _clearFullQuad(clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n\r\n        this._clearQuad.setColorFormat(this._colorFormat);\r\n        this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\r\n        this._clearQuad.setMRTAttachments(\r\n            this._cacheRenderPipeline.mrtAttachments ?? [],\r\n            this._cacheRenderPipeline.mrtTextureArray ?? [],\r\n            this._cacheRenderPipeline.mrtTextureCount\r\n        );\r\n\r\n        if (!this.compatibilityMode) {\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\r\n        } else {\r\n            renderPass!.setStencilReference(this._clearStencilValue);\r\n        }\r\n\r\n        const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\r\n\r\n        if (!this.compatibilityMode) {\r\n            bundleList.addBundle(bundle!);\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n            this._reportDrawCall();\r\n        } else {\r\n            this._applyStencilRef(renderPass!);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Vertex/Index/Storage Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the vertex buffer\r\n     * @returns the new buffer\r\n     */\r\n    public createVertexBuffer(data: DataArray): DataBuffer {\r\n        let view: ArrayBufferView;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst);\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @returns the new buffer\r\n     */\r\n    public createDynamicVertexBuffer(data: DataArray): DataBuffer {\r\n        return this.createVertexBuffer(data);\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @returns a new buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray): DataBuffer {\r\n        let is32Bits = true;\r\n        let view: ArrayBufferView;\r\n\r\n        if (indices instanceof Uint32Array || indices instanceof Int32Array) {\r\n            view = indices;\r\n        } else if (indices instanceof Uint16Array) {\r\n            view = indices;\r\n            is32Bits = false;\r\n        } else {\r\n            if (indices.length > 65535) {\r\n                view = new Uint32Array(indices);\r\n            } else {\r\n                view = new Uint16Array(indices);\r\n                is32Bits = false;\r\n            }\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst);\r\n        dataBuffer.is32Bits = is32Bits;\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createBuffer(data: DataArray | number, creationFlags: number): DataBuffer {\r\n        let view: ArrayBufferView | number;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        let flags = 0;\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_READ) {\r\n            flags |= WebGPUConstants.BufferUsage.CopySrc;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_WRITE) {\r\n            flags |= WebGPUConstants.BufferUsage.CopyDst;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_UNIFORM) {\r\n            flags |= WebGPUConstants.BufferUsage.Uniform;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_VERTEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Vertex;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_INDEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Index;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_STORAGE) {\r\n            flags |= WebGPUConstants.BufferUsage.Storage;\r\n        }\r\n\r\n        return this._bufferManager.createBuffer(view, flags);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindBuffersDirectly(): void {\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public updateAndBindInstancesBuffer(): void {\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Bind a list of vertex buffers with the engine\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        this._currentIndexBuffer = indexBuffer;\r\n        this._currentOverrideVertexBuffers = overrideVertexBuffers ?? null;\r\n        this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseBuffer(buffer: DataBuffer): boolean {\r\n        return this._bufferManager.releaseBuffer(buffer);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Effects\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @returns the new Effect\r\n     */\r\n    public createEffect(\r\n        baseName: any,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | Engine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ): Effect {\r\n        const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\r\n        const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\r\n        const globalDefines = this._getGlobalDefines()!;\r\n\r\n        let fullDefines = defines ?? (<IEffectCreationOptions>attributesNamesOrOptions).defines ?? \"\";\r\n\r\n        if (globalDefines) {\r\n            fullDefines += \"\\n\" + globalDefines;\r\n        }\r\n\r\n        const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\r\n        if (this._compiledEffects[name]) {\r\n            const compiledEffect = <Effect>this._compiledEffects[name];\r\n            if (onCompiled && compiledEffect.isReady()) {\r\n                onCompiled(compiledEffect);\r\n            }\r\n\r\n            return compiledEffect;\r\n        }\r\n        const effect = new Effect(\r\n            baseName,\r\n            attributesNamesOrOptions,\r\n            uniformsNamesOrEngine,\r\n            samplers,\r\n            this,\r\n            defines,\r\n            fallbacks,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters,\r\n            name,\r\n            shaderLanguage\r\n        );\r\n        this._compiledEffects[name] = effect;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _compileRawShaderToSpirV(source: string, type: string): Uint32Array {\r\n        return this._glslang.compileGLSL(source, type);\r\n    }\r\n\r\n    private _compileShaderToSpirV(source: string, type: string, defines: Nullable<string>, shaderVersion: string): Uint32Array {\r\n        return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\r\n    }\r\n\r\n    private _getWGSLShader(source: string, type: string, defines: Nullable<string>): string {\r\n        if (defines) {\r\n            defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n        } else {\r\n            defines = \"\";\r\n        }\r\n        return defines + source;\r\n    }\r\n\r\n    private _createPipelineStageDescriptor(\r\n        vertexShader: Uint32Array | string,\r\n        fragmentShader: Uint32Array | string,\r\n        shaderLanguage: ShaderLanguage\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\r\n            vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader as Uint32Array) as any;\r\n            fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader as Uint32Array) as any;\r\n        }\r\n\r\n        return {\r\n            vertexStage: {\r\n                module: this._device.createShaderModule({\r\n                    code: vertexShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n            fragmentStage: {\r\n                module: this._device.createShaderModule({\r\n                    code: fragmentShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        };\r\n    }\r\n\r\n    private _compileRawPipelineStageDescriptor(vertexCode: string, fragmentCode: string, shaderLanguage: ShaderLanguage): IWebGPURenderPipelineStageDescriptor {\r\n        const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\r\n        const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\r\n\r\n        return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\r\n    }\r\n\r\n    private _compilePipelineStageDescriptor(\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        defines: Nullable<string>,\r\n        shaderLanguage: ShaderLanguage\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const shaderVersion = \"#version 450\\n\";\r\n        const vertexShader =\r\n            shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\r\n        const fragmentShader =\r\n            shaderLanguage === ShaderLanguage.GLSL\r\n                ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion)\r\n                : this._getWGSLShader(fragmentCode, \"fragment\", defines);\r\n\r\n        const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage);\r\n\r\n        this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createShaderProgram(): WebGLProgram {\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public createPipelineContext(shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext {\r\n        return new WebGPUPipelineContext(shaderProcessingContext! as WebGPUShaderProcessingContext, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public createMaterialContext(): WebGPUMaterialContext | undefined {\r\n        return new WebGPUMaterialContext();\r\n    }\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public createDrawContext(): WebGPUDrawContext | undefined {\r\n        return new WebGPUDrawContext(this._bufferManager);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        rebuildRebind: any,\r\n        defines: Nullable<string>\r\n    ) {\r\n        const webGpuContext = pipelineContext as WebGPUPipelineContext;\r\n        const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\r\n\r\n        if (this.dbgShowShaderCode) {\r\n            console.log(defines);\r\n            console.log(vertexSourceCode);\r\n            console.log(fragmentSourceCode);\r\n            console.log(\"***********************************************\");\r\n        }\r\n\r\n        webGpuContext.sources = {\r\n            fragment: fragmentSourceCode,\r\n            vertex: vertexSourceCode,\r\n            rawVertex: rawVertexSourceCode,\r\n            rawFragment: rawFragmentSourceCode,\r\n        };\r\n\r\n        if (createAsRaw) {\r\n            webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\r\n        } else {\r\n            webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active attributes for a given WebGPU program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const results = new Array(attributesNames.length);\r\n        const gpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n\r\n        for (let i = 0; i < attributesNames.length; i++) {\r\n            const attributeName = attributesNames[i];\r\n            const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\r\n            if (attributeLocation === undefined) {\r\n                continue;\r\n            }\r\n\r\n            results[i] = attributeLocation;\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        let isNewEffect = true;\r\n\r\n        if (!DrawWrapper.IsWrapper(effect)) {\r\n            isNewEffect = effect !== this._currentEffect;\r\n            this._currentEffect = effect;\r\n            this._currentMaterialContext = this._defaultMaterialContext;\r\n            this._currentDrawContext = this._defaultDrawContext;\r\n            this._counters.numEnableEffects++;\r\n            if (this.dbgLogIfNotDrawWrapper) {\r\n                Logger.Warn(\r\n                    `enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${effect.name.vertex}, effect.name.fragment=${effect.name.fragment}`,\r\n                    10\r\n                );\r\n            }\r\n        } else if (\r\n            !effect.effect ||\r\n            (effect.effect === this._currentEffect &&\r\n                effect.materialContext === this._currentMaterialContext &&\r\n                effect.drawContext === this._currentDrawContext &&\r\n                !this._forceEnableEffect)\r\n        ) {\r\n            if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\r\n                console.error(\"drawWrapper=\", effect);\r\n                throw \"Invalid call to enableEffect: the effect property is empty!\";\r\n            }\r\n            return;\r\n        } else {\r\n            isNewEffect = effect.effect !== this._currentEffect;\r\n            this._currentEffect = effect.effect;\r\n            this._currentMaterialContext = effect.materialContext as WebGPUMaterialContext;\r\n            this._currentDrawContext = effect.drawContext as WebGPUDrawContext;\r\n            this._counters.numEnableDrawWrapper++;\r\n            if (!this._currentMaterialContext) {\r\n                console.error(\"drawWrapper=\", effect);\r\n                throw `Invalid call to enableEffect: the materialContext property is empty!`;\r\n            }\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = undefined;\r\n\r\n        this._forceEnableEffect = isNewEffect || this._forceEnableEffect ? false : this._forceEnableEffect;\r\n\r\n        if (isNewEffect) {\r\n            if (this._currentEffect!.onBind) {\r\n                this._currentEffect!.onBind(this._currentEffect!);\r\n            }\r\n            if (this._currentEffect!._onBindObservable) {\r\n                this._currentEffect!._onBindObservable.notifyObservers(this._currentEffect!);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseEffect(effect: Effect): void {\r\n        if (this._compiledEffects[effect._key]) {\r\n            delete this._compiledEffects[effect._key];\r\n\r\n            this._deletePipelineContext(effect.getPipelineContext() as WebGPUPipelineContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {\r\n        for (const name in this._compiledEffects) {\r\n            const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext() as WebGPUPipelineContext;\r\n            this._deletePipelineContext(webGPUPipelineContext);\r\n        }\r\n\r\n        this._compiledEffects = {};\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const webgpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n        if (webgpuPipelineContext) {\r\n            pipelineContext.dispose();\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Textures\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public get needPOTTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): HardwareTextureWrapper {\r\n        return new WebGPUHardwareTexture();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {\r\n        const index = this._internalTexturesCache.indexOf(texture);\r\n        if (index !== -1) {\r\n            this._internalTexturesCache.splice(index, 1);\r\n        }\r\n\r\n        this._textureHelper.releaseTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getRGBABufferInternalSizedFormat(): number {\r\n        return Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    public updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void {\r\n        texture._comparisonFunction = comparisonFunction;\r\n    }\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        const fullOptions: InternalTextureCreationOptions = {};\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            fullOptions.format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            fullOptions.samples = options.samples ?? 1;\r\n            fullOptions.creationFlags = options.creationFlags ?? 0;\r\n            fullOptions.useSRGBBuffer = options.useSRGBBuffer ?? false;\r\n        } else {\r\n            fullOptions.generateMipMaps = <boolean>options;\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n            fullOptions.format = Constants.TEXTUREFORMAT_RGBA;\r\n            fullOptions.samples = 1;\r\n            fullOptions.creationFlags = 0;\r\n            fullOptions.useSRGBBuffer = false;\r\n        }\r\n\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (fullOptions.type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n        const layers = (<{ width: number; height: number; layers?: number }>size).layers || 0;\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = layers;\r\n        texture.isReady = true;\r\n        texture.samples = fullOptions.samples;\r\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n        texture.format = fullOptions.format;\r\n        texture.is2DArray = layers > 0;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = fullOptions.useSRGBBuffer;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        if (!delayGPUTextureCreation) {\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a hardware texture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        return this._createTextureBase(\r\n            url,\r\n            noMipmap,\r\n            invertY,\r\n            scene,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            (\r\n                texture: InternalTexture,\r\n                extension: string,\r\n                scene: Nullable<ISceneLike>,\r\n                img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                invertY: boolean,\r\n                noMipmap: boolean,\r\n                isCompressed: boolean,\r\n                processFunction: (\r\n                    width: number,\r\n                    height: number,\r\n                    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                    extension: string,\r\n                    texture: InternalTexture,\r\n                    continuationCallback: () => void\r\n                ) => boolean\r\n            ) => {\r\n                const imageBitmap = img as ImageBitmap | { width: number; height: number }; // we will never get an HTMLImageElement in WebGPU\r\n\r\n                texture.baseWidth = imageBitmap.width;\r\n                texture.baseHeight = imageBitmap.height;\r\n                texture.width = imageBitmap.width;\r\n                texture.height = imageBitmap.height;\r\n                texture.format = format ?? -1;\r\n\r\n                processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\r\n\r\n                if (!texture._hardwareTexture?.underlyingResource) {\r\n                    // the texture could have been created before reaching this point so don't recreate it if already existing\r\n                    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\r\n\r\n                    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n                        this._textureHelper.updateTexture(\r\n                            imageBitmap,\r\n                            texture,\r\n                            imageBitmap.width,\r\n                            imageBitmap.height,\r\n                            texture.depth,\r\n                            gpuTextureWrapper.format,\r\n                            0,\r\n                            0,\r\n                            invertY,\r\n                            false,\r\n                            0,\r\n                            0\r\n                        );\r\n                        if (!noMipmap && !isCompressed) {\r\n                            this._generateMipmaps(texture, this._uploadEncoder);\r\n                        }\r\n                    }\r\n                } else if (!noMipmap && !isCompressed) {\r\n                    this._generateMipmaps(texture, this._uploadEncoder);\r\n                }\r\n\r\n                if (scene) {\r\n                    scene.removePendingData(texture);\r\n                }\r\n\r\n                texture.isReady = true;\r\n\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n            },\r\n            () => false,\r\n            buffer,\r\n            fallback,\r\n            format,\r\n            forcedExtension,\r\n            mimeType,\r\n            loaderOptions,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gpu texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGPUTexture(texture: GPUTexture): InternalTexture {\r\n        const hardwareTexture = new WebGPUHardwareTexture(texture);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\r\n    }\r\n\r\n    public generateMipMapsForCubemap(texture: InternalTexture) {\r\n        if (texture.generateMipMaps) {\r\n            const gpuTexture = texture._hardwareTexture?.underlyingResource;\r\n\r\n            if (!gpuTexture) {\r\n                this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n            }\r\n\r\n            this._generateMipmaps(\r\n                texture,\r\n                texture.source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? this._renderTargetEncoder : undefined\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps: boolean = false): void {\r\n        if (generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n            this._generateMipmaps(texture);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV: Nullable<number> = null, wrapR: Nullable<number> = null): void {\r\n        if (wrapU !== null) {\r\n            texture._cachedWrapU = wrapU;\r\n        }\r\n        if (wrapV !== null) {\r\n            texture._cachedWrapV = wrapV;\r\n        }\r\n        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\r\n            texture._cachedWrapR = wrapR;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number = 1): void {\r\n        if (!texture._hardwareTexture) {\r\n            // the gpu texture is not created yet, so when it is it will be created with the right dimensions\r\n            return;\r\n        }\r\n\r\n        if (texture.width === width && texture.height === height && texture.depth === depth) {\r\n            return;\r\n        }\r\n\r\n        const additionalUsages = (texture._hardwareTexture as WebGPUHardwareTexture).textureAdditionalUsages;\r\n\r\n        texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setInternalTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>, baseName?: string): void {\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            const webgpuPipelineContext = this._currentEffect._pipelineContext as WebGPUPipelineContext;\r\n            const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\r\n\r\n            this._currentMaterialContext.setTexture(name, texture);\r\n\r\n            if (availableTexture && availableTexture.autoBindSampler) {\r\n                const samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;\r\n                this._currentMaterialContext.setSampler(samplerName, texture as InternalTexture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<BaseTexture>, name: string): void {\r\n        this._setTexture(channel, texture, false, false, name, name);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of texture to the WebGPU context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param unused unused parameter\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public setTextureArray(channel: number, unused: Nullable<WebGLUniformLocation>, textures: BaseTexture[], name: string): void {\r\n        for (let index = 0; index < textures.length; index++) {\r\n            this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\r\n        }\r\n    }\r\n\r\n    protected _setTexture(\r\n        channel: number,\r\n        texture: Nullable<BaseTexture>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        isPartOfTextureArray = false,\r\n        depthStencilTexture = false,\r\n        name = \"\",\r\n        baseName?: string\r\n    ): boolean {\r\n        // name == baseName for a texture that is not part of a texture array\r\n        // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\r\n        // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\r\n        // name is used to look up the texture in the _currentMaterialContext.textures map\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            if (!texture) {\r\n                this._currentMaterialContext.setTexture(name, null);\r\n                return false;\r\n            }\r\n\r\n            // Video\r\n            if ((<VideoTexture>texture).video) {\r\n                (<VideoTexture>texture).update();\r\n            } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n                // Delay loading\r\n                texture.delayLoad();\r\n                return false;\r\n            }\r\n\r\n            let internalTexture: Nullable<InternalTexture> = null;\r\n            if (depthStencilTexture) {\r\n                internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n            } else if (texture.isReady()) {\r\n                internalTexture = <InternalTexture>texture.getInternalTexture();\r\n            } else if (texture.isCube) {\r\n                internalTexture = this.emptyCubeTexture;\r\n            } else if (texture.is3D) {\r\n                internalTexture = this.emptyTexture3D;\r\n            } else if (texture.is2DArray) {\r\n                internalTexture = this.emptyTexture2DArray;\r\n            } else {\r\n                internalTexture = this.emptyTexture;\r\n            }\r\n\r\n            if (internalTexture && !internalTexture.isMultiview) {\r\n                // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\r\n                if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\r\n                    internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\r\n\r\n                    const textureWrapMode =\r\n                        texture.coordinatesMode !== Constants.TEXTURE_CUBIC_MODE && texture.coordinatesMode !== Constants.TEXTURE_SKYBOX_MODE\r\n                            ? Constants.TEXTURE_WRAP_ADDRESSMODE\r\n                            : Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    texture.wrapU = textureWrapMode;\r\n                    texture.wrapV = textureWrapMode;\r\n                }\r\n\r\n                internalTexture._cachedWrapU = texture.wrapU;\r\n                internalTexture._cachedWrapV = texture.wrapV;\r\n                if (internalTexture.is3D) {\r\n                    internalTexture._cachedWrapR = texture.wrapR;\r\n                }\r\n\r\n                this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\r\n            }\r\n\r\n            this._setInternalTexture(name, internalTexture, baseName);\r\n        } else {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - _setTexture called with a null _currentEffect! texture=\", texture);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setAnisotropicLevel(target: number, internalTexture: InternalTexture, anisotropicFilteringLevel: number) {\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\r\n            internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture, name: string): void {\r\n        if (channel === undefined) {\r\n            return;\r\n        }\r\n\r\n        this._setInternalTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Generates the mipmaps for a texture\r\n     * @param texture texture to generate the mipmaps for\r\n     */\r\n    public generateMipmaps(texture: InternalTexture): void {\r\n        this._generateMipmaps(texture, this._renderTargetEncoder);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateMipmaps(texture: InternalTexture, commandEncoder?: GPUCommandEncoder) {\r\n        const gpuHardwareTexture = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (!gpuHardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        // try as much as possible to use the command encoder corresponding to the current pass.\r\n        // If not possible (because the pass is started - generateMipmaps itself creates a pass and it's not allowed to have a pass inside a pass), use _uploadEncoder\r\n        commandEncoder =\r\n            commandEncoder ??\r\n            (this._currentRenderTarget && !this._currentRenderPass ? this._renderTargetEncoder : !this._currentRenderPass ? this._renderEncoder : this._uploadEncoder);\r\n\r\n        const format = (texture._hardwareTexture as WebGPUHardwareTexture).format;\r\n        const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - generate mipmaps called - width=\", texture.width, \"height=\", texture.height, \"isCube=\", texture.isCube);\r\n            }\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\r\n        } else {\r\n            this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\r\n\r\n        if (generateMipMaps) {\r\n            this._generateMipmaps(texture, this._renderTargetEncoder);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            texture.format = internalFormat;\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight = false\r\n    ): void {\r\n        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\r\n        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\r\n\r\n        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\r\n        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\r\n\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement | ImageBitmap, faceIndex: number = 0, lod: number = 0) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        if (image instanceof HTMLImageElement) {\r\n            throw \"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!\";\r\n        }\r\n\r\n        const bitmap = image as ImageBitmap; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\r\n\r\n        const width = Math.ceil(texture.width / (1 << lod));\r\n        const height = Math.ceil(texture.height / (1 << lod));\r\n\r\n        this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public readPixels(x: number, y: number, width: number, height: number, hasAlpha = true, flushRenderer = true): Promise<ArrayBufferView> {\r\n        const renderPassWrapper = this._rttRenderPassWrapper.renderPass ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\r\n        const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];\r\n        if (!hardwareTexture) {\r\n            // we are calling readPixels for a render pass with no color texture bound\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        const gpuTexture = hardwareTexture.underlyingResource;\r\n        const gpuTextureFormat = hardwareTexture.format;\r\n        if (!gpuTexture) {\r\n            // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        if (flushRenderer) {\r\n            this.flushFramebuffer();\r\n        }\r\n        return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Frame management\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public beginFrame(): void {\r\n        super.beginFrame();\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public endFrame() {\r\n        this._snapshotRendering.endFrame(this._mainRenderPassWrapper.renderPass);\r\n\r\n        this._endMainRenderPass();\r\n\r\n        this._timestampQuery.endFrame(this._renderEncoder);\r\n\r\n        this.flushFramebuffer(false);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - counters\");\r\n            }\r\n        }\r\n\r\n        this._textureHelper.destroyDeferredTextures();\r\n        this._bufferManager.destroyDeferredBuffers();\r\n\r\n        if (this._features._collectUbosUpdatedInFrame) {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    const list: Array<string> = [];\r\n                    for (const name in UniformBuffer._UpdatedUbosInFrame) {\r\n                        list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\r\n                    }\r\n                    console.log(\"frame #\" + (this as any)._count + \" - updated ubos -\", list.join(\", \"));\r\n                }\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame = {};\r\n        }\r\n\r\n        this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\r\n        this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\r\n        this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\r\n        this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\r\n        this._counters.numEnableEffects = 0;\r\n        this._counters.numEnableDrawWrapper = 0;\r\n        this._counters.numBundleCreationNonCompatMode = 0;\r\n        this._counters.numBundleReuseNonCompatMode = 0;\r\n\r\n        this._cacheRenderPipeline.endFrame();\r\n        this._cacheBindGroups.endFrame();\r\n\r\n        this._pendingDebugCommands.length = 0;\r\n\r\n        super.endFrame();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"%c frame #\" + (this as any)._count + \" - end\", \"background: #ffff00\");\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                (this as any)._count++;\r\n                if ((this as any)._count !== this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a WebGPU flush (ie. a flush of all waiting commands)\r\n     * @param reopenPass true to reopen at the end of the function the pass that was active when entering the function\r\n     */\r\n    public flushFramebuffer(reopenPass = true): void {\r\n        // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\r\n        const currentRenderPassIsNULL = !this._currentRenderPass;\r\n        let currentPasses = 0; // 0 if no pass, 1 for rtt, 2 for main pass\r\n        if (this._currentRenderPass && this._currentRenderTarget) {\r\n            currentPasses |= 1;\r\n            this._endRenderTargetRenderPass();\r\n        }\r\n        if (this._mainRenderPassWrapper.renderPass) {\r\n            currentPasses |= 2;\r\n            this._endMainRenderPass();\r\n        }\r\n\r\n        this._commandBuffers[0] = this._uploadEncoder.finish();\r\n        this._commandBuffers[1] = this._renderTargetEncoder.finish();\r\n        this._commandBuffers[2] = this._renderEncoder.finish();\r\n\r\n        this._device.queue.submit(this._commandBuffers);\r\n\r\n        this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n        this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n        this._renderTargetEncoder = this._device.createCommandEncoder(this._renderTargetEncoderDescriptor);\r\n\r\n        this._timestampQuery.startFrame(this._uploadEncoder);\r\n\r\n        this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n        this._bundleList.reset();\r\n        this._bundleListRenderTarget.reset();\r\n\r\n        // restart the render pass\r\n        if (reopenPass) {\r\n            if (currentPasses & 2) {\r\n                this._startMainRenderPass(false);\r\n            }\r\n            if (currentPasses & 1) {\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget!, false, null, false, false);\r\n            }\r\n            if (currentRenderPassIsNULL && this._currentRenderTarget) {\r\n                this._currentRenderPass = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _currentFrameBufferIsDefaultFrameBuffer() {\r\n        return this._currentRenderTarget === null;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render Pass\r\n    //------------------------------------------------------------------------------\r\n\r\n    private _startRenderTargetRenderPass(\r\n        renderTargetWrapper: RenderTargetWrapper,\r\n        setClearStates: boolean,\r\n        clearColor: Nullable<IColor4Like>,\r\n        clearDepth: boolean,\r\n        clearStencil: boolean\r\n    ) {\r\n        const rtWrapper = renderTargetWrapper as WebGPURenderTargetWrapper;\r\n\r\n        const depthStencilTexture = rtWrapper._depthStencilTexture;\r\n        const gpuDepthStencilWrapper = depthStencilTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n        const gpuDepthStencilTexture = gpuDepthStencilWrapper?.underlyingResource as Nullable<GPUTexture>;\r\n        const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper?.msaaTexture;\r\n\r\n        const depthTextureView = gpuDepthStencilTexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthMSAATextureView = gpuDepthStencilMSAATexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;\r\n\r\n        const colorAttachments: (GPURenderPassColorAttachment | null)[] = [];\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        if (rtWrapper._attachments && rtWrapper.isMulti) {\r\n            // multi render targets\r\n            if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\r\n                this._mrtAttachments = rtWrapper._defaultAttachments;\r\n            }\r\n            for (let i = 0; i < this._mrtAttachments.length; ++i) {\r\n                const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\r\n                const mrtTexture = rtWrapper.textures![i];\r\n                const gpuMRTWrapper = mrtTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n                const gpuMRTTexture = gpuMRTWrapper?.underlyingResource;\r\n                if (gpuMRTWrapper && gpuMRTTexture) {\r\n                    const viewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        format: gpuMRTWrapper.format,\r\n                    };\r\n                    const gpuMSAATexture = gpuMRTWrapper.msaaTexture;\r\n                    const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\r\n                    const colorMSAATextureView = gpuMSAATexture?.createView(viewDescriptor);\r\n\r\n                    colorAttachments.push({\r\n                        view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                        resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                        clearValue: index !== 0 && mustClearColor ? clearColor : undefined,\r\n                        loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    });\r\n                }\r\n            }\r\n            this._cacheRenderPipeline.setMRT(rtWrapper.textures!, this._mrtAttachments.length);\r\n            this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        } else {\r\n            // single render target\r\n            const internalTexture = rtWrapper.texture;\r\n            if (internalTexture) {\r\n                const gpuWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n                const gpuTexture = gpuWrapper.underlyingResource!;\r\n\r\n                const gpuMSAATexture = gpuWrapper.msaaTexture;\r\n                const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n                const colorMSAATextureView = gpuMSAATexture?.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n\r\n                colorAttachments.push({\r\n                    view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                    resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                    clearValue: mustClearColor ? clearColor : undefined,\r\n                    loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                });\r\n            } else {\r\n                colorAttachments.push(null);\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"render target pass\", 1);\r\n\r\n        this._rttRenderPassWrapper.renderPassDescriptor = {\r\n            colorAttachments,\r\n            depthStencilAttachment:\r\n                depthStencilTexture && gpuDepthStencilTexture\r\n                    ? {\r\n                          view: depthMSAATextureView ? depthMSAATextureView : depthTextureView!,\r\n                          depthClearValue: mustClearDepth ? (this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue) : undefined,\r\n                          depthLoadOp: mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                          depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n                          stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\r\n                          stencilLoadOp: !depthTextureHasStencil\r\n                              ? undefined\r\n                              : rtWrapper._depthStencilTextureWithStencil && mustClearStencil\r\n                              ? WebGPUConstants.LoadOp.Clear\r\n                              : WebGPUConstants.LoadOp.Load,\r\n                          stencilStoreOp: !depthTextureHasStencil ? undefined : WebGPUConstants.StoreOp.Store,\r\n                      }\r\n                    : undefined,\r\n            occlusionQuerySet: this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined,\r\n        };\r\n        this._rttRenderPassWrapper.renderPass = this._renderTargetEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                const internalTexture = rtWrapper.texture!;\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - render target begin pass - internalTexture.uniqueId=\",\r\n                    internalTexture.uniqueId,\r\n                    \"width=\",\r\n                    internalTexture.width,\r\n                    \"height=\",\r\n                    internalTexture.height,\r\n                    this._rttRenderPassWrapper.renderPassDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._currentRenderPass = this._rttRenderPassWrapper.renderPass;\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetCurrentViewport(1);\r\n        this._resetCurrentScissor(1);\r\n        this._resetCurrentStencilRef(1);\r\n        this._resetCurrentColorBlend(1);\r\n\r\n        if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _endRenderTargetRenderPass() {\r\n        if (this._currentRenderPass) {\r\n            const gpuWrapper = this._currentRenderTarget!.texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n            if (gpuWrapper && !this._snapshotRendering.endRenderTargetPass(this._currentRenderPass, gpuWrapper) && !this.compatibilityMode) {\r\n                this._bundleListRenderTarget.run(this._currentRenderPass);\r\n                this._bundleListRenderTarget.reset();\r\n            }\r\n            this._currentRenderPass.end();\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - render target end pass - internalTexture.uniqueId=\", this._currentRenderTarget?.texture?.uniqueId);\r\n                }\r\n            }\r\n            this._debugPopGroup?.(1);\r\n            this._resetCurrentViewport(1);\r\n            this._resetCurrentScissor(1);\r\n            this._resetCurrentStencilRef(1);\r\n            this._resetCurrentColorBlend(1);\r\n            this._currentRenderPass = null;\r\n            this._rttRenderPassWrapper.reset();\r\n        }\r\n    }\r\n\r\n    private _getCurrentRenderPass(): GPURenderPassEncoder {\r\n        if (this._currentRenderTarget && !this._currentRenderPass) {\r\n            // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\r\n            this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\r\n        } else if (!this._currentRenderPass) {\r\n            this._startMainRenderPass(false);\r\n        }\r\n\r\n        return this._currentRenderPass!;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getCurrentRenderPassIndex(): number {\r\n        return this._currentRenderPass === null ? -1 : this._currentRenderPass === this._mainRenderPassWrapper.renderPass ? 0 : 1;\r\n    }\r\n\r\n    private _startMainRenderPass(setClearStates: boolean, clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        if (this._mainRenderPassWrapper.renderPass) {\r\n            this.flushFramebuffer(false);\r\n        }\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.clearValue = mustClearColor ? clearColor : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthClearValue = mustClearDepth\r\n            ? this.useReverseDepthBuffer\r\n                ? this._clearReverseDepthValue\r\n                : this._clearDepthValue\r\n            : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilLoadOp = !this.isStencilEnable\r\n            ? undefined\r\n            : mustClearStencil\r\n            ? WebGPUConstants.LoadOp.Clear\r\n            : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.occlusionQuerySet = this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined;\r\n\r\n        const swapChainTexture = this._context.getCurrentTexture();\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.set(swapChainTexture);\r\n\r\n        // Resolve in case of MSAA\r\n        if (this._options.antialiasing) {\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.resolveTarget = swapChainTexture.createView();\r\n        } else {\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.view = swapChainTexture.createView();\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - main begin pass - texture width=\" + (this._mainTextureExtends as any).width,\r\n                    \" height=\" + (this._mainTextureExtends as any).height,\r\n                    this._mainRenderPassWrapper.renderPassDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"main pass\", 0);\r\n\r\n        this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor!);\r\n\r\n        this._mainRenderPassWrapper.renderPass = this._currentRenderPass;\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetCurrentViewport(0);\r\n        this._resetCurrentScissor(0);\r\n        this._resetCurrentStencilRef(0);\r\n        this._resetCurrentColorBlend(0);\r\n\r\n        if (!this._isStencilEnable) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    private _endMainRenderPass(): void {\r\n        if (this._mainRenderPassWrapper.renderPass !== null) {\r\n            this._snapshotRendering.endMainRenderPass();\r\n            if (!this.compatibilityMode && !this._snapshotRendering.play) {\r\n                this._bundleList.run(this._mainRenderPassWrapper.renderPass);\r\n                this._bundleList.reset();\r\n            }\r\n            this._mainRenderPassWrapper.renderPass.end();\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    console.log(\"frame #\" + (this as any)._count + \" - main end pass\");\r\n                }\r\n            }\r\n            this._debugPopGroup?.(0);\r\n            this._resetCurrentViewport(0);\r\n            this._resetCurrentScissor(0);\r\n            this._resetCurrentStencilRef(0);\r\n            this._resetCurrentColorBlend(0);\r\n            if (this._mainRenderPassWrapper.renderPass === this._currentRenderPass) {\r\n                this._currentRenderPass = null;\r\n            }\r\n            this._mainRenderPassWrapper.reset(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex: number = 0,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel = 0,\r\n        layer = 0\r\n    ): void {\r\n        const hardwareTexture = texture.texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n        this._currentRenderTarget = texture;\r\n        if (hardwareTexture) {\r\n            hardwareTexture._currentLayer = texture.isCube ? layer * 6 + faceIndex : layer;\r\n        }\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\r\n        this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture\r\n            ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format)\r\n            : undefined;\r\n\r\n        this._setDepthTextureFormat(this._rttRenderPassWrapper);\r\n        this._setColorFormat(this._rttRenderPassWrapper);\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\r\n            format: this._colorFormat as GPUTextureFormat,\r\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: lodLevel,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\r\n            format: this._depthTextureFormat!,\r\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\r\n                    \"frame #\" + (this as any)._count + \" - bindFramebuffer called - internalTexture.uniqueId=\",\r\n                    texture.texture?.uniqueId,\r\n                    \"face=\",\r\n                    faceIndex,\r\n                    \"lodLevel=\",\r\n                    lodLevel,\r\n                    \"layer=\",\r\n                    layer,\r\n                    this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\r\n                    this._rttRenderPassWrapper.depthAttachmentViewDescriptor\r\n                );\r\n            }\r\n        }\r\n\r\n        this._currentRenderPass = null; // lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\r\n\r\n        if (this.snapshotRendering && this.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST) {\r\n            // force the creation of the render pass as we know in fast snapshot rendering mode clear() won't be called\r\n            this._getCurrentRenderPass();\r\n        }\r\n\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        } else {\r\n            if (!requiredWidth) {\r\n                requiredWidth = texture.width;\r\n                if (lodLevel) {\r\n                    requiredWidth = requiredWidth / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n            if (!requiredHeight) {\r\n                requiredHeight = texture.height;\r\n                if (lodLevel) {\r\n                    requiredHeight = requiredHeight / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n\r\n            this._viewport(0, 0, requiredWidth, requiredHeight);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the WebGPU context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        const saveCRT = this._currentRenderTarget;\r\n\r\n        this._currentRenderTarget = null; // to be iso with thinEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._currentRenderTarget = saveCRT;\r\n\r\n        if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\r\n            this._endRenderTargetRenderPass();\r\n        }\r\n\r\n        if (texture.texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture.texture);\r\n        }\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        this._onAfterUnbindFrameBufferObservable.notifyObservers(this);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                console.log(\"frame #\" + (this as any)._count + \" - unBindFramebuffer called - internalTexture.uniqueId=\", texture.texture?.uniqueId);\r\n            }\r\n        }\r\n\r\n        this._mrtAttachments = [];\r\n        this._cacheRenderPipeline.setMRT([]);\r\n        this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public restoreDefaultFramebuffer(): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else {\r\n            this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n            this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n            this._setColorFormat(this._mainRenderPassWrapper);\r\n        }\r\n        if (this._currentRenderPass) {\r\n            if (this._cachedViewport) {\r\n                this.setViewport(this._cachedViewport);\r\n            }\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setColorFormat(wrapper: WebGPURenderPassWrapper): void {\r\n        const format = wrapper.colorAttachmentGPUTextures[0]?.format ?? null;\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n        if (this._colorFormat === format) {\r\n            return;\r\n        }\r\n        this._colorFormat = format;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDepthTextureFormat(wrapper: WebGPURenderPassWrapper): void {\r\n        this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\r\n        if (this._depthTextureFormat === wrapper.depthTextureFormat) {\r\n            return;\r\n        }\r\n        this._depthTextureFormat = wrapper.depthTextureFormat;\r\n    }\r\n\r\n    public setDitheringState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    public setRasterizerState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        // Culling\r\n        if (this._depthCullingState.cull !== culling || force) {\r\n            this._depthCullingState.cull = culling;\r\n        }\r\n\r\n        // Cull face\r\n        const cullFace = this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 2;\r\n        if (this._depthCullingState.cullFace !== cullFace || force) {\r\n            this._depthCullingState.cullFace = cullFace;\r\n        }\r\n\r\n        // Z offset\r\n        this.setZOffset(zOffset);\r\n        this.setZOffsetUnits(zOffsetUnits);\r\n\r\n        // Front face\r\n        const frontFace = reverseSide ? (this._currentRenderTarget ? 1 : 2) : this._currentRenderTarget ? 2 : 1;\r\n        if (this._depthCullingState.frontFace !== frontFace || force) {\r\n            this._depthCullingState.frontFace = frontFace;\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = stencil;\r\n    }\r\n\r\n    private _applyRenderPassChanges(renderPass: GPURenderPassEncoder, bundleList: Nullable<WebGPUBundleList>): void {\r\n        const mustUpdateViewport = this._mustUpdateViewport(renderPass);\r\n        const mustUpdateScissor = this._mustUpdateScissor(renderPass);\r\n        const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef(renderPass);\r\n        const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor(renderPass);\r\n\r\n        if (bundleList) {\r\n            if (mustUpdateViewport) {\r\n                bundleList.addItem(new WebGPURenderItemViewport(this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w));\r\n            }\r\n            if (mustUpdateScissor) {\r\n                bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w));\r\n            }\r\n            if (mustUpdateStencilRef) {\r\n                bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n            }\r\n            if (mustUpdateBlendColor) {\r\n                bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\r\n            }\r\n        } else {\r\n            if (mustUpdateViewport) {\r\n                this._applyViewport(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateScissor) {\r\n                this._applyScissor(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateStencilRef) {\r\n                this._applyStencilRef(renderPass as GPURenderPassEncoder);\r\n            }\r\n            if (mustUpdateBlendColor) {\r\n                this._applyBlendColor(renderPass as GPURenderPassEncoder);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _draw(drawType: number, fillMode: number, start: number, count: number, instancesCount: number): void {\r\n        const renderPass = this._getCurrentRenderPass();\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n\r\n        this.applyStates();\r\n\r\n        const webgpuPipelineContext = this._currentEffect!._pipelineContext as WebGPUPipelineContext;\r\n\r\n        this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\r\n\r\n        if (webgpuPipelineContext.uniformBuffer) {\r\n            webgpuPipelineContext.uniformBuffer.update();\r\n            this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer()!, 0, WebGPUShaderProcessor.LeftOvertUBOName);\r\n        }\r\n\r\n        if (this._snapshotRendering.play) {\r\n            this._reportDrawCall();\r\n            return;\r\n        }\r\n\r\n        if (\r\n            !this.compatibilityMode &&\r\n            (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)\r\n        ) {\r\n            this._currentDrawContext.fastBundle = undefined;\r\n        }\r\n\r\n        const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder = renderPass;\r\n\r\n        if (useFastPath || this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(renderPass, bundleList);\r\n            if (!this._snapshotRendering.record) {\r\n                this._counters.numBundleReuseNonCompatMode++;\r\n                if (this._currentDrawContext.indirectDrawBuffer) {\r\n                    this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n                }\r\n                bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n                this._reportDrawCall();\r\n                return;\r\n            }\r\n\r\n            renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\r\n            bundleList.numDrawCalls++;\r\n        }\r\n\r\n        let textureState = 0;\r\n        if (!this._caps.textureFloatLinearFiltering && this._currentMaterialContext.hasFloatTextures) {\r\n            let bitVal = 1;\r\n            for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\r\n                const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\r\n                const texture = this._currentMaterialContext.textures[textureName]?.texture;\r\n                if (texture?.type === Constants.TEXTURETYPE_FLOAT) {\r\n                    textureState |= bitVal;\r\n                }\r\n                bitVal = bitVal << 1;\r\n            }\r\n        }\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect!, this.currentSampleCount, textureState);\r\n        const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\r\n\r\n        if (!this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(renderPass, !this.compatibilityMode ? bundleList : null);\r\n            if (!this.compatibilityMode) {\r\n                this._counters.numBundleCreationNonCompatMode++;\r\n                renderPass2 = this._device.createRenderBundleEncoder({\r\n                    colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                    depthStencilFormat: this._depthTextureFormat,\r\n                    sampleCount: this.currentSampleCount,\r\n                });\r\n            }\r\n        }\r\n\r\n        // bind pipeline\r\n        renderPass2.setPipeline(pipeline);\r\n\r\n        // bind index/vertex buffers\r\n        if (this._currentIndexBuffer) {\r\n            renderPass2.setIndexBuffer(\r\n                this._currentIndexBuffer.underlyingResource,\r\n                this._currentIndexBuffer!.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16,\r\n                0\r\n            );\r\n        }\r\n\r\n        const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\r\n        for (let index = 0; index < vertexBuffers.length; index++) {\r\n            const vertexBuffer = vertexBuffers[index];\r\n\r\n            const buffer = vertexBuffer.getBuffer();\r\n            if (buffer) {\r\n                renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\r\n            }\r\n        }\r\n\r\n        // bind bind groups\r\n        for (let i = 0; i < bindGroups.length; i++) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n\r\n        // draw\r\n        const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\r\n\r\n        if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {\r\n            this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n            if (drawType === 0) {\r\n                renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            } else {\r\n                renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            }\r\n        } else if (drawType === 0) {\r\n            renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\r\n        } else {\r\n            renderPass2.draw(count, instancesCount || 1, start, 0);\r\n        }\r\n\r\n        if (nonCompatMode) {\r\n            this._currentDrawContext.fastBundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n        }\r\n\r\n        this._reportDrawCall();\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount: number = 1): void {\r\n        this._draw(0, fillMode, indexStart, indexCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount: number = 1): void {\r\n        this._currentIndexBuffer = null;\r\n        this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._mainTexture?.destroy();\r\n        this._depthTexture?.destroy();\r\n        super.dispose();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Misc\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._canvas.width;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._canvas.height;\r\n    }\r\n\r\n    /**\r\n     * Gets the HTML canvas attached with the current WebGPU context\r\n     * @returns a HTML canvas\r\n     */\r\n    public getRenderingCanvas(): Nullable<HTMLCanvasElement> {\r\n        return this._canvas;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Errors\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Get the current error code of the WebGPU context\r\n     * @returns the error code\r\n     */\r\n    public getError(): number {\r\n        // TODO WEBGPU. from the webgpu errors.\r\n        return 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Unused WebGPU\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindSamplers(): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTextureDirectly(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns always true - No parallel shader compilation\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        // No parallel shader compilation.\r\n        // No Async, so direct launch\r\n        action();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isRenderingStateCompiled(): boolean {\r\n        // No parallel shader compilation.\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unpackFlipY() {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindUnboundFramebuffer() {\r\n        throw \"_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead\";\r\n    }\r\n\r\n    // TODO WEBGPU. All of the below should go once engine split with baseEngine.\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getSamplingParameters(): { min: number; mag: number } {\r\n        throw \"_getSamplingParameters is not available in WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public getUniforms(): Nullable<WebGLUniformLocation>[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setIntArray4(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setArray4(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setMatrices(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setMatrix3x3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setMatrix2x2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat2(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat3(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setFloat4(): boolean {\r\n        return false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}