{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Engine } from \"../engine.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Class used to define an additional view for the engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/multiCanvas\n */\nexport class EngineView {}\nconst _onBeforeViewRenderObservable = new Observable();\nconst _onAfterViewRenderObservable = new Observable();\nObject.defineProperty(Engine.prototype, \"onBeforeViewRenderObservable\", {\n  get: function () {\n    return _onBeforeViewRenderObservable;\n  }\n});\nObject.defineProperty(Engine.prototype, \"onAfterViewRenderObservable\", {\n  get: function () {\n    return _onAfterViewRenderObservable;\n  }\n});\nObject.defineProperty(Engine.prototype, \"inputElement\", {\n  get: function () {\n    return this._inputElement;\n  },\n  set: function (value) {\n    var _a;\n    if (this._inputElement !== value) {\n      this._inputElement = value;\n      (_a = this._onEngineViewChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n  }\n});\nEngine.prototype.getInputElement = function () {\n  return this.inputElement || this.getRenderingCanvas();\n};\nEngine.prototype.registerView = function (canvas, camera, clearBeforeCopy) {\n  if (!this.views) {\n    this.views = [];\n  }\n  for (const view of this.views) {\n    if (view.target === canvas) {\n      return view;\n    }\n  }\n  const masterCanvas = this.getRenderingCanvas();\n  if (masterCanvas) {\n    canvas.width = masterCanvas.width;\n    canvas.height = masterCanvas.height;\n  }\n  const newView = {\n    target: canvas,\n    camera,\n    clearBeforeCopy,\n    enabled: true,\n    id: (Math.random() * 100000).toFixed()\n  };\n  this.views.push(newView);\n  if (camera) {\n    camera.onDisposeObservable.add(() => {\n      this.unRegisterView(canvas);\n    });\n  }\n  return newView;\n};\nEngine.prototype.unRegisterView = function (canvas) {\n  if (!this.views || this.views.length === 0) {\n    return this;\n  }\n  for (const view of this.views) {\n    if (view.target === canvas) {\n      const index = this.views.indexOf(view);\n      if (index !== -1) {\n        this.views.splice(index, 1);\n      }\n      break;\n    }\n  }\n  return this;\n};\nEngine.prototype._renderViewStep = function (view) {\n  const canvas = view.target;\n  const context = canvas.getContext(\"2d\");\n  if (!context) {\n    return true;\n  }\n  const parent = this.getRenderingCanvas();\n  _onBeforeViewRenderObservable.notifyObservers(view);\n  const camera = view.camera;\n  let previewCamera = null;\n  let scene = null;\n  if (camera) {\n    scene = camera.getScene();\n    if (!scene || scene.activeCameras && scene.activeCameras.length) {\n      return true;\n    }\n    this.activeView = view;\n    previewCamera = scene.activeCamera;\n    scene.activeCamera = camera;\n  }\n  if (view.customResize) {\n    view.customResize(canvas);\n  } else {\n    // Set sizes\n    const width = Math.floor(canvas.clientWidth / this._hardwareScalingLevel);\n    const height = Math.floor(canvas.clientHeight / this._hardwareScalingLevel);\n    const dimsChanged = width !== canvas.width || parent.width !== canvas.width || height !== canvas.height || parent.height !== canvas.height;\n    if (canvas.clientWidth && canvas.clientHeight && dimsChanged) {\n      canvas.width = width;\n      canvas.height = height;\n      this.setSize(width, height);\n    }\n  }\n  if (!parent.width || !parent.height) {\n    return false;\n  }\n  // Render the frame\n  this._renderFrame();\n  this.flushFramebuffer();\n  // Copy to target\n  if (view.clearBeforeCopy) {\n    context.clearRect(0, 0, parent.width, parent.height);\n  }\n  context.drawImage(parent, 0, 0);\n  // Restore\n  if (previewCamera && scene) {\n    scene.activeCamera = previewCamera;\n  }\n  _onAfterViewRenderObservable.notifyObservers(view);\n  return true;\n};\nEngine.prototype._renderViews = function () {\n  if (!this.views || this.views.length === 0) {\n    return false;\n  }\n  const parent = this.getRenderingCanvas();\n  if (!parent) {\n    return false;\n  }\n  let inputElementView;\n  for (const view of this.views) {\n    if (!view.enabled) {\n      continue;\n    }\n    const canvas = view.target;\n    // Always render the view correspondent to the inputElement for last\n    if (canvas === this.inputElement) {\n      inputElementView = view;\n      continue;\n    }\n    if (!this._renderViewStep(view)) {\n      return false;\n    }\n  }\n  if (inputElementView) {\n    if (!this._renderViewStep(inputElementView)) {\n      return false;\n    }\n  }\n  this.activeView = null;\n  return true;\n};","map":{"version":3,"mappings":"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","names":["Engine","Observable","EngineView","_onBeforeViewRenderObservable","_onAfterViewRenderObservable","Object","defineProperty","prototype","get","_inputElement","set","value","_onEngineViewChanged","getInputElement","inputElement","getRenderingCanvas","registerView","canvas","camera","clearBeforeCopy","views","view","target","masterCanvas","width","height","newView","enabled","id","Math","random","toFixed","push","onDisposeObservable","add","unRegisterView","length","index","indexOf","splice","_renderViewStep","context","getContext","parent","notifyObservers","previewCamera","scene","getScene","activeCameras","activeView","activeCamera","customResize","floor","clientWidth","_hardwareScalingLevel","clientHeight","dimsChanged","setSize","_renderFrame","flushFramebuffer","clearRect","drawImage","_renderViews","inputElementView"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Extensions/engine.views.ts"],"sourcesContent":["import { Engine } from \"../engine\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Class used to define an additional view for the engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/multiCanvas\r\n */\r\nexport class EngineView {\r\n    /**\r\n     * A randomly generated unique id\r\n     */\r\n    readonly id: string;\r\n    /** Defines the canvas where to render the view */\r\n    target: HTMLCanvasElement;\r\n    /** Defines an optional camera used to render the view (will use active camera else) */\r\n    camera?: Camera;\r\n    /** Indicates if the destination view canvas should be cleared before copying the parent canvas. Can help if the scene clear color has alpha < 1 */\r\n    clearBeforeCopy?: boolean;\r\n    /** Indicates if the view is enabled (true by default) */\r\n    enabled: boolean;\r\n    /** Defines a custom function to handle canvas size changes. (the canvas to render into is provided to the callback) */\r\n    customResize?: (canvas: HTMLCanvasElement) => void;\r\n}\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /** @internal */\r\n        _inputElement: Nullable<HTMLElement>;\r\n\r\n        /**\r\n         * Gets or sets the  HTML element to use for attaching events\r\n         */\r\n        inputElement: Nullable<HTMLElement>;\r\n\r\n        /**\r\n         * Observable to handle when a change to inputElement occurs\r\n         * @internal\r\n         */\r\n        _onEngineViewChanged?: () => void;\r\n\r\n        /**\r\n         * Will be triggered before the view renders\r\n         */\r\n        readonly onBeforeViewRenderObservable: Observable<EngineView>;\r\n        /**\r\n         * Will be triggered after the view rendered\r\n         */\r\n        readonly onAfterViewRenderObservable: Observable<EngineView>;\r\n\r\n        /**\r\n         * Gets the current engine view\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/multiCanvas\r\n         */\r\n        activeView: Nullable<EngineView>;\r\n\r\n        /** Gets or sets the list of views */\r\n        views: EngineView[];\r\n\r\n        /**\r\n         * Register a new child canvas\r\n         * @param canvas defines the canvas to register\r\n         * @param camera defines an optional camera to use with this canvas (it will overwrite the scene.camera for this view)\r\n         * @param clearBeforeCopy Indicates if the destination view canvas should be cleared before copying the parent canvas. Can help if the scene clear color has alpha < 1\r\n         * @returns the associated view\r\n         */\r\n        registerView(canvas: HTMLCanvasElement, camera?: Camera, clearBeforeCopy?: boolean): EngineView;\r\n\r\n        /**\r\n         * Remove a registered child canvas\r\n         * @param canvas defines the canvas to remove\r\n         * @returns the current engine\r\n         */\r\n        unRegisterView(canvas: HTMLCanvasElement): Engine;\r\n\r\n        /**\r\n         * @internal\r\n         */\r\n        _renderViewStep(view: EngineView): boolean;\r\n    }\r\n}\r\n\r\nconst _onBeforeViewRenderObservable = new Observable<EngineView>();\r\nconst _onAfterViewRenderObservable = new Observable<EngineView>();\r\n\r\nObject.defineProperty(Engine.prototype, \"onBeforeViewRenderObservable\", {\r\n    get: function (this: Engine) {\r\n        return _onBeforeViewRenderObservable;\r\n    },\r\n});\r\n\r\nObject.defineProperty(Engine.prototype, \"onAfterViewRenderObservable\", {\r\n    get: function (this: Engine) {\r\n        return _onAfterViewRenderObservable;\r\n    },\r\n});\r\n\r\nObject.defineProperty(Engine.prototype, \"inputElement\", {\r\n    get: function (this: Engine) {\r\n        return this._inputElement;\r\n    },\r\n    set: function (this: Engine, value: HTMLElement) {\r\n        if (this._inputElement !== value) {\r\n            this._inputElement = value;\r\n            this._onEngineViewChanged?.();\r\n        }\r\n    },\r\n});\r\n\r\nEngine.prototype.getInputElement = function (): Nullable<HTMLElement> {\r\n    return this.inputElement || this.getRenderingCanvas();\r\n};\r\n\r\nEngine.prototype.registerView = function (canvas: HTMLCanvasElement, camera?: Camera, clearBeforeCopy?: boolean): EngineView {\r\n    if (!this.views) {\r\n        this.views = [];\r\n    }\r\n\r\n    for (const view of this.views) {\r\n        if (view.target === canvas) {\r\n            return view;\r\n        }\r\n    }\r\n\r\n    const masterCanvas = this.getRenderingCanvas();\r\n    if (masterCanvas) {\r\n        canvas.width = masterCanvas.width;\r\n        canvas.height = masterCanvas.height;\r\n    }\r\n\r\n    const newView = { target: canvas, camera, clearBeforeCopy, enabled: true, id: (Math.random() * 100000).toFixed() };\r\n    this.views.push(newView);\r\n\r\n    if (camera) {\r\n        camera.onDisposeObservable.add(() => {\r\n            this.unRegisterView(canvas);\r\n        });\r\n    }\r\n\r\n    return newView;\r\n};\r\n\r\nEngine.prototype.unRegisterView = function (canvas: HTMLCanvasElement): Engine {\r\n    if (!this.views || this.views.length === 0) {\r\n        return this;\r\n    }\r\n\r\n    for (const view of this.views) {\r\n        if (view.target === canvas) {\r\n            const index = this.views.indexOf(view);\r\n\r\n            if (index !== -1) {\r\n                this.views.splice(index, 1);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nEngine.prototype._renderViewStep = function (view: EngineView): boolean {\r\n    const canvas = view.target;\r\n    const context = canvas.getContext(\"2d\");\r\n    if (!context) {\r\n        return true;\r\n    }\r\n    const parent = this.getRenderingCanvas()!;\r\n\r\n    _onBeforeViewRenderObservable.notifyObservers(view);\r\n    const camera = view.camera;\r\n    let previewCamera: Nullable<Camera> = null;\r\n    let scene: Nullable<Scene> = null;\r\n    if (camera) {\r\n        scene = camera.getScene();\r\n\r\n        if (!scene || (scene.activeCameras && scene.activeCameras.length)) {\r\n            return true;\r\n        }\r\n\r\n        this.activeView = view;\r\n\r\n        previewCamera = scene.activeCamera;\r\n        scene.activeCamera = camera;\r\n    }\r\n\r\n    if (view.customResize) {\r\n        view.customResize(canvas);\r\n    } else {\r\n        // Set sizes\r\n        const width = Math.floor(canvas.clientWidth / this._hardwareScalingLevel);\r\n        const height = Math.floor(canvas.clientHeight / this._hardwareScalingLevel);\r\n\r\n        const dimsChanged = width !== canvas.width || parent.width !== canvas.width || height !== canvas.height || parent.height !== canvas.height;\r\n        if (canvas.clientWidth && canvas.clientHeight && dimsChanged) {\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            this.setSize(width, height);\r\n        }\r\n    }\r\n\r\n    if (!parent.width || !parent.height) {\r\n        return false;\r\n    }\r\n\r\n    // Render the frame\r\n    this._renderFrame();\r\n\r\n    this.flushFramebuffer();\r\n\r\n    // Copy to target\r\n    if (view.clearBeforeCopy) {\r\n        context.clearRect(0, 0, parent.width, parent.height);\r\n    }\r\n    context.drawImage(parent, 0, 0);\r\n\r\n    // Restore\r\n    if (previewCamera && scene) {\r\n        scene.activeCamera = previewCamera;\r\n    }\r\n    _onAfterViewRenderObservable.notifyObservers(view);\r\n    return true;\r\n};\r\n\r\nEngine.prototype._renderViews = function () {\r\n    if (!this.views || this.views.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    const parent = this.getRenderingCanvas();\r\n\r\n    if (!parent) {\r\n        return false;\r\n    }\r\n\r\n    let inputElementView;\r\n    for (const view of this.views) {\r\n        if (!view.enabled) {\r\n            continue;\r\n        }\r\n        const canvas = view.target;\r\n        // Always render the view correspondent to the inputElement for last\r\n        if (canvas === this.inputElement) {\r\n            inputElementView = view;\r\n            continue;\r\n        }\r\n\r\n        if (!this._renderViewStep(view)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    if (inputElementView) {\r\n        if (!this._renderViewStep(inputElementView)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    this.activeView = null;\r\n\r\n    return true;\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}