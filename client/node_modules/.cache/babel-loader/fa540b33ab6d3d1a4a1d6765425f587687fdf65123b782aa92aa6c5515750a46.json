{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { Scalar } from \"../../../../Maths/math.scalar.js\";\n/**\n * Block used to implement the refraction part of the sub surface module of the PBR material\n */\nexport class RefractionBlock extends NodeMaterialBlock {\n  /**\n   * Create a new RefractionBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n    this.linkRefractionWithTransparency = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.useThicknessAsDepth = false;\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"vRefractionPosition\");\n    state._excludeVariableName(\"vRefractionSize\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"RefractionBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the tint at distance input component\n   */\n  get tintAtDistance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the volume index of refraction input component\n   */\n  get volumeIndexOfRefraction() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the view input component\n   */\n  get view() {\n    return this.viewConnectionPoint;\n  }\n  /**\n   * Gets the refraction object output component\n   */\n  get refraction() {\n    return this._outputs[0];\n  }\n  /**\n   * Returns true if the block has a texture\n   */\n  get hasTexture() {\n    return !!this._getTexture();\n  }\n  _getTexture() {\n    if (this.texture) {\n      return this.texture;\n    }\n    return this._scene.environmentTexture;\n  }\n  autoConfigure(material) {\n    if (!this.intensity.isConnected) {\n      const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n    }\n    if (this.view && !this.view.isConnected) {\n      let viewInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.View);\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n      viewInput.output.connectTo(this.view);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    const refractionTexture = this._getTexture();\n    const refraction = refractionTexture && refractionTexture.getTextureMatrix;\n    defines.setValue(\"SS_REFRACTION\", refraction, true);\n    if (!refraction) {\n      return;\n    }\n    defines.setValue(this._define3DName, refractionTexture.isCube, true);\n    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture.invertZ : refractionTexture.invertZ, true);\n    defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\n    defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture.gammaSpace, true);\n    defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture.isRGBD, true);\n    defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", refractionTexture.boundingBoxSize ? true : false, true);\n    defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\n  }\n  isReady() {\n    const texture = this._getTexture();\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect, nodeMaterial, mesh) {\n    var _a, _b, _c, _d;\n    super.bind(effect, nodeMaterial, mesh);\n    const refractionTexture = this._getTexture();\n    if (!refractionTexture) {\n      return;\n    }\n    if (refractionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, refractionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, refractionTexture);\n    }\n    effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());\n    let depth = 1.0;\n    if (!refractionTexture.isCube) {\n      if (refractionTexture.depth) {\n        depth = refractionTexture.depth;\n      }\n    }\n    const indexOfRefraction = (_d = (_b = (_a = this.volumeIndexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : (_c = this.indexOfRefractionConnectionPoint.connectInputBlock) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 1.5;\n    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n    effect.setFloat4(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / indexOfRefraction);\n    const width = refractionTexture.getSize().width;\n    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\n    if (refractionTexture.boundingBoxSize) {\n      const cubeTexture = refractionTexture;\n      effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n      effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n    }\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  getCode(state) {\n    const code = \"\";\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    // Samplers\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\n    state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\n    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\n    state._samplerDeclaration += `#else\\r\\n`;\n    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\n    state._samplerDeclaration += `#endif\\r\\n`;\n    // Fragment\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\n    this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\n    this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\n    this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\n    state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\n    state._emitFunction(\"sampleRefraction\", `\n            #ifdef ${this._define3DName}\n                #define sampleRefraction(s, c) textureCube(s, c)\n            #else\n                #define sampleRefraction(s, c) texture2D(s, c)\n            #endif\\r\\n`, `//${this.name}`);\n    state._emitFunction(\"sampleRefractionLod\", `\n            #ifdef ${this._define3DName}\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\n            #else\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\n            #endif\\r\\n`, `//${this.name}`);\n    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\n    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\n    this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\n    state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\n    this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\n    state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\n    state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\n    state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\n    return code;\n  }\n  _buildBlock(state) {\n    this._scene = state.sharedData.scene;\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (this.texture) {\n      if (this.texture.isCube) {\n        codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\r\\n`;\n      } else {\n        codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\r\\n`;\n      }\n      codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\n    }\n    codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\r\\n`;\n    codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\r\\n`;\n    codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\r\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\n    serializationObject.invertRefractionY = this.invertRefractionY;\n    serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\n    this.invertRefractionY = serializationObject.invertRefractionY;\n    this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\n  }\n}\n__decorate([editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"linkRefractionWithTransparency\", void 0);\n__decorate([editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"invertRefractionY\", void 0);\n__decorate([editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"useThicknessAsDepth\", void 0);\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","InputBlock","NodeMaterialConnectionPointCustomObject","editableInPropertyPage","PropertyTypeForEdition","NodeMaterialBlock","CubeTexture","Texture","NodeMaterialSystemValues","Scalar","RefractionBlock","constructor","name","Fragment","_isUnique","registerInput","Float","registerOutput","Object","Output","initialize","state","_excludeVariableName","getClassName","intensity","_inputs","tintAtDistance","volumeIndexOfRefraction","view","viewConnectionPoint","refraction","_outputs","hasTexture","_getTexture","texture","_scene","environmentTexture","autoConfigure","material","isConnected","intensityInput","value","output","connectTo","viewInput","getInputBlockByPredicate","b","systemValue","View","setAsSystemValue","prepareDefines","mesh","nodeMaterial","defines","refractionTexture","getTextureMatrix","setValue","_define3DName","isCube","_defineLODRefractionAlpha","lodLevelInAlpha","_defineLinearSpecularRefraction","linearSpecularLOD","_defineOppositeZ","useRightHandedSystem","invertZ","linkRefractionWithTransparency","gammaSpace","isRGBD","boundingBoxSize","useThicknessAsDepth","isReady","isReadyOrNotBlocking","bind","effect","setTexture","_cubeSamplerName","_2DSamplerName","setMatrix","_refractionMatrixName","getReflectionTextureMatrix","depth","indexOfRefraction","connectInputBlock","indexOfRefractionConnectionPoint","setFloat4","_vRefractionInfosName","level","invertRefractionY","_vRefractionMicrosurfaceInfosName","getSize","width","lodGenerationScale","lodGenerationOffset","setFloat2","_vRefractionFilteringInfoName","Log2","cubeTexture","setVector3","boundingBoxPosition","getCode","code","sharedData","blockingBlocks","push","textureBlocks","_getFreeVariableName","samplers","_getFreeDefineName","_samplerDeclaration","blocksWithDefines","bindableBlocks","_emitUniformFromString","_emitFunction","_buildBlock","scene","_dumpPropertiesCode","codeString","_codeVariableName","coordinatesMode","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","url","indexOf","Parse","__decorate","Boolean","notifiers","update"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/PBR/refractionBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Scalar } from \"../../../../Maths/math.scalar\";\r\n\r\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\r\nexport class RefractionBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _refractionMatrixName: string;\r\n    /** @internal */\r\n    public _defineLODRefractionAlpha: string;\r\n    /** @internal */\r\n    public _defineLinearSpecularRefraction: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _vRefractionMicrosurfaceInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionFilteringInfoName: string;\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /** @internal */\r\n    public indexOfRefractionConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public linkRefractionWithTransparency: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public invertRefractionY: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useThicknessAsDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new RefractionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"refraction\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vRefractionPosition\");\r\n        state._excludeVariableName(\"vRefractionSize\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RefractionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint at distance input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the volume index of refraction input component\r\n     */\r\n    public get volumeIndexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object output component\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const refractionTexture = this._getTexture();\r\n        const refraction = refractionTexture && refractionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"SS_REFRACTION\", refraction, true);\r\n\r\n        if (!refraction) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, refractionTexture!.isCube, true);\r\n        defines.setValue(this._defineLODRefractionAlpha, refractionTexture!.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularRefraction, refractionTexture!.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture!.invertZ : refractionTexture!.invertZ, true);\r\n\r\n        defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\r\n        defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture!.gammaSpace, true);\r\n        defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture!.isRGBD, true);\r\n        defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", (<any>refractionTexture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const refractionTexture = this._getTexture();\r\n\r\n        if (!refractionTexture) {\r\n            return;\r\n        }\r\n\r\n        if (refractionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, refractionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, refractionTexture);\r\n        }\r\n\r\n        effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());\r\n\r\n        let depth = 1.0;\r\n        if (!refractionTexture.isCube) {\r\n            if ((<any>refractionTexture).depth) {\r\n                depth = (<any>refractionTexture).depth;\r\n            }\r\n        }\r\n\r\n        const indexOfRefraction = this.volumeIndexOfRefraction.connectInputBlock?.value ?? this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;\r\n\r\n        effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n        effect.setFloat4(\r\n            this._vRefractionMicrosurfaceInfosName,\r\n            refractionTexture.getSize().width,\r\n            refractionTexture.lodGenerationScale,\r\n            refractionTexture.lodGenerationOffset,\r\n            1 / indexOfRefraction\r\n        );\r\n\r\n        const width = refractionTexture.getSize().width;\r\n\r\n        effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\r\n\r\n        if ((<any>refractionTexture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>refractionTexture;\r\n            effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState): string {\r\n        const code = \"\";\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#else\\r\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#endif\\r\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\r\n        this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\r\n\r\n        this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\r\n\r\n        state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\r\n\r\n        state._emitFunction(\r\n            \"sampleRefraction\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefraction(s, c) textureCube(s, c)\r\n            #else\r\n                #define sampleRefraction(s, c) texture2D(s, c)\r\n            #endif\\r\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        state._emitFunction(\r\n            \"sampleRefractionLod\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n            #else\r\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n            #endif\\r\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\r\n\r\n        this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\r\n\r\n        this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\r\n\r\n        state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\r\n        state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            if (this.texture.isCube) {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\r\\n`;\r\n            } else {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\r\\n`;\r\n            }\r\n            codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\r\n        serializationObject.invertRefractionY = this.invertRefractionY;\r\n        serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\r\n        this.invertRefractionY = serializationObject.invertRefractionY;\r\n        this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}