{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\n/**\n * Block used to output the final color\n */\nexport class FragmentOutputBlock extends NodeMaterialBlock {\n  /**\n   * Create a new FragmentOutputBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment, true);\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\n    this.convertToGammaSpace = false;\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\n    this.convertToLinearSpace = false;\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\n    this.useLogarithmicDepth = false;\n    this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\n    this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n    this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.rgb.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FragmentOutputBlock\";\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"logarithmicDepthConstant\");\n    state._excludeVariableName(\"vFragmentDepth\");\n  }\n  /**\n   * Gets the rgba input component\n   */\n  get rgba() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the rgb input component\n   */\n  get rgb() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the a input component\n   */\n  get a() {\n    return this._inputs[2];\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (this.useLogarithmicDepth && mesh) {\n      MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const rgba = this.rgba;\n    const rgb = this.rgb;\n    const a = this.a;\n    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\n    state.sharedData.blocksWithDefines.push(this);\n    if (this.useLogarithmicDepth) {\n      state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\n      state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\n      state.sharedData.bindableBlocks.push(this);\n    }\n    this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    if (rgba.connectedPoint) {\n      if (a.isConnected) {\n        state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\r\\n`;\n      } else {\n        state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\r\\n`;\n      }\n    } else if (rgb.connectedPoint) {\n      let aValue = \"1.0\";\n      if (a.connectedPoint) {\n        aValue = a.associatedVariableName;\n      }\n      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\n        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\r\\n`;\n      } else {\n        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\r\\n`;\n      }\n    } else {\n      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\n    }\n    state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\n    state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\n    state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    if (this.useLogarithmicDepth) {\n      state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\r\\n`;\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\n    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\n    codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\r\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    var _a;\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = serializationObject.convertToLinearSpace;\n    this.useLogarithmicDepth = (_a = serializationObject.useLogarithmicDepth) !== null && _a !== void 0 ? _a : false;\n  }\n}\n__decorate([editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], FragmentOutputBlock.prototype, \"convertToGammaSpace\", void 0);\n__decorate([editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], FragmentOutputBlock.prototype, \"convertToLinearSpace\", void 0);\n__decorate([editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")], FragmentOutputBlock.prototype, \"useLogarithmicDepth\", void 0);\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","MaterialHelper","FragmentOutputBlock","constructor","name","Fragment","registerInput","Color4","AutoDetect","Float","rgb","addExcludedConnectionPointFromAllowedTypes","Color3","Vector3","getClassName","initialize","state","_excludeVariableName","rgba","_inputs","a","prepareDefines","mesh","nodeMaterial","defines","setValue","_linearDefineName","convertToLinearSpace","_gammaDefineName","convertToGammaSpace","bind","effect","useLogarithmicDepth","BindLogDepth","undefined","getScene","_buildBlock","sharedData","hints","needAlphaBlending","isConnected","blocksWithDefines","push","_emitUniformFromString","_emitVaryingFromString","bindableBlocks","_getFreeDefineName","comments","_emitFunctionFromInclude","connectedPoint","compilationString","associatedVariableName","aValue","type","checks","notConnectedNonOptionalInputs","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","scene","rootUrl","__decorate","Boolean","notifiers","update"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Fragment/fragmentOutputBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\ndeclare type Effect = import(\"../../../effect\").Effect;\r\ndeclare type Mesh = import(\"../../../../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Block used to output the final color\r\n */\r\nexport class FragmentOutputBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n\r\n    /**\r\n     * Create a new FragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.rgb.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float\r\n        );\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\r\n    @editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\r\n    @editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToLinearSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\r\n    @editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")\r\n    public useLogarithmicDepth = false;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"logarithmicDepthConstant\");\r\n        state._excludeVariableName(\"vFragmentDepth\");\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb input component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the a input component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (this.useLogarithmicDepth && mesh) {\r\n            MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgba = this.rgba;\r\n        const rgb = this.rgb;\r\n        const a = this.a;\r\n\r\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        if (this.useLogarithmicDepth) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\r\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (rgba.connectedPoint) {\r\n            if (a.isConnected) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\r\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\r\\n`;\r\n            }\r\n        } else if (rgb.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n\r\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\r\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\r\\n`;\r\n            }\r\n        } else {\r\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n        state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n        state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = serializationObject.convertToLinearSpace;\r\n        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}