{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools.js\";\nimport \"../Engines/Extensions/engine.cubeTexture.js\";\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\nconst DDS_MAGIC = 0x20534444;\nconst\n//DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000;\n//DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\nconst DDSCAPS2_CUBEMAP = 0x200;\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\nconst\n  //DDPF_ALPHAPIXELS = 0x1,\n  //DDPF_ALPHA = 0x2,\n  DDPF_FOURCC = 0x4,\n  DDPF_RGB = 0x40,\n  //DDPF_YUV = 0x200,\n  DDPF_LUMINANCE = 0x20000;\nfunction FourCCToInt32(value) {\n  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\nfunction Int32ToFourCC(value) {\n  return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n}\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nconst headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\nconst off_magic = 0;\nconst off_size = 1;\nconst off_flags = 2;\nconst off_height = 3;\nconst off_width = 4;\nconst off_mipmapCount = 7;\nconst off_pfFlags = 20;\nconst off_pfFourCC = 21;\nconst off_RGBbpp = 22;\nconst off_RMask = 23;\nconst off_GMask = 24;\nconst off_BMask = 25;\nconst off_AMask = 26;\n// var off_caps1 = 27;\nconst off_caps2 = 28;\n// var off_caps3 = 29;\n// var off_caps4 = 30;\nconst off_dxgiFormat = 32;\n/**\n * Class used to provide DDS decompression tools\n */\nexport class DDSTools {\n  /**\n   * Gets DDS information from an array buffer\n   * @param data defines the array buffer view to read data from\n   * @returns the DDS information\n   */\n  static GetDDSInfo(data) {\n    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n    let mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const fourCC = header[off_pfFourCC];\n    const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n    let textureType = 0;\n    switch (fourCC) {\n      case FOURCC_D3DFMT_R16G16B16A16F:\n        textureType = 2;\n        break;\n      case FOURCC_D3DFMT_R32G32B32A32F:\n        textureType = 1;\n        break;\n      case FOURCC_DX10:\n        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n          textureType = 2;\n          break;\n        }\n        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n          textureType = 1;\n          break;\n        }\n    }\n    return {\n      width: header[off_width],\n      height: header[off_height],\n      mipmapCount: mipmapCount,\n      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n      dxgiFormat: dxgiFormat,\n      textureType: textureType\n    };\n  }\n  static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Float32Array(dataLength);\n    const srcData = new Uint16Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        destArray[index] = FromHalfFloat(srcData[srcPos]);\n        destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\n        destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      const destArray = new Uint16Array(dataLength);\n      const srcData = new Uint16Array(arrayBuffer, dataOffset);\n      let index = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = ToHalfFloat(lod);\n          index += 4;\n        }\n      }\n      return destArray;\n    }\n    return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n  }\n  static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      const destArray = new Float32Array(dataLength);\n      const srcData = new Float32Array(arrayBuffer, dataOffset);\n      let index = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = lod;\n          index += 4;\n        }\n      }\n      return destArray;\n    }\n    return new Float32Array(arrayBuffer, dataOffset, dataLength);\n  }\n  static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Uint16Array(dataLength);\n    const srcData = new Float32Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        destArray[index] = ToHalfFloat(srcData[index]);\n        destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\n        destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = ToHalfFloat(lod);\n        } else {\n          destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Uint8Array(dataLength);\n    const srcData = new Float32Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\n        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\n        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Uint8Array(dataLength);\n    const srcData = new Uint16Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\n        destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\n        destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n    const byteArray = new Uint8Array(dataLength);\n    const srcData = new Uint8Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        byteArray[index + 3] = srcData[srcPos + aOffset];\n        index += 4;\n      }\n    }\n    return byteArray;\n  }\n  static _ExtractLongWordOrder(value) {\n    if (value === 0 || value === 255 || value === -16777216) {\n      return 0;\n    }\n    return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n  }\n  static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n    const byteArray = new Uint8Array(dataLength);\n    const srcData = new Uint8Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 3;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        index += 3;\n      }\n    }\n    return byteArray;\n  }\n  static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {\n    const byteArray = new Uint8Array(dataLength);\n    const srcData = new Uint8Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = x + y * width;\n        byteArray[index] = srcData[srcPos];\n        index++;\n      }\n    }\n    return byteArray;\n  }\n  /**\n   * Uploads DDS Levels to a Babylon Texture\n   * @internal\n   */\n  static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {\n    let sphericalPolynomialFaces = null;\n    if (info.sphericalPolynomial) {\n      sphericalPolynomialFaces = new Array();\n    }\n    const ext = !!engine.getCaps().s3tc;\n    // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\n    texture.generateMipMaps = loadMipmaps;\n    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    let fourCC,\n      width,\n      height,\n      dataLength = 0,\n      dataOffset;\n    let byteArray, mipmapCount, mip;\n    let internalCompressedFormat = 0;\n    let blockBytes = 1;\n    if (header[off_magic] !== DDS_MAGIC) {\n      Logger.Error(\"Invalid magic number in DDS header\");\n      return;\n    }\n    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n      Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n      return;\n    }\n    if (info.isCompressed && !ext) {\n      Logger.Error(\"Compressed textures are not supported on this platform.\");\n      return;\n    }\n    let bpp = header[off_RGBbpp];\n    dataOffset = header[off_size] + 4;\n    let computeFormats = false;\n    if (info.isFourCC) {\n      fourCC = header[off_pfFourCC];\n      switch (fourCC) {\n        case FOURCC_DXT1:\n          blockBytes = 8;\n          internalCompressedFormat = 33777;\n          break;\n        case FOURCC_DXT3:\n          blockBytes = 16;\n          internalCompressedFormat = 33778;\n          break;\n        case FOURCC_DXT5:\n          blockBytes = 16;\n          internalCompressedFormat = 33779;\n          break;\n        case FOURCC_D3DFMT_R16G16B16A16F:\n          computeFormats = true;\n          bpp = 64;\n          break;\n        case FOURCC_D3DFMT_R32G32B32A32F:\n          computeFormats = true;\n          bpp = 128;\n          break;\n        case FOURCC_DX10:\n          {\n            // There is an additionnal header so dataOffset need to be changed\n            dataOffset += 5 * 4; // 5 uints\n            let supported = false;\n            switch (info.dxgiFormat) {\n              case DXGI_FORMAT_R16G16B16A16_FLOAT:\n                computeFormats = true;\n                bpp = 64;\n                supported = true;\n                break;\n              case DXGI_FORMAT_R32G32B32A32_FLOAT:\n                computeFormats = true;\n                bpp = 128;\n                supported = true;\n                break;\n              case DXGI_FORMAT_B8G8R8X8_UNORM:\n                info.isRGB = true;\n                info.isFourCC = false;\n                bpp = 32;\n                supported = true;\n                break;\n            }\n            if (supported) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n        default:\n          console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\n          return;\n      }\n    }\n    const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n    const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n    const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n    const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n    if (computeFormats) {\n      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n    }\n    mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const startFace = currentFace || 0;\n    const caps = engine.getCaps();\n    for (let face = startFace; face < faces; face++) {\n      width = header[off_width];\n      height = header[off_height];\n      for (mip = 0; mip < mipmapCount; ++mip) {\n        if (lodIndex === -1 || lodIndex === mip) {\n          // In case of fixed LOD, if the lod has just been uploaded, early exit.\n          const i = lodIndex === -1 ? mip : 0;\n          if (!info.isCompressed && info.isFourCC) {\n            texture.format = 5;\n            dataLength = width * height * 4;\n            let floatArray = null;\n            if (engine._badOS || engine._badDesktopOS || !caps.textureHalfFloat && !caps.textureFloat) {\n              // Required because iOS has many issues with float and half float generation\n              if (bpp === 128) {\n                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              } else if (bpp === 64) {\n                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              }\n              texture.type = 0;\n            } else {\n              const floatAvailable = caps.textureFloat && (destTypeMustBeFilterable && caps.textureFloatLinearFiltering || !destTypeMustBeFilterable);\n              const halfFloatAvailable = caps.textureHalfFloat && (destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering || !destTypeMustBeFilterable);\n              const destType = (bpp === 128 || bpp === 64 && !halfFloatAvailable) && floatAvailable ? 1 : (bpp === 64 || bpp === 128 && !floatAvailable) && halfFloatAvailable ? 2 : 0;\n              let dataGetter;\n              let dataGetterPolynomial = null;\n              switch (bpp) {\n                case 128:\n                  {\n                    switch (destType) {\n                      case 1:\n                        dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = null;\n                        break;\n                      case 2:\n                        dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                        break;\n                      case 0:\n                        dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                        break;\n                    }\n                    break;\n                  }\n                default:\n                  {\n                    // 64 bpp\n                    switch (destType) {\n                      case 1:\n                        dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = null;\n                        break;\n                      case 2:\n                        dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        break;\n                      case 0:\n                        dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        break;\n                    }\n                    break;\n                  }\n              }\n              texture.type = destType;\n              floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n              if (sphericalPolynomialFaces && i == 0) {\n                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);\n              }\n            }\n            if (floatArray) {\n              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n            }\n          } else if (info.isRGB) {\n            texture.type = 0;\n            if (bpp === 24) {\n              texture.format = 4;\n              dataLength = width * height * 3;\n              byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            } else {\n              // 32\n              texture.format = 5;\n              dataLength = width * height * 4;\n              byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            }\n          } else if (info.isLuminance) {\n            const unpackAlignment = engine._getUnpackAlignement();\n            const unpaddedRowSize = width;\n            const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n            byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n            texture.format = 1;\n            texture.type = 0;\n            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n          } else {\n            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n            texture.type = 0;\n            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n          }\n        }\n        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n        width *= 0.5;\n        height *= 0.5;\n        width = Math.max(1.0, width);\n        height = Math.max(1.0, height);\n      }\n      if (currentFace !== undefined) {\n        // Loading a single face\n        break;\n      }\n    }\n    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n        size: header[off_width],\n        right: sphericalPolynomialFaces[0],\n        left: sphericalPolynomialFaces[1],\n        up: sphericalPolynomialFaces[2],\n        down: sphericalPolynomialFaces[3],\n        front: sphericalPolynomialFaces[4],\n        back: sphericalPolynomialFaces[5],\n        format: 5,\n        type: 1,\n        gammaSpace: false\n      });\n    } else {\n      info.sphericalPolynomial = undefined;\n    }\n  }\n}\n/**\n * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\n */\nDDSTools.StoreLODInAlphaChannel = false;\n/**\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\n * @param rootUrl defines the url where the file to load is located\n * @param scene defines the current scene\n * @param lodScale defines scale to apply to the mip map selection\n * @param lodOffset defines offset to apply to the mip map selection\n * @param onLoad defines an optional callback raised when the texture is loaded\n * @param onError defines an optional callback raised if there is an issue to load the texture\n * @param format defines the format of the data\n * @param forcedExtension defines the extension to use to pick the right loader\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\n * @returns the cube texture as an InternalTexture\n */\nThinEngine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {\n  const callback = loadData => {\n    if (!loadData) {\n      if (onLoad) {\n        onLoad(null);\n      }\n      return;\n    }\n    const texture = loadData.texture;\n    if (!createPolynomials) {\n      texture._sphericalPolynomial = new SphericalPolynomial();\n    } else if (loadData.info.sphericalPolynomial) {\n      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\n    }\n    texture._source = InternalTextureSource.CubePrefiltered;\n    if (this.getCaps().textureLOD) {\n      // Do not add extra process if texture lod is supported.\n      if (onLoad) {\n        onLoad(texture);\n      }\n      return;\n    }\n    const mipSlices = 3;\n    const gl = this._gl;\n    const width = loadData.width;\n    if (!width) {\n      return;\n    }\n    const textures = [];\n    for (let i = 0; i < mipSlices; i++) {\n      //compute LOD from even spacing in smoothness (matching shader calculation)\n      const smoothness = i / (mipSlices - 1);\n      const roughness = 1 - smoothness;\n      const minLODIndex = lodOffset; // roughness = 0\n      const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\n      const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n      const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n      const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\n      glTextureFromLod.type = texture.type;\n      glTextureFromLod.format = texture.format;\n      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\n      glTextureFromLod.height = glTextureFromLod.width;\n      glTextureFromLod.isCube = true;\n      glTextureFromLod._cachedWrapU = 0;\n      glTextureFromLod._cachedWrapV = 0;\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\n      glTextureFromLod.samplingMode = 2;\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      if (loadData.isDDS) {\n        const info = loadData.info;\n        const data = loadData.data;\n        this._unpackFlipY(info.isCompressed);\n        DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\n      } else {\n        Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\n      }\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n      // Wrap in a base texture for easy binding.\n      const lodTexture = new BaseTexture(scene);\n      lodTexture._isCube = true;\n      lodTexture._texture = glTextureFromLod;\n      glTextureFromLod.isReady = true;\n      textures.push(lodTexture);\n    }\n    texture._lodTextureHigh = textures[2];\n    texture._lodTextureMid = textures[1];\n    texture._lodTextureLow = textures[0];\n    if (onLoad) {\n      onLoad(texture);\n    }\n  };\n  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\n};","map":{"version":3,"mappings":";AAAA;AACA,SAASA,MAAM,QAAQ,yBAAuB;AAC9C,SAASC,mBAAmB,QAAQ,iCAA+B;AAEnE,SAASC,eAAe,EAAEC,qBAAqB,QAAQ,0CAAwC;AAE/F,SAASC,MAAM,QAAQ,mBAAiB;AACxC,SAASC,iCAAiC,QAAQ,0DAAwD;AAE1G,SAASC,WAAW,QAAQ,sCAAoC;AAChE,SAASC,UAAU,QAAQ,0BAAwB;AACnD,SAASC,aAAa,EAAEC,WAAW,QAAQ,mBAAiB;AAE5D,OAAO,6CAA2C;AAElD;AACA;AACA;AACA,MAAMC,SAAS,GAAG,UAAU;AAE5B;AAAM;AACF;AACA;AACA;AACA;AACAC,gBAAgB,GAAG,OAAO;AAC9B;AACA;AAEA;AACA;AACA;AAEA,MAAMC,gBAAgB,GAAG,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;EAAM;EACF;EACAC,WAAW,GAAG,GAAG;EACjBC,QAAQ,GAAG,IAAI;EACf;EACAC,cAAc,GAAG,OAAO;AAE5B,SAASC,aAAa,CAACC,KAAa;EAChC,OAAOA,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAID,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAID,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,IAAID,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACvH;AAEA,SAASC,aAAa,CAACF,KAAa;EAChC,OAAOG,MAAM,CAACC,YAAY,CAACJ,KAAK,GAAG,IAAI,EAAGA,KAAK,IAAI,CAAC,GAAI,IAAI,EAAGA,KAAK,IAAI,EAAE,GAAI,IAAI,EAAGA,KAAK,IAAI,EAAE,GAAI,IAAI,CAAC;AAC7G;AAEA,MAAMK,WAAW,GAAGN,aAAa,CAAC,MAAM,CAAC;AACzC,MAAMO,WAAW,GAAGP,aAAa,CAAC,MAAM,CAAC;AACzC,MAAMQ,WAAW,GAAGR,aAAa,CAAC,MAAM,CAAC;AACzC,MAAMS,WAAW,GAAGT,aAAa,CAAC,MAAM,CAAC;AACzC,MAAMU,2BAA2B,GAAG,GAAG;AACvC,MAAMC,2BAA2B,GAAG,GAAG;AAEvC,MAAMC,8BAA8B,GAAG,CAAC;AACxC,MAAMC,8BAA8B,GAAG,EAAE;AACzC,MAAMC,0BAA0B,GAAG,EAAE;AAErC,MAAMC,eAAe,GAAG,EAAE,CAAC,CAAC;AAE5B;AACA,MAAMC,SAAS,GAAG,CAAC;AAEnB,MAAMC,QAAQ,GAAG,CAAC;AAClB,MAAMC,SAAS,GAAG,CAAC;AACnB,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,SAAS,GAAG,CAAC;AAEnB,MAAMC,eAAe,GAAG,CAAC;AAEzB,MAAMC,WAAW,GAAG,EAAE;AACtB,MAAMC,YAAY,GAAG,EAAE;AACvB,MAAMC,UAAU,GAAG,EAAE;AACrB,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,SAAS,GAAG,EAAE;AACpB;AACA,MAAMC,SAAS,GAAG,EAAE;AACpB;AACA;AACA,MAAMC,cAAc,GAAG,EAAE;AAyDzB;;;AAGA,OAAM,MAAOC,QAAQ;EAMjB;;;;;EAKO,OAAOC,UAAU,CAACC,IAAqB;IAC1C,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAACF,IAAI,CAACG,MAAM,EAAEH,IAAI,CAACI,UAAU,EAAEtB,eAAe,CAAC;IAC5E,MAAMuB,cAAc,GAAG,IAAIH,UAAU,CAACF,IAAI,CAACG,MAAM,EAAEH,IAAI,CAACI,UAAU,EAAEtB,eAAe,GAAG,CAAC,CAAC;IAExF,IAAIwB,WAAW,GAAG,CAAC;IACnB,IAAIL,MAAM,CAAChB,SAAS,CAAC,GAAGvB,gBAAgB,EAAE;MACtC4C,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEP,MAAM,CAACb,eAAe,CAAC,CAAC;;IAGtD,MAAMqB,MAAM,GAAGR,MAAM,CAACX,YAAY,CAAC;IACnC,MAAMoB,UAAU,GAAGD,MAAM,KAAKjC,WAAW,GAAG6B,cAAc,CAACR,cAAc,CAAC,GAAG,CAAC;IAC9E,IAAIc,WAAW,GAAG;IAElB,QAAQF,MAAM;MACV,KAAKhC,2BAA2B;QAC5BkC,WAAW,GAAG;QACd;MACJ,KAAKjC,2BAA2B;QAC5BiC,WAAW,GAAG;QACd;MACJ,KAAKnC,WAAW;QACZ,IAAIkC,UAAU,KAAK9B,8BAA8B,EAAE;UAC/C+B,WAAW,GAAG;UACd;;QAEJ,IAAID,UAAU,KAAK/B,8BAA8B,EAAE;UAC/CgC,WAAW,GAAG;UACd;;IACH;IAGT,OAAO;MACHC,KAAK,EAAEX,MAAM,CAACd,SAAS,CAAC;MACxB0B,MAAM,EAAEZ,MAAM,CAACf,UAAU,CAAC;MAC1BoB,WAAW,EAAEA,WAAW;MACxBQ,QAAQ,EAAE,CAACb,MAAM,CAACZ,WAAW,CAAC,GAAGzB,WAAW,MAAMA,WAAW;MAC7DmD,KAAK,EAAE,CAACd,MAAM,CAACZ,WAAW,CAAC,GAAGxB,QAAQ,MAAMA,QAAQ;MACpDmD,WAAW,EAAE,CAACf,MAAM,CAACZ,WAAW,CAAC,GAAGvB,cAAc,MAAMA,cAAc;MACtEmD,MAAM,EAAE,CAAChB,MAAM,CAACL,SAAS,CAAC,GAAGjC,gBAAgB,MAAMA,gBAAgB;MACnEuD,YAAY,EAAET,MAAM,KAAKpC,WAAW,IAAIoC,MAAM,KAAKnC,WAAW,IAAImC,MAAM,KAAKlC,WAAW;MACxFmC,UAAU,EAAEA,UAAU;MACtBC,WAAW,EAAEA;KAChB;EACL;EAEQ,OAAOQ,mCAAmC,CAACP,KAAa,EAAEC,MAAc,EAAEO,UAAkB,EAAEC,UAAkB,EAAEC,WAAwB,EAAEC,GAAW;IAC3J,MAAMC,SAAS,GAAG,IAAIC,YAAY,CAACJ,UAAU,CAAC;IAC9C,MAAMK,OAAO,GAAG,IAAIC,WAAW,CAACL,WAAW,EAAEF,UAAU,CAAC;IACxD,IAAIQ,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;QAC5B,MAAMC,MAAM,GAAG,CAACD,CAAC,GAAGD,CAAC,GAAGjB,KAAK,IAAI,CAAC;QAClCY,SAAS,CAACI,KAAK,CAAC,GAAGrE,aAAa,CAACmE,OAAO,CAACK,MAAM,CAAC,CAAC;QACjDP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGrE,aAAa,CAACmE,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC;QACzDP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGrE,aAAa,CAACmE,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC;QACzD,IAAIjC,QAAQ,CAACkC,sBAAsB,EAAE;UACjCR,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGL,GAAG;SAC7B,MAAM;UACHC,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGrE,aAAa,CAACmE,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC;;QAE7DH,KAAK,IAAI,CAAC;;;IAIlB,OAAOJ,SAAS;EACpB;EAEQ,OAAOS,4BAA4B,CAACrB,KAAa,EAAEC,MAAc,EAAEO,UAAkB,EAAEC,UAAkB,EAAEC,WAAwB,EAAEC,GAAW;IACpJ,IAAIzB,QAAQ,CAACkC,sBAAsB,EAAE;MACjC,MAAMR,SAAS,GAAG,IAAIG,WAAW,CAACN,UAAU,CAAC;MAC7C,MAAMK,OAAO,GAAG,IAAIC,WAAW,CAACL,WAAW,EAAEF,UAAU,CAAC;MACxD,IAAIQ,KAAK,GAAG,CAAC;MACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;QAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;UAC5B,MAAMC,MAAM,GAAG,CAACD,CAAC,GAAGD,CAAC,GAAGjB,KAAK,IAAI,CAAC;UAClCY,SAAS,CAACI,KAAK,CAAC,GAAGF,OAAO,CAACK,MAAM,CAAC;UAClCP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC;UAC1CP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC;UAC1CP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGpE,WAAW,CAAC+D,GAAG,CAAC;UACvCK,KAAK,IAAI,CAAC;;;MAIlB,OAAOJ,SAAS;;IAGpB,OAAO,IAAIG,WAAW,CAACL,WAAW,EAAEF,UAAU,EAAEC,UAAU,CAAC;EAC/D;EAEQ,OAAOa,wBAAwB,CAACtB,KAAa,EAAEC,MAAc,EAAEO,UAAkB,EAAEC,UAAkB,EAAEC,WAAwB,EAAEC,GAAW;IAChJ,IAAIzB,QAAQ,CAACkC,sBAAsB,EAAE;MACjC,MAAMR,SAAS,GAAG,IAAIC,YAAY,CAACJ,UAAU,CAAC;MAC9C,MAAMK,OAAO,GAAG,IAAID,YAAY,CAACH,WAAW,EAAEF,UAAU,CAAC;MACzD,IAAIQ,KAAK,GAAG,CAAC;MACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;QAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;UAC5B,MAAMC,MAAM,GAAG,CAACD,CAAC,GAAGD,CAAC,GAAGjB,KAAK,IAAI,CAAC;UAClCY,SAAS,CAACI,KAAK,CAAC,GAAGF,OAAO,CAACK,MAAM,CAAC;UAClCP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC;UAC1CP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC;UAC1CP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGL,GAAG;UAC1BK,KAAK,IAAI,CAAC;;;MAIlB,OAAOJ,SAAS;;IAEpB,OAAO,IAAIC,YAAY,CAACH,WAAW,EAAEF,UAAU,EAAEC,UAAU,CAAC;EAChE;EAEQ,OAAOc,mCAAmC,CAACvB,KAAa,EAAEC,MAAc,EAAEO,UAAkB,EAAEC,UAAkB,EAAEC,WAAwB,EAAEC,GAAW;IAC3J,MAAMC,SAAS,GAAG,IAAIG,WAAW,CAACN,UAAU,CAAC;IAC7C,MAAMK,OAAO,GAAG,IAAID,YAAY,CAACH,WAAW,EAAEF,UAAU,CAAC;IACzD,IAAIQ,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;QAC5BN,SAAS,CAACI,KAAK,CAAC,GAAGpE,WAAW,CAACkE,OAAO,CAACE,KAAK,CAAC,CAAC;QAC9CJ,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGpE,WAAW,CAACkE,OAAO,CAACE,KAAK,GAAG,CAAC,CAAC,CAAC;QACtDJ,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGpE,WAAW,CAACkE,OAAO,CAACE,KAAK,GAAG,CAAC,CAAC,CAAC;QACtD,IAAI9B,QAAQ,CAACkC,sBAAsB,EAAE;UACjCR,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGpE,WAAW,CAAC+D,GAAG,CAAC;SAC1C,MAAM;UACHC,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGpE,WAAW,CAACkE,OAAO,CAACE,KAAK,GAAG,CAAC,CAAC,CAAC;;QAE1DA,KAAK,IAAI,CAAC;;;IAIlB,OAAOJ,SAAS;EACpB;EAEQ,OAAOY,8BAA8B,CAACxB,KAAa,EAAEC,MAAc,EAAEO,UAAkB,EAAEC,UAAkB,EAAEC,WAAwB,EAAEC,GAAW;IACtJ,MAAMC,SAAS,GAAG,IAAIa,UAAU,CAAChB,UAAU,CAAC;IAC5C,MAAMK,OAAO,GAAG,IAAID,YAAY,CAACH,WAAW,EAAEF,UAAU,CAAC;IACzD,IAAIQ,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;QAC5B,MAAMC,MAAM,GAAG,CAACD,CAAC,GAAGD,CAAC,GAAGjB,KAAK,IAAI,CAAC;QAClCY,SAAS,CAACI,KAAK,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAACZ,OAAO,CAACK,MAAM,CAAC,CAAC,GAAG,GAAG;QACtDP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAACZ,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG;QAC9DP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAACZ,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG;QAC9D,IAAIjC,QAAQ,CAACkC,sBAAsB,EAAE;UACjCR,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGL,GAAG;SAC7B,MAAM;UACHC,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAACZ,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG;;QAElEH,KAAK,IAAI,CAAC;;;IAIlB,OAAOJ,SAAS;EACpB;EAEQ,OAAOe,kCAAkC,CAAC3B,KAAa,EAAEC,MAAc,EAAEO,UAAkB,EAAEC,UAAkB,EAAEC,WAAwB,EAAEC,GAAW;IAC1J,MAAMC,SAAS,GAAG,IAAIa,UAAU,CAAChB,UAAU,CAAC;IAC5C,MAAMK,OAAO,GAAG,IAAIC,WAAW,CAACL,WAAW,EAAEF,UAAU,CAAC;IACxD,IAAIQ,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;QAC5B,MAAMC,MAAM,GAAG,CAACD,CAAC,GAAGD,CAAC,GAAGjB,KAAK,IAAI,CAAC;QAClCY,SAAS,CAACI,KAAK,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAAC/E,aAAa,CAACmE,OAAO,CAACK,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG;QACrEP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAAC/E,aAAa,CAACmE,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG;QAC7EP,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAAC/E,aAAa,CAACmE,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG;QAC7E,IAAIjC,QAAQ,CAACkC,sBAAsB,EAAE;UACjCR,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAGL,GAAG;SAC7B,MAAM;UACHC,SAAS,CAACI,KAAK,GAAG,CAAC,CAAC,GAAG7E,MAAM,CAACuF,KAAK,CAAC/E,aAAa,CAACmE,OAAO,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG;;QAEjFH,KAAK,IAAI,CAAC;;;IAIlB,OAAOJ,SAAS;EACpB;EAEQ,OAAOgB,mBAAmB,CAC9B5B,KAAa,EACbC,MAAc,EACdO,UAAkB,EAClBC,UAAkB,EAClBC,WAAwB,EACxBmB,OAAe,EACfC,OAAe,EACfC,OAAe,EACfC,OAAe;IAEf,MAAMC,SAAS,GAAG,IAAIR,UAAU,CAAChB,UAAU,CAAC;IAC5C,MAAMK,OAAO,GAAG,IAAIW,UAAU,CAACf,WAAW,EAAEF,UAAU,CAAC;IACvD,IAAIQ,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;QAC5B,MAAMC,MAAM,GAAG,CAACD,CAAC,GAAGD,CAAC,GAAGjB,KAAK,IAAI,CAAC;QAElCiC,SAAS,CAACjB,KAAK,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAGU,OAAO,CAAC;QAC5CI,SAAS,CAACjB,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAGW,OAAO,CAAC;QAChDG,SAAS,CAACjB,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAGY,OAAO,CAAC;QAChDE,SAAS,CAACjB,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAGa,OAAO,CAAC;QAChDhB,KAAK,IAAI,CAAC;;;IAIlB,OAAOiB,SAAS;EACpB;EAEQ,OAAOC,qBAAqB,CAAC9E,KAAa;IAC9C,IAAIA,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,CAAC,QAAQ,EAAE;MACrD,OAAO,CAAC;;IAGZ,OAAO,CAAC,GAAG8B,QAAQ,CAACgD,qBAAqB,CAAC9E,KAAK,IAAI,CAAC,CAAC;EACzD;EAEQ,OAAO+E,kBAAkB,CAC7BnC,KAAa,EACbC,MAAc,EACdO,UAAkB,EAClBC,UAAkB,EAClBC,WAAwB,EACxBmB,OAAe,EACfC,OAAe,EACfC,OAAe;IAEf,MAAME,SAAS,GAAG,IAAIR,UAAU,CAAChB,UAAU,CAAC;IAC5C,MAAMK,OAAO,GAAG,IAAIW,UAAU,CAACf,WAAW,EAAEF,UAAU,CAAC;IACvD,IAAIQ,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;QAC5B,MAAMC,MAAM,GAAG,CAACD,CAAC,GAAGD,CAAC,GAAGjB,KAAK,IAAI,CAAC;QAElCiC,SAAS,CAACjB,KAAK,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAGU,OAAO,CAAC;QAC5CI,SAAS,CAACjB,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAGW,OAAO,CAAC;QAChDG,SAAS,CAACjB,KAAK,GAAG,CAAC,CAAC,GAAGF,OAAO,CAACK,MAAM,GAAGY,OAAO,CAAC;QAChDf,KAAK,IAAI,CAAC;;;IAIlB,OAAOiB,SAAS;EACpB;EAEQ,OAAOG,wBAAwB,CAACpC,KAAa,EAAEC,MAAc,EAAEO,UAAkB,EAAEC,UAAkB,EAAEC,WAAwB;IACnI,MAAMuB,SAAS,GAAG,IAAIR,UAAU,CAAChB,UAAU,CAAC;IAC5C,MAAMK,OAAO,GAAG,IAAIW,UAAU,CAACf,WAAW,EAAEF,UAAU,CAAC;IACvD,IAAIQ,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,EAAEkB,CAAC,EAAE,EAAE;QAC5B,MAAMC,MAAM,GAAGD,CAAC,GAAGD,CAAC,GAAGjB,KAAK;QAC5BiC,SAAS,CAACjB,KAAK,CAAC,GAAGF,OAAO,CAACK,MAAM,CAAC;QAClCH,KAAK,EAAE;;;IAIf,OAAOiB,SAAS;EACpB;EAEA;;;;EAIO,OAAOI,eAAe,CACzBC,MAAkB,EAClBC,OAAwB,EACxBnD,IAAqB,EACrBoD,IAAa,EACbC,WAAoB,EACpBC,KAAa,EACbC,QAAQ,GAAG,CAAC,CAAC,EACbC,WAAoB,EACpBC,wBAAwB,GAAG,IAAI;IAE/B,IAAIC,wBAAwB,GAAqC,IAAI;IACrE,IAAIN,IAAI,CAACO,mBAAmB,EAAE;MAC1BD,wBAAwB,GAAG,IAAIE,KAAK,EAAmB;;IAE3D,MAAMC,GAAG,GAAG,CAAC,CAACX,MAAM,CAACY,OAAO,EAAE,CAACC,IAAI;IAEnC;IACAZ,OAAO,CAACa,eAAe,GAAGX,WAAW;IAErC,MAAMpD,MAAM,GAAG,IAAIC,UAAU,CAACF,IAAI,CAACG,MAAM,EAAEH,IAAI,CAACI,UAAU,EAAEtB,eAAe,CAAC;IAC5E,IAAI2B,MAAc;MACdG,KAAa;MACbC,MAAc;MACdQ,UAAU,GAAW,CAAC;MACtBD,UAAkB;IACtB,IAAIyB,SAAqB,EAAEvC,WAAmB,EAAE2D,GAAW;IAC3D,IAAIC,wBAAwB,GAAG,CAAC;IAChC,IAAIC,UAAU,GAAG,CAAC;IAElB,IAAIlE,MAAM,CAAClB,SAAS,CAAC,KAAKtB,SAAS,EAAE;MACjCN,MAAM,CAACiH,KAAK,CAAC,oCAAoC,CAAC;MAClD;;IAGJ,IAAI,CAAChB,IAAI,CAACtC,QAAQ,IAAI,CAACsC,IAAI,CAACrC,KAAK,IAAI,CAACqC,IAAI,CAACpC,WAAW,EAAE;MACpD7D,MAAM,CAACiH,KAAK,CAAC,kEAAkE,CAAC;MAChF;;IAGJ,IAAIhB,IAAI,CAAClC,YAAY,IAAI,CAAC2C,GAAG,EAAE;MAC3B1G,MAAM,CAACiH,KAAK,CAAC,yDAAyD,CAAC;MACvE;;IAGJ,IAAIC,GAAG,GAAGpE,MAAM,CAACV,UAAU,CAAC;IAC5B6B,UAAU,GAAGnB,MAAM,CAACjB,QAAQ,CAAC,GAAG,CAAC;IAEjC,IAAIsF,cAAc,GAAG,KAAK;IAE1B,IAAIlB,IAAI,CAACtC,QAAQ,EAAE;MACfL,MAAM,GAAGR,MAAM,CAACX,YAAY,CAAC;MAC7B,QAAQmB,MAAM;QACV,KAAKpC,WAAW;UACZ8F,UAAU,GAAG,CAAC;UACdD,wBAAwB,GAAG;UAC3B;QACJ,KAAK5F,WAAW;UACZ6F,UAAU,GAAG,EAAE;UACfD,wBAAwB,GAAG;UAC3B;QACJ,KAAK3F,WAAW;UACZ4F,UAAU,GAAG,EAAE;UACfD,wBAAwB,GAAG;UAC3B;QACJ,KAAKzF,2BAA2B;UAC5B6F,cAAc,GAAG,IAAI;UACrBD,GAAG,GAAG,EAAE;UACR;QACJ,KAAK3F,2BAA2B;UAC5B4F,cAAc,GAAG,IAAI;UACrBD,GAAG,GAAG,GAAG;UACT;QACJ,KAAK7F,WAAW;UAAE;YACd;YACA4C,UAAU,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YAErB,IAAImD,SAAS,GAAG,KAAK;YACrB,QAAQnB,IAAI,CAAC1C,UAAU;cACnB,KAAK9B,8BAA8B;gBAC/B0F,cAAc,GAAG,IAAI;gBACrBD,GAAG,GAAG,EAAE;gBACRE,SAAS,GAAG,IAAI;gBAChB;cACJ,KAAK5F,8BAA8B;gBAC/B2F,cAAc,GAAG,IAAI;gBACrBD,GAAG,GAAG,GAAG;gBACTE,SAAS,GAAG,IAAI;gBAChB;cACJ,KAAK1F,0BAA0B;gBAC3BuE,IAAI,CAACrC,KAAK,GAAG,IAAI;gBACjBqC,IAAI,CAACtC,QAAQ,GAAG,KAAK;gBACrBuD,GAAG,GAAG,EAAE;gBACRE,SAAS,GAAG,IAAI;gBAChB;YAAM;YAGd,IAAIA,SAAS,EAAE;cACX;;;QAGR;QACA;UACIC,OAAO,CAACC,KAAK,CAAC,0BAA0B,EAAEvG,aAAa,CAACuC,MAAM,CAAC,CAAC;UAChE;MAAO;;IAInB,MAAMgC,OAAO,GAAG3C,QAAQ,CAACgD,qBAAqB,CAAC7C,MAAM,CAACT,SAAS,CAAC,CAAC;IACjE,MAAMkD,OAAO,GAAG5C,QAAQ,CAACgD,qBAAqB,CAAC7C,MAAM,CAACR,SAAS,CAAC,CAAC;IACjE,MAAMkD,OAAO,GAAG7C,QAAQ,CAACgD,qBAAqB,CAAC7C,MAAM,CAACP,SAAS,CAAC,CAAC;IACjE,MAAMkD,OAAO,GAAG9C,QAAQ,CAACgD,qBAAqB,CAAC7C,MAAM,CAACN,SAAS,CAAC,CAAC;IAEjE,IAAI2E,cAAc,EAAE;MAChBJ,wBAAwB,GAAGhB,MAAM,CAACwB,iCAAiC,CAACtB,IAAI,CAACzC,WAAW,CAAC;;IAGzFL,WAAW,GAAG,CAAC;IACf,IAAIL,MAAM,CAAChB,SAAS,CAAC,GAAGvB,gBAAgB,IAAI2F,WAAW,KAAK,KAAK,EAAE;MAC/D/C,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEP,MAAM,CAACb,eAAe,CAAC,CAAC;;IAGtD,MAAMuF,SAAS,GAAGnB,WAAW,IAAI,CAAC;IAClC,MAAMoB,IAAI,GAAG1B,MAAM,CAACY,OAAO,EAAE;IAC7B,KAAK,IAAIe,IAAI,GAAGF,SAAS,EAAEE,IAAI,GAAGvB,KAAK,EAAEuB,IAAI,EAAE,EAAE;MAC7CjE,KAAK,GAAGX,MAAM,CAACd,SAAS,CAAC;MACzB0B,MAAM,GAAGZ,MAAM,CAACf,UAAU,CAAC;MAE3B,KAAK+E,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG3D,WAAW,EAAE,EAAE2D,GAAG,EAAE;QACpC,IAAIV,QAAQ,KAAK,CAAC,CAAC,IAAIA,QAAQ,KAAKU,GAAG,EAAE;UACrC;UACA,MAAMa,CAAC,GAAGvB,QAAQ,KAAK,CAAC,CAAC,GAAGU,GAAG,GAAG,CAAC;UAEnC,IAAI,CAACb,IAAI,CAAClC,YAAY,IAAIkC,IAAI,CAACtC,QAAQ,EAAE;YACrCqC,OAAO,CAAC4B,MAAM,GAAG;YACjB1D,UAAU,GAAGT,KAAK,GAAGC,MAAM,GAAG,CAAC;YAC/B,IAAImE,UAAU,GAA8B,IAAI;YAEhD,IAAI9B,MAAM,CAAC+B,MAAM,IAAI/B,MAAM,CAACgC,aAAa,IAAK,CAACN,IAAI,CAACO,gBAAgB,IAAI,CAACP,IAAI,CAACQ,YAAa,EAAE;cACzF;cACA,IAAIf,GAAG,KAAK,GAAG,EAAE;gBACbW,UAAU,GAAGlF,QAAQ,CAACsC,8BAA8B,CAACxB,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAE2E,CAAC,CAAC;gBAC7H,IAAIpB,wBAAwB,IAAIoB,CAAC,IAAI,CAAC,EAAE;kBACpCpB,wBAAwB,CAAC2B,IAAI,CAACvF,QAAQ,CAACoC,wBAAwB,CAACtB,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAE2E,CAAC,CAAC,CAAC;;eAEhJ,MAAM,IAAIT,GAAG,KAAK,EAAE,EAAE;gBACnBW,UAAU,GAAGlF,QAAQ,CAACyC,kCAAkC,CAAC3B,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAE2E,CAAC,CAAC;gBACjI,IAAIpB,wBAAwB,IAAIoB,CAAC,IAAI,CAAC,EAAE;kBACpCpB,wBAAwB,CAAC2B,IAAI,CACzBvF,QAAQ,CAACqB,mCAAmC,CAACP,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAE2E,CAAC,CAAC,CACxH;;;cAIT3B,OAAO,CAACmC,IAAI,GAAG;aAClB,MAAM;cACH,MAAMC,cAAc,GAAGX,IAAI,CAACQ,YAAY,KAAM3B,wBAAwB,IAAImB,IAAI,CAACY,2BAA2B,IAAK,CAAC/B,wBAAwB,CAAC;cACzI,MAAMgC,kBAAkB,GAAGb,IAAI,CAACO,gBAAgB,KAAM1B,wBAAwB,IAAImB,IAAI,CAACc,+BAA+B,IAAK,CAACjC,wBAAwB,CAAC;cAErJ,MAAMkC,QAAQ,GACV,CAACtB,GAAG,KAAK,GAAG,IAAKA,GAAG,KAAK,EAAE,IAAI,CAACoB,kBAAmB,KAAKF,cAAc,GAChE,IACA,CAAClB,GAAG,KAAK,EAAE,IAAKA,GAAG,KAAK,GAAG,IAAI,CAACkB,cAAe,KAAKE,kBAAkB,GACtE,IACA;cAEV,IAAIG,UAA6I;cACjJ,IAAIC,oBAAoB,GAEpB,IAAI;cAER,QAAQxB,GAAG;gBACP,KAAK,GAAG;kBAAE;oBACN,QAAQsB,QAAQ;sBACZ,KAAK;wBACDC,UAAU,GAAG9F,QAAQ,CAACoC,wBAAwB;wBAC9C2D,oBAAoB,GAAG,IAAI;wBAC3B;sBACJ,KAAK;wBACDD,UAAU,GAAG9F,QAAQ,CAACqC,mCAAmC;wBACzD0D,oBAAoB,GAAG/F,QAAQ,CAACoC,wBAAwB;wBACxD;sBACJ,KAAK;wBACD0D,UAAU,GAAG9F,QAAQ,CAACsC,8BAA8B;wBACpDyD,oBAAoB,GAAG/F,QAAQ,CAACoC,wBAAwB;wBACxD;oBAAM;oBAEd;;gBAEJ;kBAAS;oBACL;oBACA,QAAQyD,QAAQ;sBACZ,KAAK;wBACDC,UAAU,GAAG9F,QAAQ,CAACqB,mCAAmC;wBACzD0E,oBAAoB,GAAG,IAAI;wBAC3B;sBACJ,KAAK;wBACDD,UAAU,GAAG9F,QAAQ,CAACmC,4BAA4B;wBAClD4D,oBAAoB,GAAG/F,QAAQ,CAACqB,mCAAmC;wBACnE;sBACJ,KAAK;wBACDyE,UAAU,GAAG9F,QAAQ,CAACyC,kCAAkC;wBACxDsD,oBAAoB,GAAG/F,QAAQ,CAACqB,mCAAmC;wBACnE;oBAAM;oBAEd;;cACH;cAGLgC,OAAO,CAACmC,IAAI,GAAGK,QAAQ;cAEvBX,UAAU,GAAGY,UAAU,CAAChF,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAE2E,CAAC,CAAC;cAEhG,IAAIpB,wBAAwB,IAAIoB,CAAC,IAAI,CAAC,EAAE;gBACpCpB,wBAAwB,CAAC2B,IAAI,CACzBQ,oBAAoB,GAAGA,oBAAoB,CAACjF,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAE2E,CAAC,CAAC,GAAGE,UAAU,CACpI;;;YAIT,IAAIA,UAAU,EAAE;cACZ9B,MAAM,CAAC4C,4BAA4B,CAAC3C,OAAO,EAAE6B,UAAU,EAAEH,IAAI,EAAEC,CAAC,CAAC;;WAExE,MAAM,IAAI1B,IAAI,CAACrC,KAAK,EAAE;YACnBoC,OAAO,CAACmC,IAAI,GAAG;YACf,IAAIjB,GAAG,KAAK,EAAE,EAAE;cACZlB,OAAO,CAAC4B,MAAM,GAAG;cACjB1D,UAAU,GAAGT,KAAK,GAAGC,MAAM,GAAG,CAAC;cAC/BgC,SAAS,GAAG/C,QAAQ,CAACiD,kBAAkB,CAACnC,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAEsC,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC;cACxIO,MAAM,CAAC4C,4BAA4B,CAAC3C,OAAO,EAAEN,SAAS,EAAEgC,IAAI,EAAEC,CAAC,CAAC;aACnE,MAAM;cACH;cACA3B,OAAO,CAAC4B,MAAM,GAAG;cACjB1D,UAAU,GAAGT,KAAK,GAAGC,MAAM,GAAG,CAAC;cAC/BgC,SAAS,GAAG/C,QAAQ,CAAC0C,mBAAmB,CAAC5B,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,EAAEsC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC;cAClJM,MAAM,CAAC4C,4BAA4B,CAAC3C,OAAO,EAAEN,SAAS,EAAEgC,IAAI,EAAEC,CAAC,CAAC;;WAEvE,MAAM,IAAI1B,IAAI,CAACpC,WAAW,EAAE;YACzB,MAAM+E,eAAe,GAAG7C,MAAM,CAAC8C,oBAAoB,EAAE;YACrD,MAAMC,eAAe,GAAGrF,KAAK;YAC7B,MAAMsF,aAAa,GAAG3F,IAAI,CAAC4F,KAAK,CAAC,CAACvF,KAAK,GAAGmF,eAAe,GAAG,CAAC,IAAIA,eAAe,CAAC,GAAGA,eAAe;YACnG1E,UAAU,GAAG6E,aAAa,IAAIrF,MAAM,GAAG,CAAC,CAAC,GAAGoF,eAAe;YAE3DpD,SAAS,GAAG/C,QAAQ,CAACkD,wBAAwB,CAACpC,KAAK,EAAEC,MAAM,EAAEb,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,EAAErB,IAAI,CAACG,MAAM,CAAC;YACnHgD,OAAO,CAAC4B,MAAM,GAAG;YACjB5B,OAAO,CAACmC,IAAI,GAAG;YAEfpC,MAAM,CAAC4C,4BAA4B,CAAC3C,OAAO,EAAEN,SAAS,EAAEgC,IAAI,EAAEC,CAAC,CAAC;WACnE,MAAM;YACHzD,UAAU,GAAMd,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEI,KAAK,CAAC,GAAG,CAAC,GAAIL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEK,MAAM,CAAC,GAAI,CAAC,GAAIsD,UAAU;YAChFtB,SAAS,GAAG,IAAIR,UAAU,CAACrC,IAAI,CAACG,MAAM,EAAEH,IAAI,CAACI,UAAU,GAAGgB,UAAU,EAAEC,UAAU,CAAC;YAEjF8B,OAAO,CAACmC,IAAI,GAAG;YACfpC,MAAM,CAACkD,sCAAsC,CAACjD,OAAO,EAAEe,wBAAwB,EAAEtD,KAAK,EAAEC,MAAM,EAAEgC,SAAS,EAAEgC,IAAI,EAAEC,CAAC,CAAC;;;QAG3H1D,UAAU,IAAIiD,GAAG,GAAGzD,KAAK,GAAGC,MAAM,IAAIwD,GAAG,GAAG,CAAC,CAAC,GAAGhD,UAAU;QAC3DT,KAAK,IAAI,GAAG;QACZC,MAAM,IAAI,GAAG;QAEbD,KAAK,GAAGL,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEI,KAAK,CAAC;QAC5BC,MAAM,GAAGN,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEK,MAAM,CAAC;;MAGlC,IAAI2C,WAAW,KAAK6C,SAAS,EAAE;QAC3B;QACA;;;IAGR,IAAI3C,wBAAwB,IAAIA,wBAAwB,CAAC4C,MAAM,GAAG,CAAC,EAAE;MACjElD,IAAI,CAACO,mBAAmB,GAAGvG,iCAAiC,CAACmJ,mCAAmC,CAAC;QAC7FC,IAAI,EAAEvG,MAAM,CAACd,SAAS,CAAC;QACvBsH,KAAK,EAAE/C,wBAAwB,CAAC,CAAC,CAAC;QAClCgD,IAAI,EAAEhD,wBAAwB,CAAC,CAAC,CAAC;QACjCiD,EAAE,EAAEjD,wBAAwB,CAAC,CAAC,CAAC;QAC/BkD,IAAI,EAAElD,wBAAwB,CAAC,CAAC,CAAC;QACjCmD,KAAK,EAAEnD,wBAAwB,CAAC,CAAC,CAAC;QAClCoD,IAAI,EAAEpD,wBAAwB,CAAC,CAAC,CAAC;QACjCqB,MAAM,EAAE;QACRO,IAAI,EAAE;QACNyB,UAAU,EAAE;OACf,CAAC;KACL,MAAM;MACH3D,IAAI,CAACO,mBAAmB,GAAG0C,SAAS;;EAE5C;;AAziBA;;;AAGcvG,+BAAsB,GAAG,KAAK;AAskBhD;;;;;;;;;;;;;AAaAxC,UAAU,CAAC0J,SAAS,CAACC,4BAA4B,GAAG,UAChDC,OAAe,EACfC,KAAsB,EACtBC,QAAgB,EAChBC,SAAiB,EACjBC,SAAyE,IAAI,EAC7EC,UAAiE,IAAI,EACrExC,MAAe,EACfyC,kBAAuB,IAAI,EAC3BC,oBAA6B,IAAI;EAEjC,MAAMC,QAAQ,GAAIC,QAAa,IAAI;IAC/B,IAAI,CAACA,QAAQ,EAAE;MACX,IAAIL,MAAM,EAAE;QACRA,MAAM,CAAC,IAAI,CAAC;;MAEhB;;IAGJ,MAAMnE,OAAO,GAAGwE,QAAQ,CAACxE,OAA0B;IACnD,IAAI,CAACsE,iBAAiB,EAAE;MACpBtE,OAAO,CAACyE,oBAAoB,GAAG,IAAI5K,mBAAmB,EAAE;KAC3D,MAAM,IAAI2K,QAAQ,CAACvE,IAAI,CAACO,mBAAmB,EAAE;MAC1CR,OAAO,CAACyE,oBAAoB,GAAGD,QAAQ,CAACvE,IAAI,CAACO,mBAAmB;;IAEpER,OAAO,CAAC0E,OAAO,GAAG3K,qBAAqB,CAAC4K,eAAe;IAEvD,IAAI,IAAI,CAAChE,OAAO,EAAE,CAACiE,UAAU,EAAE;MAC3B;MACA,IAAIT,MAAM,EAAE;QACRA,MAAM,CAACnE,OAAO,CAAC;;MAEnB;;IAGJ,MAAM6E,SAAS,GAAG,CAAC;IAEnB,MAAMC,EAAE,GAAG,IAAI,CAACC,GAAG;IACnB,MAAMtH,KAAK,GAAG+G,QAAQ,CAAC/G,KAAK;IAC5B,IAAI,CAACA,KAAK,EAAE;MACR;;IAGJ,MAAMuH,QAAQ,GAAkB,EAAE;IAClC,KAAK,IAAIrD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkD,SAAS,EAAElD,CAAC,EAAE,EAAE;MAChC;MACA,MAAMsD,UAAU,GAAGtD,CAAC,IAAIkD,SAAS,GAAG,CAAC,CAAC;MACtC,MAAMK,SAAS,GAAG,CAAC,GAAGD,UAAU;MAEhC,MAAME,WAAW,GAAGjB,SAAS,CAAC,CAAC;MAC/B,MAAMkB,WAAW,GAAGxL,MAAM,CAACyL,IAAI,CAAC5H,KAAK,CAAC,GAAGwG,QAAQ,GAAGC,SAAS,CAAC,CAAC;MAE/D,MAAM9D,QAAQ,GAAG+E,WAAW,GAAG,CAACC,WAAW,GAAGD,WAAW,IAAID,SAAS;MACtE,MAAMI,WAAW,GAAGlI,IAAI,CAACmI,KAAK,CAACnI,IAAI,CAACoI,GAAG,CAACpI,IAAI,CAACC,GAAG,CAAC+C,QAAQ,EAAE,CAAC,CAAC,EAAEgF,WAAW,CAAC,CAAC;MAE5E,MAAMK,gBAAgB,GAAG,IAAI3L,eAAe,CAAC,IAAI,EAAEC,qBAAqB,CAAC2L,IAAI,CAAC;MAC9ED,gBAAgB,CAACtD,IAAI,GAAGnC,OAAO,CAACmC,IAAI;MACpCsD,gBAAgB,CAAC7D,MAAM,GAAG5B,OAAO,CAAC4B,MAAM;MACxC6D,gBAAgB,CAAChI,KAAK,GAAGL,IAAI,CAACuI,GAAG,CAAC,CAAC,EAAEvI,IAAI,CAACC,GAAG,CAACzD,MAAM,CAACyL,IAAI,CAAC5H,KAAK,CAAC,GAAG6H,WAAW,EAAE,CAAC,CAAC,CAAC;MACnFG,gBAAgB,CAAC/H,MAAM,GAAG+H,gBAAgB,CAAChI,KAAK;MAChDgI,gBAAgB,CAAC3H,MAAM,GAAG,IAAI;MAC9B2H,gBAAgB,CAACG,YAAY,GAAG;MAChCH,gBAAgB,CAACI,YAAY,GAAG;MAChC,IAAI,CAACC,oBAAoB,CAAChB,EAAE,CAACiB,gBAAgB,EAAEN,gBAAgB,EAAE,IAAI,CAAC;MAEtEA,gBAAgB,CAACO,YAAY,GAAG;MAChClB,EAAE,CAACmB,aAAa,CAACnB,EAAE,CAACiB,gBAAgB,EAAEjB,EAAE,CAACoB,kBAAkB,EAAEpB,EAAE,CAACqB,MAAM,CAAC;MACvErB,EAAE,CAACmB,aAAa,CAACnB,EAAE,CAACiB,gBAAgB,EAAEjB,EAAE,CAACsB,kBAAkB,EAAEtB,EAAE,CAACqB,MAAM,CAAC;MACvErB,EAAE,CAACmB,aAAa,CAACnB,EAAE,CAACiB,gBAAgB,EAAEjB,EAAE,CAACuB,cAAc,EAAEvB,EAAE,CAACwB,aAAa,CAAC;MAC1ExB,EAAE,CAACmB,aAAa,CAACnB,EAAE,CAACiB,gBAAgB,EAAEjB,EAAE,CAACyB,cAAc,EAAEzB,EAAE,CAACwB,aAAa,CAAC;MAE1E,IAAI9B,QAAQ,CAACgC,KAAK,EAAE;QAChB,MAAMvG,IAAI,GAAYuE,QAAQ,CAACvE,IAAI;QACnC,MAAMpD,IAAI,GAAQ2H,QAAQ,CAAC3H,IAAI;QAC/B,IAAI,CAAC4J,YAAY,CAACxG,IAAI,CAAClC,YAAY,CAAC;QAEpCpB,QAAQ,CAACmD,eAAe,CAAC,IAAI,EAAE2F,gBAAgB,EAAE5I,IAAI,EAAEoD,IAAI,EAAE,IAAI,EAAE,CAAC,EAAEqF,WAAW,CAAC;OACrF,MAAM;QACHtL,MAAM,CAAC0M,IAAI,CAAC,wDAAwD,CAAC;;MAGzE,IAAI,CAACZ,oBAAoB,CAAChB,EAAE,CAACiB,gBAAgB,EAAE,IAAI,CAAC;MAEpD;MACA,MAAMY,UAAU,GAAG,IAAIzM,WAAW,CAAC8J,KAAK,CAAC;MACzC2C,UAAU,CAACC,OAAO,GAAG,IAAI;MACzBD,UAAU,CAACE,QAAQ,GAAGpB,gBAAgB;MAEtCA,gBAAgB,CAACqB,OAAO,GAAG,IAAI;MAC/B9B,QAAQ,CAAC9C,IAAI,CAACyE,UAAU,CAAC;;IAG7B3G,OAAO,CAAC+G,eAAe,GAAG/B,QAAQ,CAAC,CAAC,CAAC;IACrChF,OAAO,CAACgH,cAAc,GAAGhC,QAAQ,CAAC,CAAC,CAAC;IACpChF,OAAO,CAACiH,cAAc,GAAGjC,QAAQ,CAAC,CAAC,CAAC;IAEpC,IAAIb,MAAM,EAAE;MACRA,MAAM,CAACnE,OAAO,CAAC;;EAEvB,CAAC;EAED,OAAO,IAAI,CAACkH,iBAAiB,CAACnD,OAAO,EAAEC,KAAK,EAAE,IAAI,EAAE,KAAK,EAAEO,QAAQ,EAAEH,OAAO,EAAExC,MAAM,EAAEyC,eAAe,EAAEC,iBAAiB,EAAEL,QAAQ,EAAEC,SAAS,CAAC;AAClJ,CAAC","names":["Scalar","SphericalPolynomial","InternalTexture","InternalTextureSource","Logger","CubeMapToSphericalPolynomialTools","BaseTexture","ThinEngine","FromHalfFloat","ToHalfFloat","DDS_MAGIC","DDSD_MIPMAPCOUNT","DDSCAPS2_CUBEMAP","DDPF_FOURCC","DDPF_RGB","DDPF_LUMINANCE","FourCCToInt32","value","charCodeAt","Int32ToFourCC","String","fromCharCode","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_DX10","FOURCC_D3DFMT_R16G16B16A16F","FOURCC_D3DFMT_R32G32B32A32F","DXGI_FORMAT_R32G32B32A32_FLOAT","DXGI_FORMAT_R16G16B16A16_FLOAT","DXGI_FORMAT_B8G8R8X8_UNORM","headerLengthInt","off_magic","off_size","off_flags","off_height","off_width","off_mipmapCount","off_pfFlags","off_pfFourCC","off_RGBbpp","off_RMask","off_GMask","off_BMask","off_AMask","off_caps2","off_dxgiFormat","DDSTools","GetDDSInfo","data","header","Int32Array","buffer","byteOffset","extendedHeader","mipmapCount","Math","max","fourCC","dxgiFormat","textureType","width","height","isFourCC","isRGB","isLuminance","isCube","isCompressed","_GetHalfFloatAsFloatRGBAArrayBuffer","dataOffset","dataLength","arrayBuffer","lod","destArray","Float32Array","srcData","Uint16Array","index","y","x","srcPos","StoreLODInAlphaChannel","_GetHalfFloatRGBAArrayBuffer","_GetFloatRGBAArrayBuffer","_GetFloatAsHalfFloatRGBAArrayBuffer","_GetFloatAsUIntRGBAArrayBuffer","Uint8Array","Clamp","_GetHalfFloatAsUIntRGBAArrayBuffer","_GetRGBAArrayBuffer","rOffset","gOffset","bOffset","aOffset","byteArray","_ExtractLongWordOrder","_GetRGBArrayBuffer","_GetLuminanceArrayBuffer","UploadDDSLevels","engine","texture","info","loadMipmaps","faces","lodIndex","currentFace","destTypeMustBeFilterable","sphericalPolynomialFaces","sphericalPolynomial","Array","ext","getCaps","s3tc","generateMipMaps","mip","internalCompressedFormat","blockBytes","Error","bpp","computeFormats","supported","console","error","_getRGBABufferInternalSizedFormat","startFace","caps","face","i","format","floatArray","_badOS","_badDesktopOS","textureHalfFloat","textureFloat","push","type","floatAvailable","textureFloatLinearFiltering","halfFloatAvailable","textureHalfFloatLinearFiltering","destType","dataGetter","dataGetterPolynomial","_uploadDataToTextureDirectly","unpackAlignment","_getUnpackAlignement","unpaddedRowSize","paddedRowSize","floor","_uploadCompressedDataToTextureDirectly","undefined","length","ConvertCubeMapToSphericalPolynomial","size","right","left","up","down","front","back","gammaSpace","prototype","createPrefilteredCubeTexture","rootUrl","scene","lodScale","lodOffset","onLoad","onError","forcedExtension","createPolynomials","callback","loadData","_sphericalPolynomial","_source","CubePrefiltered","textureLOD","mipSlices","gl","_gl","textures","smoothness","roughness","minLODIndex","maxLODIndex","Log2","mipmapIndex","round","min","glTextureFromLod","Temp","pow","_cachedWrapU","_cachedWrapV","_bindTextureDirectly","TEXTURE_CUBE_MAP","samplingMode","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","isDDS","_unpackFlipY","Warn","lodTexture","_isCube","_texture","isReady","_lodTextureHigh","_lodTextureMid","_lodTextureLow","createCubeTexture"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/dds.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { Scene } from \"../scene\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools\";\r\n\r\nimport \"../Engines/Extensions/engine.cubeTexture\";\r\n\r\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\r\n// All values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nconst DDS_MAGIC = 0x20534444;\r\n\r\nconst //DDSD_CAPS = 0x1,\r\n    //DDSD_HEIGHT = 0x2,\r\n    //DDSD_WIDTH = 0x4,\r\n    //DDSD_PITCH = 0x8,\r\n    //DDSD_PIXELFORMAT = 0x1000,\r\n    DDSD_MIPMAPCOUNT = 0x20000;\r\n//DDSD_LINEARSIZE = 0x80000,\r\n//DDSD_DEPTH = 0x800000;\r\n\r\n// var DDSCAPS_COMPLEX = 0x8,\r\n//     DDSCAPS_MIPMAP = 0x400000,\r\n//     DDSCAPS_TEXTURE = 0x1000;\r\n\r\nconst DDSCAPS2_CUBEMAP = 0x200;\r\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n// DDSCAPS2_VOLUME = 0x200000;\r\n\r\nconst //DDPF_ALPHAPIXELS = 0x1,\r\n    //DDPF_ALPHA = 0x2,\r\n    DDPF_FOURCC = 0x4,\r\n    DDPF_RGB = 0x40,\r\n    //DDPF_YUV = 0x200,\r\n    DDPF_LUMINANCE = 0x20000;\r\n\r\nfunction FourCCToInt32(value: string) {\r\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\r\n}\r\n\r\nfunction Int32ToFourCC(value: number) {\r\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\r\n}\r\n\r\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\r\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\r\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\r\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\r\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\r\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\r\n\r\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\r\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\r\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\r\n\r\nconst headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n// Offsets into the header array\r\nconst off_magic = 0;\r\n\r\nconst off_size = 1;\r\nconst off_flags = 2;\r\nconst off_height = 3;\r\nconst off_width = 4;\r\n\r\nconst off_mipmapCount = 7;\r\n\r\nconst off_pfFlags = 20;\r\nconst off_pfFourCC = 21;\r\nconst off_RGBbpp = 22;\r\nconst off_RMask = 23;\r\nconst off_GMask = 24;\r\nconst off_BMask = 25;\r\nconst off_AMask = 26;\r\n// var off_caps1 = 27;\r\nconst off_caps2 = 28;\r\n// var off_caps3 = 29;\r\n// var off_caps4 = 30;\r\nconst off_dxgiFormat = 32;\r\n\r\n/**\r\n * Direct draw surface info\r\n * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide\r\n */\r\nexport interface DDSInfo {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    height: number;\r\n    /**\r\n     * Number of Mipmaps for the texture\r\n     * @see https://en.wikipedia.org/wiki/Mipmap\r\n     */\r\n    mipmapCount: number;\r\n    /**\r\n     * If the textures format is a known fourCC format\r\n     * @see https://www.fourcc.org/\r\n     */\r\n    isFourCC: boolean;\r\n    /**\r\n     * If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format\r\n     */\r\n    isRGB: boolean;\r\n    /**\r\n     * If the texture is a lumincance format\r\n     */\r\n    isLuminance: boolean;\r\n    /**\r\n     * If this is a cube texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps\r\n     */\r\n    isCube: boolean;\r\n    /**\r\n     * If the texture is a compressed format eg. FOURCC_DXT1\r\n     */\r\n    isCompressed: boolean;\r\n    /**\r\n     * The dxgiFormat of the texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format\r\n     */\r\n    dxgiFormat: number;\r\n    /**\r\n     * Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT\r\n     */\r\n    textureType: number;\r\n    /**\r\n     * Sphericle polynomial created for the dds texture\r\n     */\r\n    sphericalPolynomial?: SphericalPolynomial;\r\n}\r\n\r\n/**\r\n * Class used to provide DDS decompression tools\r\n */\r\nexport class DDSTools {\r\n    /**\r\n     * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n     */\r\n    public static StoreLODInAlphaChannel = false;\r\n\r\n    /**\r\n     * Gets DDS information from an array buffer\r\n     * @param data defines the array buffer view to read data from\r\n     * @returns the DDS information\r\n     */\r\n    public static GetDDSInfo(data: ArrayBufferView): DDSInfo {\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\r\n\r\n        let mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const fourCC = header[off_pfFourCC];\r\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n        switch (fourCC) {\r\n            case FOURCC_D3DFMT_R16G16B16A16F:\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                break;\r\n            case FOURCC_D3DFMT_R32G32B32A32F:\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n                break;\r\n            case FOURCC_DX10:\r\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                    break;\r\n                }\r\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_FLOAT;\r\n                    break;\r\n                }\r\n        }\r\n\r\n        return {\r\n            width: header[off_width],\r\n            height: header[off_height],\r\n            mipmapCount: mipmapCount,\r\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\r\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\r\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\r\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\r\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\r\n            dxgiFormat: dxgiFormat,\r\n            textureType: textureType,\r\n        };\r\n    }\r\n\r\n    private static _GetHalfFloatAsFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        const destArray = new Float32Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\r\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\r\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Uint16Array(dataLength);\r\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n\r\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Float32Array(dataLength);\r\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = lod;\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatAsHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        const destArray = new Uint16Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                destArray[index] = ToHalfFloat(srcData[index]);\r\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\r\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                } else {\r\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetRGBAArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number,\r\n        aOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                byteArray[index + 3] = srcData[srcPos + aOffset];\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _ExtractLongWordOrder(value: number): number {\r\n        if (value === 0 || value === 255 || value === -16777216) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\r\n    }\r\n\r\n    private static _GetRGBArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 3;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                index += 3;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _GetLuminanceArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = x + y * width;\r\n                byteArray[index] = srcData[srcPos];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    /**\r\n     * Uploads DDS Levels to a Babylon Texture\r\n     * @internal\r\n     */\r\n    public static UploadDDSLevels(\r\n        engine: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: ArrayBufferView,\r\n        info: DDSInfo,\r\n        loadMipmaps: boolean,\r\n        faces: number,\r\n        lodIndex = -1,\r\n        currentFace?: number,\r\n        destTypeMustBeFilterable = true\r\n    ) {\r\n        let sphericalPolynomialFaces: Nullable<Array<ArrayBufferView>> = null;\r\n        if (info.sphericalPolynomial) {\r\n            sphericalPolynomialFaces = new Array<ArrayBufferView>();\r\n        }\r\n        const ext = !!engine.getCaps().s3tc;\r\n\r\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\r\n        texture.generateMipMaps = loadMipmaps;\r\n\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        let fourCC: number,\r\n            width: number,\r\n            height: number,\r\n            dataLength: number = 0,\r\n            dataOffset: number;\r\n        let byteArray: Uint8Array, mipmapCount: number, mip: number;\r\n        let internalCompressedFormat = 0;\r\n        let blockBytes = 1;\r\n\r\n        if (header[off_magic] !== DDS_MAGIC) {\r\n            Logger.Error(\"Invalid magic number in DDS header\");\r\n            return;\r\n        }\r\n\r\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\r\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\r\n            return;\r\n        }\r\n\r\n        if (info.isCompressed && !ext) {\r\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\r\n            return;\r\n        }\r\n\r\n        let bpp = header[off_RGBbpp];\r\n        dataOffset = header[off_size] + 4;\r\n\r\n        let computeFormats = false;\r\n\r\n        if (info.isFourCC) {\r\n            fourCC = header[off_pfFourCC];\r\n            switch (fourCC) {\r\n                case FOURCC_DXT1:\r\n                    blockBytes = 8;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1;\r\n                    break;\r\n                case FOURCC_DXT3:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n                    break;\r\n                case FOURCC_DXT5:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n                    break;\r\n                case FOURCC_D3DFMT_R16G16B16A16F:\r\n                    computeFormats = true;\r\n                    bpp = 64;\r\n                    break;\r\n                case FOURCC_D3DFMT_R32G32B32A32F:\r\n                    computeFormats = true;\r\n                    bpp = 128;\r\n                    break;\r\n                case FOURCC_DX10: {\r\n                    // There is an additionnal header so dataOffset need to be changed\r\n                    dataOffset += 5 * 4; // 5 uints\r\n\r\n                    let supported = false;\r\n                    switch (info.dxgiFormat) {\r\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 64;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 128;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\r\n                            info.isRGB = true;\r\n                            info.isFourCC = false;\r\n                            bpp = 32;\r\n                            supported = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (supported) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                default:\r\n                    console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\r\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\r\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\r\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\r\n\r\n        if (computeFormats) {\r\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\r\n        }\r\n\r\n        mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const startFace = currentFace || 0;\r\n        const caps = engine.getCaps();\r\n        for (let face = startFace; face < faces; face++) {\r\n            width = header[off_width];\r\n            height = header[off_height];\r\n\r\n            for (mip = 0; mip < mipmapCount; ++mip) {\r\n                if (lodIndex === -1 || lodIndex === mip) {\r\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\r\n                    const i = lodIndex === -1 ? mip : 0;\r\n\r\n                    if (!info.isCompressed && info.isFourCC) {\r\n                        texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                        dataLength = width * height * 4;\r\n                        let floatArray: Nullable<ArrayBufferView> = null;\r\n\r\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\r\n                            // Required because iOS has many issues with float and half float generation\r\n                            if (bpp === 128) {\r\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            } else if (bpp === 64) {\r\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(\r\n                                        DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i)\r\n                                    );\r\n                                }\r\n                            }\r\n\r\n                            texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        } else {\r\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n\r\n                            const destType =\r\n                                (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\r\n                                    ? Constants.TEXTURETYPE_FLOAT\r\n                                    : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\r\n                                    ? Constants.TEXTURETYPE_HALF_FLOAT\r\n                                    : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n                            let dataGetter: (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView;\r\n                            let dataGetterPolynomial: Nullable<\r\n                                (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView\r\n                            > = null;\r\n\r\n                            switch (bpp) {\r\n                                case 128: {\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                default: {\r\n                                    // 64 bpp\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            texture.type = destType;\r\n\r\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n\r\n                            if (sphericalPolynomialFaces && i == 0) {\r\n                                sphericalPolynomialFaces.push(\r\n                                    dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if (floatArray) {\r\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\r\n                        }\r\n                    } else if (info.isRGB) {\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        if (bpp === 24) {\r\n                            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n                            dataLength = width * height * 3;\r\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        } else {\r\n                            // 32\r\n                            texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                            dataLength = width * height * 4;\r\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        }\r\n                    } else if (info.isLuminance) {\r\n                        const unpackAlignment = engine._getUnpackAlignement();\r\n                        const unpaddedRowSize = width;\r\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\r\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\r\n\r\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\r\n                        texture.format = Constants.TEXTUREFORMAT_LUMINANCE;\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                    } else {\r\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\r\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\r\n\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\r\n                    }\r\n                }\r\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\r\n                width *= 0.5;\r\n                height *= 0.5;\r\n\r\n                width = Math.max(1.0, width);\r\n                height = Math.max(1.0, height);\r\n            }\r\n\r\n            if (currentFace !== undefined) {\r\n                // Loading a single face\r\n                break;\r\n            }\r\n        }\r\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\r\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\r\n                size: header[off_width],\r\n                right: sphericalPolynomialFaces[0],\r\n                left: sphericalPolynomialFaces[1],\r\n                up: sphericalPolynomialFaces[2],\r\n                down: sphericalPolynomialFaces[3],\r\n                front: sphericalPolynomialFaces[4],\r\n                back: sphericalPolynomialFaces[5],\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n                type: Constants.TEXTURETYPE_FLOAT,\r\n                gammaSpace: false,\r\n            });\r\n        } else {\r\n            info.sphericalPolynomial = undefined;\r\n        }\r\n    }\r\n}\r\n\r\ndeclare module \"../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n         * @param rootUrl defines the url where the file to load is located\r\n         * @param scene defines the current scene\r\n         * @param lodScale defines scale to apply to the mip map selection\r\n         * @param lodOffset defines offset to apply to the mip map selection\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createPrefilteredCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>,\r\n            onError?: Nullable<(message?: string, exception?: any) => void>,\r\n            format?: number,\r\n            forcedExtension?: any,\r\n            createPolynomials?: boolean\r\n        ): InternalTexture;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n * @param rootUrl defines the url where the file to load is located\r\n * @param scene defines the current scene\r\n * @param lodScale defines scale to apply to the mip map selection\r\n * @param lodOffset defines offset to apply to the mip map selection\r\n * @param onLoad defines an optional callback raised when the texture is loaded\r\n * @param onError defines an optional callback raised if there is an issue to load the texture\r\n * @param format defines the format of the data\r\n * @param forcedExtension defines the extension to use to pick the right loader\r\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n * @returns the cube texture as an InternalTexture\r\n */\r\nThinEngine.prototype.createPrefilteredCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    lodScale: number,\r\n    lodOffset: number,\r\n    onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = true\r\n): InternalTexture {\r\n    const callback = (loadData: any) => {\r\n        if (!loadData) {\r\n            if (onLoad) {\r\n                onLoad(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const texture = loadData.texture as InternalTexture;\r\n        if (!createPolynomials) {\r\n            texture._sphericalPolynomial = new SphericalPolynomial();\r\n        } else if (loadData.info.sphericalPolynomial) {\r\n            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n        }\r\n        texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n        if (this.getCaps().textureLOD) {\r\n            // Do not add extra process if texture lod is supported.\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const mipSlices = 3;\r\n\r\n        const gl = this._gl;\r\n        const width = loadData.width;\r\n        if (!width) {\r\n            return;\r\n        }\r\n\r\n        const textures: BaseTexture[] = [];\r\n        for (let i = 0; i < mipSlices; i++) {\r\n            //compute LOD from even spacing in smoothness (matching shader calculation)\r\n            const smoothness = i / (mipSlices - 1);\r\n            const roughness = 1 - smoothness;\r\n\r\n            const minLODIndex = lodOffset; // roughness = 0\r\n            const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\r\n\r\n            const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n            const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n            const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\r\n            glTextureFromLod.type = texture.type;\r\n            glTextureFromLod.format = texture.format;\r\n            glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\r\n            glTextureFromLod.height = glTextureFromLod.width;\r\n            glTextureFromLod.isCube = true;\r\n            glTextureFromLod._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            glTextureFromLod._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\r\n\r\n            glTextureFromLod.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n            if (loadData.isDDS) {\r\n                const info: DDSInfo = loadData.info;\r\n                const data: any = loadData.data;\r\n                this._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\r\n            } else {\r\n                Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n            // Wrap in a base texture for easy binding.\r\n            const lodTexture = new BaseTexture(scene);\r\n            lodTexture._isCube = true;\r\n            lodTexture._texture = glTextureFromLod;\r\n\r\n            glTextureFromLod.isReady = true;\r\n            textures.push(lodTexture);\r\n        }\r\n\r\n        texture._lodTextureHigh = textures[2];\r\n        texture._lodTextureMid = textures[1];\r\n        texture._lodTextureLow = textures[0];\r\n\r\n        if (onLoad) {\r\n            onLoad(texture);\r\n        }\r\n    };\r\n\r\n    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}