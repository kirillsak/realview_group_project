{"ast":null,"code":"import { Scene } from \"../../scene.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { Octree } from \"./octree.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity = 64, maxDepth = 2) {\n  let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\n  if (!component) {\n    component = new OctreeSceneComponent(this);\n    this._addComponent(component);\n  }\n  if (!this._selectionOctree) {\n    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\n  }\n  const worldExtends = this.getWorldExtends();\n  // Update octree\n  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\n  return this._selectionOctree;\n};\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\n  get: function () {\n    return this._selectionOctree;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\n * @param maxCapacity defines the maximum size of each block (64 by default)\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\n * @returns the new octree\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n */\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity = 64, maxDepth = 2) {\n  const scene = this.getScene();\n  let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\n  if (!component) {\n    component = new OctreeSceneComponent(scene);\n    scene._addComponent(component);\n  }\n  if (!this._submeshesOctree) {\n    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\n  }\n  this.computeWorldMatrix(true);\n  const boundingInfo = this.getBoundingInfo();\n  // Update octree\n  const bbox = boundingInfo.boundingBox;\n  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\n  return this._submeshesOctree;\n};\n/**\n * Defines the octree scene component responsible to manage any octrees\n * in a given scene.\n */\nexport class OctreeSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name help to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_OCTREE;\n    /**\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\n     */\n    this.checksIsEnabled = true;\n    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this.scene = scene;\n    this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\n    this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\n    this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\n    this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene.onMeshRemovedObservable.add(mesh => {\n      const sceneOctree = this.scene.selectionOctree;\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        const index = sceneOctree.dynamicContent.indexOf(mesh);\n        if (index !== -1) {\n          sceneOctree.dynamicContent.splice(index, 1);\n        }\n      }\n    });\n    this.scene.onMeshImportedObservable.add(mesh => {\n      const sceneOctree = this.scene.selectionOctree;\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        sceneOctree.addMesh(mesh);\n      }\n    });\n  }\n  /**\n   * Return the list of active meshes\n   * @returns the list of active meshes\n   */\n  getActiveMeshCandidates() {\n    var _a;\n    return ((_a = this.scene._selectionOctree) === null || _a === void 0 ? void 0 : _a.select(this.scene.frustumPlanes)) || this.scene._getDefaultMeshCandidates();\n  }\n  /**\n   * Return the list of active sub meshes\n   * @param mesh The mesh to get the candidates sub meshes from\n   * @returns the list of active sub meshes\n   */\n  getActiveSubMeshCandidates(mesh) {\n    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\n      const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\n      return intersections;\n    }\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  }\n  /**\n   * Return the list of sub meshes intersecting with a given local ray\n   * @param mesh defines the mesh to find the submesh for\n   * @param localRay defines the ray in local space\n   * @returns the list of intersecting sub meshes\n   */\n  getIntersectingSubMeshCandidates(mesh, localRay) {\n    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\n      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\n      const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\n      return intersections;\n    }\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  }\n  /**\n   * Return the list of sub meshes colliding with a collider\n   * @param mesh defines the mesh to find the submesh for\n   * @param collider defines the collider to evaluate the collision against\n   * @returns the list of colliding sub meshes\n   */\n  getCollidingSubMeshCandidates(mesh, collider) {\n    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\n      const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\n      const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\n      return intersections;\n    }\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do here.\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    // Nothing to do here.\n  }\n}","map":{"version":3,"mappings":"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","names":["Scene","Vector3","AbstractMesh","Ray","SceneComponentConstants","Octree","EngineStore","prototype","createOrUpdateSelectionOctree","maxCapacity","maxDepth","component","_getComponent","NAME_OCTREE","OctreeSceneComponent","_addComponent","_selectionOctree","CreationFuncForMeshes","worldExtends","getWorldExtends","update","min","max","meshes","Object","defineProperty","get","enumerable","configurable","createOrUpdateSubmeshesOctree","scene","getScene","_submeshesOctree","CreationFuncForSubMeshes","computeWorldMatrix","boundingInfo","getBoundingInfo","bbox","boundingBox","minimumWorld","maximumWorld","subMeshes","constructor","Zero","LastCreatedScene","getActiveMeshCandidates","bind","getActiveSubMeshCandidates","getCollidingSubMeshCandidates","getIntersectingSubMeshCandidates","register","onMeshRemovedObservable","add","mesh","sceneOctree","selectionOctree","undefined","index","dynamicContent","indexOf","splice","onMeshImportedObservable","addMesh","select","frustumPlanes","_getDefaultMeshCandidates","useOctreeForRenderingSelection","intersections","_getDefaultSubMeshCandidates","localRay","useOctreeForPicking","TransformToRef","getWorldMatrix","_tempRay","intersectsRay","collider","useOctreeForCollisions","radius","_velocityWorldLength","Math","_radius","x","y","z","intersects","_basePointWorld","rebuild","dispose"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Culling/Octrees/octreeSceneComponent.ts"],"sourcesContent":["import type { ISmartArrayLike } from \"../../Misc/smartArray\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\n\r\nimport { Octree } from \"./octree\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\n\r\ndeclare type Collider = import(\"../../Collisions/collider\").Collider;\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * @internal\r\n         * Backing Filed\r\n         */\r\n        _selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Gets the octree used to boost mesh selection (picking)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n         */\r\n        selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Creates or updates the octree used to boost selection (picking)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n         * @param maxCapacity defines the maximum capacity per leaf\r\n         * @param maxDepth defines the maximum depth of the octree\r\n         * @returns an octree of AbstractMesh\r\n         */\r\n        createOrUpdateSelectionOctree(maxCapacity?: number, maxDepth?: number): Octree<AbstractMesh>;\r\n    }\r\n}\r\n\r\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity = 64, maxDepth = 2): Octree<AbstractMesh> {\r\n    let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    if (!this._selectionOctree) {\r\n        this._selectionOctree = new Octree<AbstractMesh>(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    const worldExtends = this.getWorldExtends();\r\n\r\n    // Update octree\r\n    this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\r\n\r\n    return this._selectionOctree;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\r\n    get: function (this: Scene) {\r\n        return this._selectionOctree;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * @internal\r\n         * Backing Field\r\n         */\r\n        _submeshesOctree: Octree<SubMesh>;\r\n\r\n        /**\r\n         * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n         * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n         * @param maxCapacity defines the maximum size of each block (64 by default)\r\n         * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n         * @returns the new octree\r\n         * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n         */\r\n        createOrUpdateSubmeshesOctree(maxCapacity?: number, maxDepth?: number): Octree<SubMesh>;\r\n    }\r\n}\r\n\r\n/**\r\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n * @param maxCapacity defines the maximum size of each block (64 by default)\r\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n * @returns the new octree\r\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n */\r\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity = 64, maxDepth = 2): Octree<SubMesh> {\r\n    const scene = this.getScene();\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n\r\n    if (!this._submeshesOctree) {\r\n        this._submeshesOctree = new Octree<SubMesh>(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    this.computeWorldMatrix(true);\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n\r\n    // Update octree\r\n    const bbox = boundingInfo.boundingBox;\r\n    this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\r\n\r\n    return this._submeshesOctree;\r\n};\r\n\r\n/**\r\n * Defines the octree scene component responsible to manage any octrees\r\n * in a given scene.\r\n */\r\nexport class OctreeSceneComponent {\r\n    /**\r\n     * The component name help to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_OCTREE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\r\n     */\r\n    public readonly checksIsEnabled = true;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n\r\n        this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\r\n\r\n        this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\r\n        this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\r\n        this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene.onMeshRemovedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                const index = sceneOctree.dynamicContent.indexOf(mesh);\r\n\r\n                if (index !== -1) {\r\n                    sceneOctree.dynamicContent.splice(index, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.scene.onMeshImportedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                sceneOctree.addMesh(mesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the list of active meshes\r\n     * @returns the list of active meshes\r\n     */\r\n    public getActiveMeshCandidates(): ISmartArrayLike<AbstractMesh> {\r\n        return this.scene._selectionOctree?.select(this.scene.frustumPlanes) || this.scene._getDefaultMeshCandidates();\r\n    }\r\n\r\n    /**\r\n     * Return the list of active sub meshes\r\n     * @param mesh The mesh to get the candidates sub meshes from\r\n     * @returns the list of active sub meshes\r\n     */\r\n    public getActiveSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\r\n            const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    private _tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\r\n    /**\r\n     * Return the list of sub meshes intersecting with a given local ray\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param localRay defines the ray in local space\r\n     * @returns the list of intersecting sub meshes\r\n     */\r\n    public getIntersectingSubMeshCandidates(mesh: AbstractMesh, localRay: Ray): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\r\n            Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\r\n            const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Return the list of sub meshes colliding with a collider\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param collider defines the collider to evaluate the collision against\r\n     * @returns the list of colliding sub meshes\r\n     */\r\n    public getCollidingSubMeshCandidates(mesh: AbstractMesh, collider: Collider): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\r\n            const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\r\n            const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}