{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { BoundingSphere } from \"../../Culling/boundingSphere.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing.js\";\n// side effects\nimport \"../../Meshes/subMesh.project.js\";\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\nvar ControllerOrbAnimationState;\n(function (ControllerOrbAnimationState) {\n  /**\n   * Orb is invisible\n   */\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"DEHYDRATED\"] = 0] = \"DEHYDRATED\";\n  /**\n   * Orb is visible and inside the hover range\n   */\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"HOVER\"] = 1] = \"HOVER\";\n  /**\n   * Orb is visible and touching a near interaction target\n   */\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"TOUCH\"] = 2] = \"TOUCH\";\n})(ControllerOrbAnimationState || (ControllerOrbAnimationState = {}));\n/**\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\n */\nexport var WebXRNearControllerMode;\n(function (WebXRNearControllerMode) {\n  /**\n   * Motion controllers will not support near interaction\n   */\n  WebXRNearControllerMode[WebXRNearControllerMode[\"DISABLED\"] = 0] = \"DISABLED\";\n  /**\n   * The interaction point for motion controllers will be inside of them\n   */\n  WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_ON_CONTROLLER\"] = 1] = \"CENTERED_ON_CONTROLLER\";\n  /**\n   * The interaction point for motion controllers will be in front of the controller\n   */\n  WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_IN_FRONT\"] = 2] = \"CENTERED_IN_FRONT\";\n})(WebXRNearControllerMode || (WebXRNearControllerMode = {}));\n/**\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\n */\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\n  /**\n   * constructs a new background remover module\n   * @param _xrSessionManager the session manager for this module\n   * @param _options read-only options to be used in this module\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._tmpRay = new Ray(new Vector3(), new Vector3());\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      // get two new meshes\n      const {\n        touchCollisionMesh,\n        touchCollisionMeshFunction,\n        hydrateCollisionMeshFunction\n      } = this._generateNewTouchPointMesh();\n      const selectionMesh = this._generateVisualCue();\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        meshUnderPointer: null,\n        nearInteractionTargetMesh: null,\n        pick: null,\n        stalePick: null,\n        touchCollisionMesh,\n        touchCollisionMeshFunction: touchCollisionMeshFunction,\n        hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\n        currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\n        grabRay: new Ray(new Vector3(), new Vector3()),\n        hoverInteraction: false,\n        nearInteraction: false,\n        grabInteraction: false,\n        id: WebXRNearInteraction._IdCounter++,\n        pickedPointVisualCue: selectionMesh\n      };\n      if (this._attachedController) {\n        if (!this._options.enableNearInteractionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {\n          this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!this._options.enableNearInteractionOnAllControllers) {\n          this._attachedController = xrController.uniqueId;\n        }\n      }\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return this._attachNearInteractionMode(xrController);\n        case \"gaze\":\n          return null;\n        case \"screen\":\n          return null;\n      }\n    };\n    this._controllers = {};\n    this._farInteractionFeature = null;\n    /**\n     * default color of the selection ring\n     */\n    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\n     * This color will be applied to the selection ring when selection is triggered\n     */\n    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    this._hoverRadius = 0.1;\n    this._pickRadius = 0.02;\n    this._controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\n    this._nearGrabLengthScale = 5;\n    this._scene = this._xrSessionManager.scene;\n    if (this._options.nearInteractionControllerMode === undefined) {\n      this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\n    }\n    if (this._options.farInteractionFeature) {\n      this._farInteractionFeature = this._options.farInteractionFeature;\n    }\n  }\n  /**\n   * Attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n    return true;\n  }\n  /**\n   * Detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    return true;\n  }\n  /**\n   * Will get the mesh under a specific pointer.\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\n   * @param controllerId the controllerId to check\n   * @returns The mesh under pointer or null if no mesh is under the pointer\n   */\n  getMeshUnderPointer(controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the xr controller that correlates to the pointer id in the pointer event\n   *\n   * @param id the pointer id to search for\n   * @returns the controller that correlates to this id or null if not found\n   */\n  getXRControllerByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n    return null;\n  }\n  /**\n   * This function sets webXRControllerPointerSelection feature that will be disabled when\n   * the hover range is reached for a mesh and will be reattached when not in hover range.\n   * This is used to remove the selection rays when moving.\n   * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\n   */\n  setFarInteractionFeature(farInteractionFeature) {\n    this._farInteractionFeature = farInteractionFeature;\n  }\n  /**\n   * Filter used for near interaction pick and hover\n   * @param mesh\n   */\n  _nearPickPredicate(mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\n  }\n  /**\n   * Filter used for near interaction grab\n   * @param mesh\n   */\n  _nearGrabPredicate(mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\n  }\n  /**\n   * Filter used for any near interaction\n   * @param mesh\n   */\n  _nearInteractionPredicate(mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\n  }\n  _controllerAvailablePredicate(mesh, controllerId) {\n    let parent = mesh;\n    while (parent) {\n      if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\n        return false;\n      }\n      parent = parent.parent;\n    }\n    return true;\n  }\n  _handleTransitionAnimation(controllerData, newState) {\n    var _a;\n    if (controllerData.currentAnimationState === newState || this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT || !!((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {\n      return;\n    }\n    // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\n    if (newState > controllerData.currentAnimationState) {\n      switch (controllerData.currentAnimationState) {\n        case ControllerOrbAnimationState.DEHYDRATED:\n          {\n            controllerData.hydrateCollisionMeshFunction(true);\n            if (newState === ControllerOrbAnimationState.HOVER) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n        case ControllerOrbAnimationState.HOVER:\n          {\n            controllerData.touchCollisionMeshFunction(true);\n            if (newState === ControllerOrbAnimationState.TOUCH) {\n              break;\n            }\n          }\n      }\n    } else {\n      switch (controllerData.currentAnimationState) {\n        case ControllerOrbAnimationState.TOUCH:\n          {\n            controllerData.touchCollisionMeshFunction(false);\n            if (newState === ControllerOrbAnimationState.HOVER) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n        case ControllerOrbAnimationState.HOVER:\n          {\n            controllerData.hydrateCollisionMeshFunction(false);\n            if (newState === ControllerOrbAnimationState.DEHYDRATED) {\n              break;\n            }\n          }\n      }\n    }\n    controllerData.currentAnimationState = newState;\n  }\n  _processTouchPoint(id, position, orientation) {\n    var _a;\n    const controllerData = this._controllers[id];\n    // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\n    controllerData.grabRay.origin.copyFrom(position);\n    orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\n    controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\n    if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {\n      // offset the touch point in the direction the transform is facing\n      controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n      controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\n    }\n    controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius;\n    controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin);\n  }\n  _onXRFrame(_xrFrame) {\n    Object.keys(this._controllers).forEach(id => {\n      var _a;\n      // only do this for the selected pointer\n      const controllerData = this._controllers[id];\n      const handData = (_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand;\n      // If near interaction is not enabled/available for this controller, return early\n      if (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController || !controllerData.xrController || !handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {\n        controllerData.pick = null;\n        return;\n      }\n      controllerData.hoverInteraction = false;\n      controllerData.nearInteraction = false;\n      // Every frame check collisions/input\n      if (controllerData.xrController) {\n        if (handData) {\n          const xrIndexTip = handData.get(\"index-finger-tip\");\n          if (xrIndexTip) {\n            const indexTipPose = _xrFrame.getJointPose(xrIndexTip, this._xrSessionManager.referenceSpace);\n            if (indexTipPose && indexTipPose.transform) {\n              const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\n              TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\n              TmpVectors.Quaternion[0].set(indexTipPose.transform.orientation.x, indexTipPose.transform.orientation.y, indexTipPose.transform.orientation.z * axisRHSMultiplier, indexTipPose.transform.orientation.w * axisRHSMultiplier);\n              this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\n            }\n          }\n        } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\n          let controllerPose = controllerData.xrController.pointer;\n          if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\n            controllerPose = controllerData.xrController.grip;\n          }\n          this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion);\n        }\n      } else {\n        return;\n      }\n      const accuratePickInfo = (originalScenePick, utilityScenePick) => {\n        let pick = null;\n        if (!utilityScenePick || !utilityScenePick.hit) {\n          // No hit in utility scene\n          pick = originalScenePick;\n        } else if (!originalScenePick || !originalScenePick.hit) {\n          // No hit in original scene\n          pick = utilityScenePick;\n        } else if (utilityScenePick.distance < originalScenePick.distance) {\n          // Hit is closer in utility scene\n          pick = utilityScenePick;\n        } else {\n          // Hit is closer in original scene\n          pick = originalScenePick;\n        }\n        return pick;\n      };\n      const populateNearInteractionInfo = nearInteractionInfo => {\n        let result = new PickingInfo();\n        let nearInteractionAtOrigin = false;\n        const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\n        if (nearInteractionInfo === null || nearInteractionInfo === void 0 ? void 0 : nearInteractionInfo.pickedPoint) {\n          nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\n        }\n        if (nearInteraction && !nearInteractionAtOrigin) {\n          result = nearInteractionInfo;\n        }\n        return result;\n      };\n      // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\n      // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\n      // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\n      if (!controllerData.grabInteraction) {\n        let pick = null;\n        // near interaction hover\n        let utilitySceneHoverPick = null;\n        if (this._options.useUtilityLayer && this._utilityLayerScene) {\n          utilitySceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._utilityLayerScene, mesh => this._nearInteractionPredicate(mesh));\n        }\n        const originalSceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._scene, mesh => this._nearInteractionPredicate(mesh));\n        const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\n        if (hoverPickInfo && hoverPickInfo.hit) {\n          pick = populateNearInteractionInfo(hoverPickInfo);\n          if (pick.hit) {\n            controllerData.hoverInteraction = true;\n          }\n        }\n        // near interaction pick\n        if (controllerData.hoverInteraction) {\n          let utilitySceneNearPick = null;\n          const radius = handData ? this._pickRadius : this._controllerPickRadius;\n          if (this._options.useUtilityLayer && this._utilityLayerScene) {\n            utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, mesh => this._nearPickPredicate(mesh));\n          }\n          const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, mesh => this._nearPickPredicate(mesh));\n          const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\n          const nearPick = populateNearInteractionInfo(pickInfo);\n          if (nearPick.hit) {\n            // Near pick takes precedence over hover interaction\n            pick = nearPick;\n            controllerData.nearInteraction = true;\n          }\n        }\n        controllerData.stalePick = controllerData.pick;\n        controllerData.pick = pick;\n        // Update mesh under pointer\n        if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\n          controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\n          controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\n          controllerData.pickedPointVisualCue.isVisible = true;\n          if (this._farInteractionFeature && this._farInteractionFeature.attached) {\n            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\n          }\n        } else {\n          controllerData.meshUnderPointer = null;\n          controllerData.pickedPointVisualCue.isVisible = false;\n          if (this._farInteractionFeature && this._farInteractionFeature.attached) {\n            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\n          }\n        }\n      }\n      // Update the interaction animation. Only updates if the visible touch mesh is active\n      let state = ControllerOrbAnimationState.DEHYDRATED;\n      if (controllerData.grabInteraction || controllerData.nearInteraction) {\n        state = ControllerOrbAnimationState.TOUCH;\n      } else if (controllerData.hoverInteraction) {\n        state = ControllerOrbAnimationState.HOVER;\n      }\n      this._handleTransitionAnimation(controllerData, state);\n    });\n  }\n  get _utilityLayerScene() {\n    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n  }\n  _generateVisualCue() {\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    const selectionMesh = CreateSphere(\"nearInteraction\", {\n      diameter: 0.0035 * 3\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    selectionMesh.rotationQuaternion = Quaternion.Identity();\n    const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n    return selectionMesh;\n  }\n  _isControllerReadyForNearInteraction(id) {\n    if (this._farInteractionFeature) {\n      return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\n    }\n    return true;\n  }\n  _attachNearInteractionMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr-near\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      if (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController || !controllerData.xrController || !controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {\n        return;\n      }\n      if (controllerData.pick) {\n        controllerData.pick.ray = controllerData.grabRay;\n      }\n      if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n      // Near pick pointer event\n      if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\n        if (!controllerData.nearInteractionTargetMesh) {\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n          controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\n        }\n      } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\n        this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\n        controllerData.nearInteractionTargetMesh = null;\n      }\n    });\n    const grabCheck = pressed => {\n      if (this._options.enableNearInteractionOnAllControllers || xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id)) {\n        if (controllerData.pick) {\n          controllerData.pick.ray = controllerData.grabRay;\n        }\n        if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n          controllerData.grabInteraction = true;\n          controllerData.pickedPointVisualCue.isVisible = false;\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n        } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.grabInteraction = false;\n          controllerData.pickedPointVisualCue.isVisible = true;\n        }\n      } else {\n        if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\n          this._attachedController = xrController.uniqueId;\n        }\n      }\n    };\n    if (xrController.inputSource.gamepad) {\n      const init = motionController => {\n        controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\n        if (controllerData.squeezeComponent) {\n          controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add(component => {\n            if (component.changes.pressed) {\n              const pressed = component.changes.pressed.current;\n              grabCheck(pressed);\n            }\n          });\n        } else {\n          controllerData.selectionComponent = motionController.getMainComponent();\n          controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(component => {\n            if (component.changes.pressed) {\n              const pressed = component.changes.pressed.current;\n              grabCheck(pressed);\n            }\n          });\n        }\n      };\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      const selectStartListener = event => {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id) && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n          controllerData.grabInteraction = true;\n          controllerData.pickedPointVisualCue.isVisible = false;\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n        }\n      };\n      const selectEndListener = event => {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.grabInteraction = false;\n          controllerData.pickedPointVisualCue.isVisible = true;\n        }\n      };\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.squeezeComponent) {\n      if (controllerData.onSqueezeButtonChangedObserver) {\n        controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\n      }\n    }\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(eventName => {\n        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n        if (func) {\n          this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n    controllerData.touchCollisionMesh.dispose();\n    controllerData.pickedPointVisualCue.dispose();\n    this._xrSessionManager.runInXRFrame(() => {\n      // Fire a pointerup\n      const pointerEventInit = {\n        pointerId: controllerData.id,\n        pointerType: \"xr-near\"\n      };\n      this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\n    });\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n    if (this._attachedController === xrControllerUniqueId) {\n      // check for other controllers\n      const keys = Object.keys(this._controllers);\n      if (keys.length) {\n        this._attachedController = keys[0];\n      } else {\n        this._attachedController = \"\";\n      }\n    }\n  }\n  _generateNewTouchPointMesh() {\n    // populate information for near hover, pick and pinch\n    const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    const touchCollisionMesh = CreateSphere(\"PickSphere\", {\n      diameter: 1\n    }, meshCreationScene);\n    touchCollisionMesh.isVisible = false;\n    // Generate the material for the touch mesh visuals\n    if (this._options.motionControllerOrbMaterial) {\n      touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\n    } else {\n      NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then(nodeMaterial => {\n        touchCollisionMesh.material = nodeMaterial;\n      });\n    }\n    const easingFunction = new QuadraticEase();\n    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n    // Adjust the visual size based off of the size of the touch collision orb.\n    // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\n    // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\n    const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius);\n    const touchSize = this._controllerPickRadius * (4 / 3);\n    const touchSizeVec = new Vector3(touchSize, touchSize, touchSize);\n    const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\n    const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize);\n    const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\n    const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize);\n    const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\n    const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize);\n    const touchKeys = [{\n      frame: 0,\n      value: hoverSizeVec\n    }, {\n      frame: 10,\n      value: hoverTouchTransitionSizeVec\n    }, {\n      frame: 18,\n      value: touchSizeVec\n    }];\n    const releaseKeys = [{\n      frame: 0,\n      value: touchSizeVec\n    }, {\n      frame: 10,\n      value: touchHoverTransitionSizeVec\n    }, {\n      frame: 18,\n      value: hoverSizeVec\n    }];\n    const hydrateKeys = [{\n      frame: 0,\n      value: Vector3.ZeroReadOnly\n    }, {\n      frame: 12,\n      value: hydrateTransitionSizeVec\n    }, {\n      frame: 15,\n      value: hoverSizeVec\n    }];\n    const dehydrateKeys = [{\n      frame: 0,\n      value: hoverSizeVec\n    }, {\n      frame: 10,\n      value: Vector3.ZeroReadOnly\n    }, {\n      frame: 15,\n      value: Vector3.ZeroReadOnly\n    }];\n    const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    touchAction.setEasingFunction(easingFunction);\n    releaseAction.setEasingFunction(easingFunction);\n    hydrateAction.setEasingFunction(easingFunction);\n    dehydrateAction.setEasingFunction(easingFunction);\n    touchAction.setKeys(touchKeys);\n    releaseAction.setKeys(releaseKeys);\n    hydrateAction.setKeys(hydrateKeys);\n    dehydrateAction.setKeys(dehydrateKeys);\n    const touchCollisionMeshFunction = isTouch => {\n      const action = isTouch ? touchAction : releaseAction;\n      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\n    };\n    const hydrateCollisionMeshFunction = isHydration => {\n      const action = isHydration ? hydrateAction : dehydrateAction;\n      if (isHydration) {\n        touchCollisionMesh.isVisible = true;\n      }\n      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\n        if (!isHydration) {\n          touchCollisionMesh.isVisible = false;\n        }\n      });\n    };\n    return {\n      touchCollisionMesh,\n      touchCollisionMeshFunction,\n      hydrateCollisionMeshFunction\n    };\n  }\n  _pickWithSphere(controllerData, radius, sceneToUse, predicate) {\n    const pickingInfo = new PickingInfo();\n    pickingInfo.distance = +Infinity;\n    if (controllerData.touchCollisionMesh && controllerData.xrController) {\n      const position = controllerData.touchCollisionMesh.position;\n      const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\n      for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\n        const mesh = sceneToUse.meshes[meshIndex];\n        if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\n          continue;\n        }\n        const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\n        if (result && result.hit && result.distance < pickingInfo.distance) {\n          pickingInfo.hit = result.hit;\n          pickingInfo.pickedMesh = mesh;\n          pickingInfo.pickedPoint = result.pickedPoint;\n          pickingInfo.aimTransform = controllerData.xrController.pointer;\n          pickingInfo.gripTransform = controllerData.xrController.grip || null;\n          pickingInfo.originMesh = controllerData.touchCollisionMesh;\n          pickingInfo.distance = result.distance;\n        }\n      }\n    }\n    return pickingInfo;\n  }\n  /**\n   * Picks a mesh with a sphere\n   * @param mesh the mesh to pick\n   * @param sphere picking sphere in world coordinates\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @returns the picking info\n   */\n  static PickMeshWithSphere(mesh, sphere, skipBoundingInfo = false) {\n    const subMeshes = mesh.subMeshes;\n    const pi = new PickingInfo();\n    const boundingInfo = mesh.getBoundingInfo();\n    if (!mesh._generatePointsArray()) {\n      return pi;\n    }\n    if (!mesh.subMeshes || !boundingInfo) {\n      return pi;\n    }\n    if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\n      return pi;\n    }\n    const result = TmpVectors.Vector3[0];\n    const tmpVec = TmpVectors.Vector3[1];\n    let distance = +Infinity;\n    let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter;\n    const center = TmpVectors.Vector3[2];\n    const worldToMesh = TmpVectors.Matrix[0];\n    worldToMesh.copyFrom(mesh.getWorldMatrix());\n    worldToMesh.invert();\n    Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\n    for (let index = 0; index < subMeshes.length; index++) {\n      const subMesh = subMeshes[index];\n      subMesh.projectToRef(center, mesh._positions, mesh.getIndices(), tmpVec);\n      Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\n      tmp = Vector3.Distance(tmpVec, sphere.center);\n      // Check for finger inside of mesh\n      tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\n      tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\n      if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\n        tmp = 0;\n        tmpVec.copyFrom(sphere.center);\n      }\n      if (tmp !== -1 && tmp < distance) {\n        distance = tmp;\n        result.copyFrom(tmpVec);\n      }\n    }\n    if (distance < sphere.radius) {\n      pi.hit = true;\n      pi.distance = distance;\n      pi.pickedMesh = mesh;\n      pi.pickedPoint = result.clone();\n    }\n    return pi;\n  }\n}\nWebXRNearInteraction._IdCounter = 200;\n/**\n * The module's name\n */\nWebXRNearInteraction.Name = WebXRFeatureName.NEAR_INTERACTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRNearInteraction.Version = 1;\n//Register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRNearInteraction.Name, (xrSessionManager, options) => {\n  return () => new WebXRNearInteraction(xrSessionManager, options);\n}, WebXRNearInteraction.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","CreateSphere","Vector3","Quaternion","TmpVectors","Ray","PickingInfo","WebXRAbstractFeature","UtilityLayerRenderer","BoundingSphere","StandardMaterial","Color3","NodeMaterial","Animation","QuadraticEase","EasingFunction","ControllerOrbAnimationState","WebXRNearControllerMode","WebXRNearInteraction","constructor","_xrSessionManager","_options","xrController","_controllers","uniqueId","touchCollisionMesh","touchCollisionMeshFunction","hydrateCollisionMeshFunction","_generateNewTouchPointMesh","selectionMesh","_generateVisualCue","meshUnderPointer","nearInteractionTargetMesh","pick","stalePick","currentAnimationState","DEHYDRATED","grabRay","hoverInteraction","nearInteraction","grabInteraction","id","_IdCounter","pickedPointVisualCue","_attachedController","enableNearInteractionOnAllControllers","preferredHandedness","inputSource","handedness","targetRayMode","_attachNearInteractionMode","_scene","scene","nearInteractionControllerMode","undefined","CENTERED_IN_FRONT","farInteractionFeature","_farInteractionFeature","attach","xrInput","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","constantlyUpdateMeshUnderPointer","detach","Object","keys","controllerId","getMeshUnderPointer","getXRControllerByPointerId","i","length","setFarInteractionFeature","_nearPickPredicate","mesh","isEnabled","isVisible","isPickable","isNearPickable","_nearGrabPredicate","isNearGrabbable","_nearInteractionPredicate","_controllerAvailablePredicate","parent","reservedDataStore","excludedControllerId","_handleTransitionAnimation","controllerData","newState","hand","HOVER","TOUCH","_processTouchPoint","position","orientation","origin","copyFrom","toEulerAnglesToRef","direction","getWorldPointerRayToRef","_tmpRay","addInPlace","scale","_nearGrabLengthScale","_hoverRadius","_onXRFrame","_xrFrame","handData","gamepad","xrIndexTip","get","indexTipPose","getJointPose","referenceSpace","transform","axisRHSMultiplier","useRightHandedSystem","set","x","y","z","w","DISABLED","controllerPose","pointer","grip","CENTERED_ON_CONTROLLER","rotationQuaternion","accuratePickInfo","originalScenePick","utilityScenePick","hit","distance","populateNearInteractionInfo","nearInteractionInfo","result","nearInteractionAtOrigin","pickedPoint","utilitySceneHoverPick","useUtilityLayer","_utilityLayerScene","_pickWithSphere","originalSceneHoverPick","hoverPickInfo","utilitySceneNearPick","radius","_pickRadius","_controllerPickRadius","originalSceneNearPick","pickInfo","nearPick","pickedMesh","attached","_setPointerSelectionDisabledByPointerId","state","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","sceneToRenderTo","diameter","bakeCurrentTransformIntoVertices","Identity","targetMat","specularColor","Black","emissiveColor","selectionMeshDefaultColor","backFaceCulling","material","_isControllerReadyForNearInteraction","_getPointerSelectionDisabledByPointerId","pointerEventInit","pointerId","pointerType","onFrameObserver","onXRFrameObservable","add","ray","simulatePointerMove","simulatePointerDown","simulatePointerUp","grabCheck","pressed","disableSwitchOnClick","init","motionController","squeezeComponent","getComponent","onSqueezeButtonChangedObserver","onButtonStateChangedObservable","component","changes","current","selectionComponent","getMainComponent","onButtonChangedObserver","onMotionControllerInitObservable","selectStartListener","event","selectEndListener","eventListeners","selectend","selectstart","session","addEventListener","xrControllerUniqueId","remove","eventName","func","removeEventListener","dispose","runInXRFrame","meshCreationScene","motionControllerOrbMaterial","ParseFromSnippetAsync","then","nodeMaterial","easingFunction","setEasingMode","EASINGMODE_EASEINOUT","hoverSizeVec","touchSize","touchSizeVec","hydrateTransitionSize","hydrateTransitionSizeVec","touchHoverTransitionSize","touchHoverTransitionSizeVec","hoverTouchTransitionSize","hoverTouchTransitionSizeVec","touchKeys","frame","value","releaseKeys","hydrateKeys","ZeroReadOnly","dehydrateKeys","touchAction","ANIMATIONTYPE_VECTOR3","ANIMATIONLOOPMODE_CONSTANT","releaseAction","hydrateAction","dehydrateAction","setEasingFunction","setKeys","isTouch","action","beginDirectAnimation","isHydration","sceneToUse","predicate","pickingInfo","Infinity","sphere","CreateFromCenterAndRadius","meshIndex","meshes","PickMeshWithSphere","aimTransform","gripTransform","originMesh","skipBoundingInfo","subMeshes","pi","boundingInfo","getBoundingInfo","_generatePointsArray","Intersects","boundingSphere","tmpVec","tmp","tmpDistanceSphereToCenter","tmpDistanceSurfaceToCenter","center","worldToMesh","Matrix","getWorldMatrix","invert","TransformCoordinatesToRef","index","subMesh","projectToRef","_positions","getIndices","Distance","getAbsolutePosition","clone","NEAR_INTERACTION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRNearInteraction.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRControllerPointerSelection } from \"./WebXRControllerPointerSelection\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { IndicesArray, Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport { BoundingSphere } from \"../../Culling/boundingSphere\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing\";\r\n// side effects\r\nimport \"../../Meshes/subMesh.project\";\r\n\r\ntype ControllerData = {\r\n    xrController?: WebXRInputSource;\r\n    squeezeComponent?: WebXRControllerComponent;\r\n    selectionComponent?: WebXRControllerComponent;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onSqueezeButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n    meshUnderPointer: Nullable<AbstractMesh>;\r\n    nearInteractionTargetMesh: Nullable<AbstractMesh>;\r\n    pick: Nullable<PickingInfo>;\r\n    stalePick: Nullable<PickingInfo>;\r\n    id: number;\r\n    touchCollisionMesh: AbstractMesh;\r\n    touchCollisionMeshFunction: (isTouch: boolean) => void;\r\n    hydrateCollisionMeshFunction: (isHydration: boolean) => void;\r\n    currentAnimationState: ControllerOrbAnimationState;\r\n    grabRay: Ray;\r\n    nearInteraction: boolean;\r\n    hoverInteraction: boolean;\r\n    grabInteraction: boolean;\r\n    // event support\r\n    eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n    pickedPointVisualCue: AbstractMesh;\r\n};\r\n\r\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\r\nenum ControllerOrbAnimationState {\r\n    /**\r\n     * Orb is invisible\r\n     */\r\n    DEHYDRATED,\r\n    /**\r\n     * Orb is visible and inside the hover range\r\n     */\r\n    HOVER,\r\n    /**\r\n     * Orb is visible and touching a near interaction target\r\n     */\r\n    TOUCH,\r\n}\r\n\r\n/**\r\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\r\n */\r\nexport enum WebXRNearControllerMode {\r\n    /**\r\n     * Motion controllers will not support near interaction\r\n     */\r\n    DISABLED = 0,\r\n    /**\r\n     * The interaction point for motion controllers will be inside of them\r\n     */\r\n    CENTERED_ON_CONTROLLER = 1,\r\n    /**\r\n     * The interaction point for motion controllers will be in front of the controller\r\n     */\r\n    CENTERED_IN_FRONT = 2,\r\n}\r\n\r\n/**\r\n * Options interface for the near interaction module\r\n */\r\nexport interface IWebXRNearInteractionOptions {\r\n    /**\r\n     * If provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * The xr input to use with this near interaction\r\n     */\r\n    xrInput: WebXRInput;\r\n    /**\r\n     * Enable near interaction on all controllers instead of switching between them\r\n     */\r\n    enableNearInteractionOnAllControllers?: boolean;\r\n    /**\r\n     * The preferred hand to give the near interaction to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n    /**\r\n     * Disable switching the near interaction from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * Far interaction feature to toggle when near interaction takes precedence\r\n     */\r\n    farInteractionFeature?: WebXRControllerPointerSelection;\r\n\r\n    /**\r\n     * Near interaction mode for motion controllers\r\n     */\r\n    nearInteractionControllerMode?: WebXRNearControllerMode;\r\n\r\n    /**\r\n     * Optional material for the motion controller orb, if enabled\r\n     */\r\n    motionControllerOrbMaterial?: Material;\r\n}\r\n\r\n/**\r\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\r\n */\r\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _tmpRay: Ray = new Ray(new Vector3(), new Vector3());\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        // get two new meshes\r\n        const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n        const selectionMesh = this._generateVisualCue();\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            meshUnderPointer: null,\r\n            nearInteractionTargetMesh: null,\r\n            pick: null,\r\n            stalePick: null,\r\n            touchCollisionMesh,\r\n            touchCollisionMeshFunction: touchCollisionMeshFunction,\r\n            hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\r\n            currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\r\n            grabRay: new Ray(new Vector3(), new Vector3()),\r\n            hoverInteraction: false,\r\n            nearInteraction: false,\r\n            grabInteraction: false,\r\n            id: WebXRNearInteraction._IdCounter++,\r\n            pickedPointVisualCue: selectionMesh,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enableNearInteractionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enableNearInteractionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachNearInteractionMode(xrController);\r\n            case \"gaze\":\r\n                return null;\r\n            case \"screen\":\r\n                return null;\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: ControllerData;\r\n    } = {};\r\n    private _scene: Scene;\r\n\r\n    private _attachedController: string;\r\n\r\n    private _farInteractionFeature: Nullable<WebXRControllerPointerSelection> = null;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.NEAR_INTERACTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRNearInteractionOptions) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n        if (this._options.nearInteractionControllerMode === undefined) {\r\n            this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\r\n        }\r\n\r\n        if (this._options.farInteractionFeature) {\r\n            this._farInteractionFeature = this._options.farInteractionFeature;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function sets webXRControllerPointerSelection feature that will be disabled when\r\n     * the hover range is reached for a mesh and will be reattached when not in hover range.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\r\n     */\r\n    public setFarInteractionFeature(farInteractionFeature: Nullable<WebXRControllerPointerSelection>) {\r\n        this._farInteractionFeature = farInteractionFeature;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction pick and hover\r\n     * @param mesh\r\n     */\r\n    private _nearPickPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction grab\r\n     * @param mesh\r\n     */\r\n    private _nearGrabPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for any near interaction\r\n     * @param mesh\r\n     */\r\n    private _nearInteractionPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\r\n    }\r\n\r\n    private _controllerAvailablePredicate(mesh: AbstractMesh, controllerId: string): boolean {\r\n        let parent: TransformNode = mesh;\r\n\r\n        while (parent) {\r\n            if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\r\n                return false;\r\n            }\r\n            parent = parent.parent as TransformNode;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _handleTransitionAnimation(controllerData: ControllerData, newState: ControllerOrbAnimationState) {\r\n        if (\r\n            controllerData.currentAnimationState === newState ||\r\n            this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT ||\r\n            !!controllerData.xrController?.inputSource.hand\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\r\n        if (newState > controllerData.currentAnimationState) {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.DEHYDRATED: {\r\n                    controllerData.hydrateCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.touchCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.TOUCH) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.TOUCH: {\r\n                    controllerData.touchCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.hydrateCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.DEHYDRATED) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        controllerData.currentAnimationState = newState;\r\n    }\r\n\r\n    private readonly _hoverRadius = 0.1;\r\n    private readonly _pickRadius = 0.02;\r\n    private readonly _controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\r\n    private readonly _nearGrabLengthScale = 5;\r\n\r\n    private _processTouchPoint(id: string, position: Vector3, orientation: Quaternion) {\r\n        const controllerData = this._controllers[id];\r\n\r\n        // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\r\n        controllerData.grabRay.origin.copyFrom(position);\r\n        orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\r\n        controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\r\n\r\n        if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !controllerData.xrController?.inputSource.hand) {\r\n            // offset the touch point in the direction the transform is facing\r\n            controllerData.xrController!.getWorldPointerRayToRef(this._tmpRay);\r\n            controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\r\n        }\r\n\r\n        controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius;\r\n        controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin);\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            const handData = controllerData.xrController?.inputSource.hand;\r\n            // If near interaction is not enabled/available for this controller, return early\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n            controllerData.hoverInteraction = false;\r\n            controllerData.nearInteraction = false;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                if (handData) {\r\n                    const xrIndexTip = handData.get(\"index-finger-tip\");\r\n                    if (xrIndexTip) {\r\n                        const indexTipPose = _xrFrame.getJointPose!(xrIndexTip, this._xrSessionManager.referenceSpace);\r\n                        if (indexTipPose && indexTipPose.transform) {\r\n                            const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\r\n                            TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\r\n                            TmpVectors.Quaternion[0].set(\r\n                                indexTipPose.transform.orientation.x,\r\n                                indexTipPose.transform.orientation.y,\r\n                                indexTipPose.transform.orientation.z * axisRHSMultiplier,\r\n                                indexTipPose.transform.orientation.w * axisRHSMultiplier\r\n                            );\r\n\r\n                            this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\r\n                        }\r\n                    }\r\n                } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\r\n                    let controllerPose = controllerData.xrController.pointer;\r\n                    if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\r\n                        controllerPose = controllerData.xrController.grip;\r\n                    }\r\n\r\n                    this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion!);\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const accuratePickInfo = (originalScenePick: Nullable<PickingInfo>, utilityScenePick: Nullable<PickingInfo>): Nullable<PickingInfo> => {\r\n                let pick = null;\r\n                if (!utilityScenePick || !utilityScenePick.hit) {\r\n                    // No hit in utility scene\r\n                    pick = originalScenePick;\r\n                } else if (!originalScenePick || !originalScenePick.hit) {\r\n                    // No hit in original scene\r\n                    pick = utilityScenePick;\r\n                } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                    // Hit is closer in utility scene\r\n                    pick = utilityScenePick;\r\n                } else {\r\n                    // Hit is closer in original scene\r\n                    pick = originalScenePick;\r\n                }\r\n                return pick;\r\n            };\r\n            const populateNearInteractionInfo = (nearInteractionInfo: Nullable<PickingInfo>): PickingInfo => {\r\n                let result = new PickingInfo();\r\n\r\n                let nearInteractionAtOrigin = false;\r\n                const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\r\n                if (nearInteractionInfo?.pickedPoint) {\r\n                    nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\r\n                }\r\n                if (nearInteraction && !nearInteractionAtOrigin) {\r\n                    result = nearInteractionInfo!;\r\n                }\r\n                return result;\r\n            };\r\n\r\n            // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\r\n            // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\r\n            // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\r\n            if (!controllerData.grabInteraction) {\r\n                let pick = null;\r\n\r\n                // near interaction hover\r\n                let utilitySceneHoverPick = null;\r\n                if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                    utilitySceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._utilityLayerScene, (mesh: AbstractMesh) =>\r\n                        this._nearInteractionPredicate(mesh)\r\n                    );\r\n                }\r\n                const originalSceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._scene, (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh));\r\n\r\n                const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\r\n                if (hoverPickInfo && hoverPickInfo.hit) {\r\n                    pick = populateNearInteractionInfo(hoverPickInfo);\r\n                    if (pick.hit) {\r\n                        controllerData.hoverInteraction = true;\r\n                    }\r\n                }\r\n\r\n                // near interaction pick\r\n                if (controllerData.hoverInteraction) {\r\n                    let utilitySceneNearPick = null;\r\n                    const radius = handData ? this._pickRadius : this._controllerPickRadius;\r\n                    if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                        utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    }\r\n                    const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\r\n                    const nearPick = populateNearInteractionInfo(pickInfo);\r\n                    if (nearPick.hit) {\r\n                        // Near pick takes precedence over hover interaction\r\n                        pick = nearPick;\r\n                        controllerData.nearInteraction = true;\r\n                    }\r\n                }\r\n\r\n                controllerData.stalePick = controllerData.pick;\r\n                controllerData.pick = pick;\r\n\r\n                // Update mesh under pointer\r\n                if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\r\n                    controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\r\n                    controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\r\n                    }\r\n                } else {\r\n                    controllerData.meshUnderPointer = null;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update the interaction animation. Only updates if the visible touch mesh is active\r\n            let state = ControllerOrbAnimationState.DEHYDRATED;\r\n            if (controllerData.grabInteraction || controllerData.nearInteraction) {\r\n                state = ControllerOrbAnimationState.TOUCH;\r\n            } else if (controllerData.hoverInteraction) {\r\n                state = ControllerOrbAnimationState.HOVER;\r\n            }\r\n            this._handleTransitionAnimation(controllerData, state);\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _generateVisualCue() {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const selectionMesh = CreateSphere(\r\n            \"nearInteraction\",\r\n            {\r\n                diameter: 0.0035 * 3,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        selectionMesh.rotationQuaternion = Quaternion.Identity();\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        return selectionMesh;\r\n    }\r\n\r\n    private _isControllerReadyForNearInteraction(id: number) {\r\n        if (this._farInteractionFeature) {\r\n            return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _attachNearInteractionMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr-near\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                return;\r\n            }\r\n            if (controllerData.pick) {\r\n                controllerData.pick.ray = controllerData.grabRay;\r\n            }\r\n\r\n            if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n\r\n            // Near pick pointer event\r\n            if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\r\n                if (!controllerData.nearInteractionTargetMesh) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\r\n                }\r\n            } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\r\n                this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\r\n                controllerData.nearInteractionTargetMesh = null;\r\n            }\r\n        });\r\n\r\n        const grabCheck = (pressed: boolean) => {\r\n            if (\r\n                this._options.enableNearInteractionOnAllControllers ||\r\n                (xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id))\r\n            ) {\r\n                if (controllerData.pick) {\r\n                    controllerData.pick.ray = controllerData.grabRay;\r\n                }\r\n                if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                }\r\n            } else {\r\n                if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                    this._attachedController = xrController.uniqueId;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\r\n                if (controllerData.squeezeComponent) {\r\n                    controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                } else {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                    controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id) &&\r\n                    controllerData.meshUnderPointer &&\r\n                    this._nearGrabPredicate(controllerData.meshUnderPointer)\r\n                ) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id)\r\n                ) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = true;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.squeezeComponent) {\r\n            if (controllerData.onSqueezeButtonChangedObserver) {\r\n                controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n        controllerData.touchCollisionMesh.dispose();\r\n        controllerData.pickedPointVisualCue.dispose();\r\n\r\n        this._xrSessionManager.runInXRFrame(() => {\r\n            // Fire a pointerup\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr-near\",\r\n            };\r\n            this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\r\n        });\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n        if (this._attachedController === xrControllerUniqueId) {\r\n            // check for other controllers\r\n            const keys = Object.keys(this._controllers);\r\n            if (keys.length) {\r\n                this._attachedController = keys[0];\r\n            } else {\r\n                this._attachedController = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    private _generateNewTouchPointMesh() {\r\n        // populate information for near hover, pick and pinch\r\n        const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n\r\n        const touchCollisionMesh = CreateSphere(\"PickSphere\", { diameter: 1 }, meshCreationScene);\r\n        touchCollisionMesh.isVisible = false;\r\n\r\n        // Generate the material for the touch mesh visuals\r\n        if (this._options.motionControllerOrbMaterial) {\r\n            touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\r\n        } else {\r\n            NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then((nodeMaterial) => {\r\n                touchCollisionMesh.material = nodeMaterial;\r\n            });\r\n        }\r\n\r\n        const easingFunction = new QuadraticEase();\r\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n\r\n        // Adjust the visual size based off of the size of the touch collision orb.\r\n        // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\r\n        // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\r\n        const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius);\r\n        const touchSize = this._controllerPickRadius * (4 / 3);\r\n        const touchSizeVec = new Vector3(touchSize, touchSize, touchSize);\r\n        const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\r\n        const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize);\r\n        const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\r\n        const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize);\r\n        const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\r\n        const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize);\r\n\r\n        const touchKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: hoverTouchTransitionSizeVec },\r\n            { frame: 18, value: touchSizeVec },\r\n        ];\r\n        const releaseKeys = [\r\n            { frame: 0, value: touchSizeVec },\r\n            { frame: 10, value: touchHoverTransitionSizeVec },\r\n            { frame: 18, value: hoverSizeVec },\r\n        ];\r\n        const hydrateKeys = [\r\n            { frame: 0, value: Vector3.ZeroReadOnly },\r\n            { frame: 12, value: hydrateTransitionSizeVec },\r\n            { frame: 15, value: hoverSizeVec },\r\n        ];\r\n        const dehydrateKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: Vector3.ZeroReadOnly },\r\n            { frame: 15, value: Vector3.ZeroReadOnly },\r\n        ];\r\n\r\n        const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        touchAction.setEasingFunction(easingFunction);\r\n        releaseAction.setEasingFunction(easingFunction);\r\n        hydrateAction.setEasingFunction(easingFunction);\r\n        dehydrateAction.setEasingFunction(easingFunction);\r\n\r\n        touchAction.setKeys(touchKeys);\r\n        releaseAction.setKeys(releaseKeys);\r\n        hydrateAction.setKeys(hydrateKeys);\r\n        dehydrateAction.setKeys(dehydrateKeys);\r\n\r\n        const touchCollisionMeshFunction = (isTouch: boolean) => {\r\n            const action = isTouch ? touchAction : releaseAction;\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\r\n        };\r\n\r\n        const hydrateCollisionMeshFunction = (isHydration: boolean) => {\r\n            const action = isHydration ? hydrateAction : dehydrateAction;\r\n            if (isHydration) {\r\n                touchCollisionMesh.isVisible = true;\r\n            }\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\r\n                if (!isHydration) {\r\n                    touchCollisionMesh.isVisible = false;\r\n                }\r\n            });\r\n        };\r\n\r\n        return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };\r\n    }\r\n\r\n    private _pickWithSphere(controllerData: ControllerData, radius: number, sceneToUse: Scene, predicate: (mesh: AbstractMesh) => boolean): Nullable<PickingInfo> {\r\n        const pickingInfo = new PickingInfo();\r\n        pickingInfo.distance = +Infinity;\r\n\r\n        if (controllerData.touchCollisionMesh && controllerData.xrController) {\r\n            const position = controllerData.touchCollisionMesh.position;\r\n            const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\r\n\r\n            for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\r\n                const mesh = sceneToUse.meshes[meshIndex];\r\n                if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\r\n                    continue;\r\n                }\r\n                const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\r\n\r\n                if (result && result.hit && result.distance < pickingInfo.distance) {\r\n                    pickingInfo.hit = result.hit;\r\n                    pickingInfo.pickedMesh = mesh;\r\n                    pickingInfo.pickedPoint = result.pickedPoint;\r\n                    pickingInfo.aimTransform = controllerData.xrController.pointer;\r\n                    pickingInfo.gripTransform = controllerData.xrController.grip || null;\r\n                    pickingInfo.originMesh = controllerData.touchCollisionMesh;\r\n                    pickingInfo.distance = result.distance;\r\n                }\r\n            }\r\n        }\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Picks a mesh with a sphere\r\n     * @param mesh the mesh to pick\r\n     * @param sphere picking sphere in world coordinates\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     */\r\n    public static PickMeshWithSphere(mesh: AbstractMesh, sphere: BoundingSphere, skipBoundingInfo = false): PickingInfo {\r\n        const subMeshes = mesh.subMeshes;\r\n        const pi = new PickingInfo();\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (!mesh._generatePointsArray()) {\r\n            return pi;\r\n        }\r\n\r\n        if (!mesh.subMeshes || !boundingInfo) {\r\n            return pi;\r\n        }\r\n\r\n        if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\r\n            return pi;\r\n        }\r\n\r\n        const result = TmpVectors.Vector3[0];\r\n        const tmpVec = TmpVectors.Vector3[1];\r\n\r\n        let distance = +Infinity;\r\n        let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter;\r\n        const center = TmpVectors.Vector3[2];\r\n        const worldToMesh = TmpVectors.Matrix[0];\r\n        worldToMesh.copyFrom(mesh.getWorldMatrix());\r\n        worldToMesh.invert();\r\n        Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\r\n\r\n        for (let index = 0; index < subMeshes.length; index++) {\r\n            const subMesh = subMeshes[index];\r\n\r\n            subMesh.projectToRef(center, <Vector3[]>mesh._positions, <IndicesArray>mesh.getIndices(), tmpVec);\r\n\r\n            Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\r\n            tmp = Vector3.Distance(tmpVec, sphere.center);\r\n\r\n            // Check for finger inside of mesh\r\n            tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\r\n            tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\r\n            if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\r\n                tmp = 0;\r\n                tmpVec.copyFrom(sphere.center);\r\n            }\r\n\r\n            if (tmp !== -1 && tmp < distance) {\r\n                distance = tmp;\r\n                result.copyFrom(tmpVec);\r\n            }\r\n        }\r\n\r\n        if (distance < sphere.radius) {\r\n            pi.hit = true;\r\n            pi.distance = distance;\r\n            pi.pickedMesh = mesh;\r\n            pi.pickedPoint = result.clone();\r\n        }\r\n\r\n        return pi;\r\n    }\r\n}\r\n\r\n//Register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRNearInteraction.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRNearInteraction(xrSessionManager, options);\r\n    },\r\n    WebXRNearInteraction.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}