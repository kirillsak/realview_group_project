{"ast":null,"code":"import { WebXRFeatureName } from \"../../XR/webXRFeaturesManager.js\";\nimport { WebXRHandJoint } from \"../../XR/features/WebXRHandTracking.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Zones around the hand\n */\nexport var HandConstraintZone;\n(function (HandConstraintZone) {\n  /**\n   * Above finger tips\n   */\n  HandConstraintZone[HandConstraintZone[\"ABOVE_FINGER_TIPS\"] = 0] = \"ABOVE_FINGER_TIPS\";\n  /**\n   * Next to the thumb\n   */\n  HandConstraintZone[HandConstraintZone[\"RADIAL_SIDE\"] = 1] = \"RADIAL_SIDE\";\n  /**\n   * Next to the pinky finger\n   */\n  HandConstraintZone[HandConstraintZone[\"ULNAR_SIDE\"] = 2] = \"ULNAR_SIDE\";\n  /**\n   * Below the wrist\n   */\n  HandConstraintZone[HandConstraintZone[\"BELOW_WRIST\"] = 3] = \"BELOW_WRIST\";\n})(HandConstraintZone || (HandConstraintZone = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\nexport var HandConstraintOrientation;\n(function (HandConstraintOrientation) {\n  /**\n   * Orientation is towards the camera\n   */\n  HandConstraintOrientation[HandConstraintOrientation[\"LOOK_AT_CAMERA\"] = 0] = \"LOOK_AT_CAMERA\";\n  /**\n   * Orientation is determined by the rotation of the palm\n   */\n  HandConstraintOrientation[HandConstraintOrientation[\"HAND_ROTATION\"] = 1] = \"HAND_ROTATION\";\n})(HandConstraintOrientation || (HandConstraintOrientation = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\nexport var HandConstraintVisibility;\n(function (HandConstraintVisibility) {\n  /**\n   * Constraint is always visible\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"ALWAYS_VISIBLE\"] = 0] = \"ALWAYS_VISIBLE\";\n  /**\n   * Constraint is only visible when the palm is up\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_UP\"] = 1] = \"PALM_UP\";\n  /**\n   * Constraint is only visible when the user is looking at the constraint.\n   * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"GAZE_FOCUS\"] = 2] = \"GAZE_FOCUS\";\n  /**\n   * Constraint is only visible when the palm is up and the user is looking at it\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_AND_GAZE\"] = 3] = \"PALM_AND_GAZE\";\n})(HandConstraintVisibility || (HandConstraintVisibility = {}));\n/**\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\n * @since 5.0.0\n */\nexport class HandConstraintBehavior {\n  /**\n   * Builds a hand constraint behavior\n   */\n  constructor() {\n    this._sceneRenderObserver = null;\n    this._zoneAxis = {};\n    /**\n     * Sets the HandConstraintVisibility level for the hand constraint\n     */\n    this.handConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\n    /**\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\n     * Used with HandConstraintVisibility.PALM_UP\n     */\n    this.palmUpStrictness = 0.95;\n    /**\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\n     * Used with HandConstraintVisibility.GAZE_FOCUS\n     */\n    this.gazeProximityRadius = 0.15;\n    /**\n     * Offset distance from the hand in meters\n     */\n    this.targetOffset = 0.1;\n    /**\n     * Where to place the node regarding the center of the hand.\n     */\n    this.targetZone = HandConstraintZone.ULNAR_SIDE;\n    /**\n     * Orientation mode of the 4 zones around the hand\n     */\n    this.zoneOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Orientation mode of the node attached to this behavior\n     */\n    this.nodeOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\n     */\n    this.handedness = \"none\";\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 100;\n    // For a right hand\n    this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\n    this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\n    this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\n    this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\n  }\n  /** gets or sets behavior's name */\n  get name() {\n    return \"HandConstraint\";\n  }\n  /** Enable the behavior */\n  enable() {\n    this._node.setEnabled(true);\n  }\n  /** Disable the behavior */\n  disable() {\n    this._node.setEnabled(false);\n  }\n  _getHandPose() {\n    if (!this._handTracking) {\n      return null;\n    }\n    // Retrieve any available hand, starting by the left\n    let hand;\n    if (this.handedness === \"none\") {\n      hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\n    } else {\n      hand = this._handTracking.getHandByHandedness(this.handedness);\n    }\n    if (hand) {\n      const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);\n      const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);\n      const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);\n      if (wrist && middleMetacarpal && pinkyMetacarpal) {\n        const handPose = {\n          position: middleMetacarpal.absolutePosition,\n          quaternion: new Quaternion(),\n          id: hand.xrController.uniqueId\n        };\n        // palm forward\n        const up = TmpVectors.Vector3[0];\n        const forward = TmpVectors.Vector3[1];\n        const left = TmpVectors.Vector3[2];\n        up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\n        forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\n        // Create vectors for a rotation quaternion, where forward points out from the palm\n        Vector3.CrossToRef(up, forward, forward);\n        Vector3.CrossToRef(forward, up, left);\n        Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\n        return handPose;\n      }\n    }\n    return null;\n  }\n  /**\n   * Initializes the hand constraint behavior\n   */\n  init() {}\n  /**\n   * Attaches the hand constraint to a `TransformNode`\n   * @param node defines the node to attach the behavior to\n   */\n  attach(node) {\n    this._node = node;\n    this._scene = node.getScene();\n    if (!this._node.rotationQuaternion) {\n      this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\n    }\n    let lastTick = Date.now();\n    this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n      const pose = this._getHandPose();\n      this._node.reservedDataStore = this._node.reservedDataStore || {};\n      this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\n      this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\n      if (pose) {\n        const zoneOffset = TmpVectors.Vector3[0];\n        const camera = this._scene.activeCamera;\n        zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\n        const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\n        if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\n          const toCamera = TmpVectors.Vector3[1];\n          toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\n          if (this._scene.useRightHandedSystem) {\n            Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          } else {\n            Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          }\n        }\n        if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        } else {\n          cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        }\n        Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\n        zoneOffset.scaleInPlace(this.targetOffset);\n        const targetPosition = TmpVectors.Vector3[2];\n        const targetRotation = TmpVectors.Quaternion[1];\n        targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\n        if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          targetRotation.copyFrom(pose.quaternion);\n        } else {\n          targetRotation.copyFrom(cameraLookAtQuaternion);\n        }\n        const elapsed = Date.now() - lastTick;\n        Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\n        Quaternion.SmoothToRef(this._node.rotationQuaternion, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion);\n        this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\n      }\n      this._setVisibility(pose);\n      lastTick = Date.now();\n    });\n  }\n  _setVisibility(pose) {\n    let palmVisible = true;\n    let gazeVisible = true;\n    const camera = this._scene.activeCamera;\n    if (camera) {\n      const cameraForward = camera.getForwardRay();\n      if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        gazeVisible = false;\n        let gaze;\n        if (this._eyeTracking) {\n          gaze = this._eyeTracking.getEyeGaze();\n        }\n        gaze = gaze || cameraForward;\n        const gazeToBehavior = TmpVectors.Vector3[0];\n        if (pose) {\n          pose.position.subtractToRef(gaze.origin, gazeToBehavior);\n        } else {\n          this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\n        }\n        const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\n        const projectedSquared = projectedDistance * projectedDistance;\n        if (projectedDistance > 0) {\n          const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\n          if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\n            gazeVisible = true;\n          }\n        }\n      }\n      if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        palmVisible = false;\n        if (pose) {\n          const palmDirection = TmpVectors.Vector3[0];\n          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\n          if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\n            palmVisible = true;\n          }\n        }\n      }\n    }\n    this._node.setEnabled(palmVisible && gazeVisible);\n  }\n  /**\n   * Detaches the behavior from the `TransformNode`\n   */\n  detach() {\n    this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n  }\n  /**\n   * Links the behavior to the XR experience in which to retrieve hand transform information.\n   * @param xr xr experience\n   */\n  linkToXRExperience(xr) {\n    const featuresManager = xr.featuresManager ? xr.featuresManager : xr;\n    if (!featuresManager) {\n      Tools.Error(\"XR features manager must be available or provided directly for the Hand Menu to work\");\n    } else {\n      try {\n        this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);\n      } catch (_a) {}\n      try {\n        this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);\n      } catch (_b) {\n        Tools.Error(\"Hand tracking must be enabled for the Hand Menu to work\");\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["WebXRFeatureName","WebXRHandJoint","Quaternion","TmpVectors","Vector3","Tools","HandConstraintZone","HandConstraintOrientation","HandConstraintVisibility","HandConstraintBehavior","constructor","PALM_AND_GAZE","ULNAR_SIDE","HAND_ROTATION","_zoneAxis","ABOVE_FINGER_TIPS","RADIAL_SIDE","BELOW_WRIST","name","enable","_node","setEnabled","disable","_getHandPose","_handTracking","hand","handedness","getHandByHandedness","pinkyMetacarpal","getJointMesh","PINKY_FINGER_METACARPAL","middleMetacarpal","MIDDLE_FINGER_METACARPAL","wrist","WRIST","handPose","position","absolutePosition","quaternion","id","xrController","uniqueId","up","forward","left","copyFrom","subtractInPlace","normalize","CrossToRef","FromLookDirectionLHToRef","init","attach","node","_scene","getScene","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","lastTick","Date","now","_sceneRenderObserver","onBeforeRenderObservable","add","pose","reservedDataStore","nearInteraction","excludedControllerId","zoneOffset","camera","activeCamera","targetZone","cameraLookAtQuaternion","zoneOrientationMode","LOOK_AT_CAMERA","nodeOrientationMode","toCamera","useRightHandedSystem","FromLookDirectionRHToRef","UpReadOnly","toRotationMatrix","Matrix","TransformNormalToRef","scaleInPlace","targetOffset","targetPosition","targetRotation","addInPlace","elapsed","SmoothToRef","lerpTime","_setVisibility","palmVisible","gazeVisible","cameraForward","getForwardRay","handConstraintVisibility","GAZE_FOCUS","gaze","_eyeTracking","getEyeGaze","gazeToBehavior","subtractToRef","origin","getAbsolutePosition","projectedDistance","Dot","direction","projectedSquared","radiusSquared","lengthSquared","gazeProximityRadius","PALM_UP","palmDirection","LeftHandedForwardReadOnly","rotateByQuaternionToRef","palmUpStrictness","detach","remove","linkToXRExperience","xr","featuresManager","Error","getEnabledFeature","EYE_TRACKING","HAND_TRACKING"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Meshes/handConstraintBehavior.ts"],"sourcesContent":["import type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXRFeaturesManager } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXREyeTracking } from \"../../XR/features/WebXREyeTracking\";\r\nimport type { WebXRHandTracking } from \"../../XR/features/WebXRHandTracking\";\r\nimport { WebXRHandJoint } from \"../../XR/features/WebXRHandTracking\";\r\nimport type { WebXRExperienceHelper } from \"../../XR/webXRExperienceHelper\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Zones around the hand\r\n */\r\nexport enum HandConstraintZone {\r\n    /**\r\n     * Above finger tips\r\n     */\r\n    ABOVE_FINGER_TIPS,\r\n    /**\r\n     * Next to the thumb\r\n     */\r\n    RADIAL_SIDE,\r\n    /**\r\n     * Next to the pinky finger\r\n     */\r\n    ULNAR_SIDE,\r\n    /**\r\n     * Below the wrist\r\n     */\r\n    BELOW_WRIST,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintOrientation {\r\n    /**\r\n     * Orientation is towards the camera\r\n     */\r\n    LOOK_AT_CAMERA,\r\n    /**\r\n     * Orientation is determined by the rotation of the palm\r\n     */\r\n    HAND_ROTATION,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport enum HandConstraintVisibility {\r\n    /**\r\n     * Constraint is always visible\r\n     */\r\n    ALWAYS_VISIBLE,\r\n    /**\r\n     * Constraint is only visible when the palm is up\r\n     */\r\n    PALM_UP,\r\n    /**\r\n     * Constraint is only visible when the user is looking at the constraint.\r\n     * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\r\n     */\r\n    GAZE_FOCUS,\r\n    /**\r\n     * Constraint is only visible when the palm is up and the user is looking at it\r\n     */\r\n    PALM_AND_GAZE,\r\n}\r\n\r\ntype HandPoseInfo = {\r\n    position: Vector3;\r\n    quaternion: Quaternion;\r\n    id: string;\r\n};\r\n\r\n/**\r\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\r\n * @since 5.0.0\r\n */\r\nexport class HandConstraintBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n    private _node: TransformNode;\r\n    private _eyeTracking: Nullable<WebXREyeTracking>;\r\n    private _handTracking: Nullable<WebXRHandTracking>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _zoneAxis: { [id: number]: Vector3 } = {};\r\n\r\n    /**\r\n     * Sets the HandConstraintVisibility level for the hand constraint\r\n     */\r\n    public handConstraintVisibility: HandConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\r\n\r\n    /**\r\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\r\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\r\n     * Used with HandConstraintVisibility.PALM_UP\r\n     */\r\n    public palmUpStrictness: number = 0.95;\r\n\r\n    /**\r\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\r\n     * Used with HandConstraintVisibility.GAZE_FOCUS\r\n     */\r\n    public gazeProximityRadius: number = 0.15;\r\n\r\n    /**\r\n     * Offset distance from the hand in meters\r\n     */\r\n    public targetOffset: number = 0.1;\r\n\r\n    /**\r\n     * Where to place the node regarding the center of the hand.\r\n     */\r\n    public targetZone: HandConstraintZone = HandConstraintZone.ULNAR_SIDE;\r\n\r\n    /**\r\n     * Orientation mode of the 4 zones around the hand\r\n     */\r\n    public zoneOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n    /**\r\n     * Orientation mode of the node attached to this behavior\r\n     */\r\n    public nodeOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n\r\n    /**\r\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\r\n     */\r\n    public handedness: XRHandedness = \"none\";\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 100;\r\n\r\n    /**\r\n     * Builds a hand constraint behavior\r\n     */\r\n    constructor() {\r\n        // For a right hand\r\n        this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\r\n        this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\r\n    }\r\n\r\n    /** gets or sets behavior's name */\r\n    public get name() {\r\n        return \"HandConstraint\";\r\n    }\r\n\r\n    /** Enable the behavior */\r\n    public enable() {\r\n        this._node.setEnabled(true);\r\n    }\r\n\r\n    /** Disable the behavior */\r\n    public disable() {\r\n        this._node.setEnabled(false);\r\n    }\r\n\r\n    private _getHandPose(): Nullable<HandPoseInfo> {\r\n        if (!this._handTracking) {\r\n            return null;\r\n        }\r\n\r\n        // Retrieve any available hand, starting by the left\r\n        let hand;\r\n        if (this.handedness === \"none\") {\r\n            hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\r\n        } else {\r\n            hand = this._handTracking.getHandByHandedness(this.handedness);\r\n        }\r\n\r\n        if (hand) {\r\n            const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);\r\n            const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);\r\n            const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);\r\n\r\n            if (wrist && middleMetacarpal && pinkyMetacarpal) {\r\n                const handPose: HandPoseInfo = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };\r\n\r\n                // palm forward\r\n                const up = TmpVectors.Vector3[0];\r\n                const forward = TmpVectors.Vector3[1];\r\n                const left = TmpVectors.Vector3[2];\r\n                up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\r\n                forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\r\n\r\n                // Create vectors for a rotation quaternion, where forward points out from the palm\r\n                Vector3.CrossToRef(up, forward, forward);\r\n                Vector3.CrossToRef(forward, up, left);\r\n\r\n                Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\r\n\r\n                return handPose;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Initializes the hand constraint behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the hand constraint to a `TransformNode`\r\n     * @param node defines the node to attach the behavior to\r\n     */\r\n    public attach(node: TransformNode): void {\r\n        this._node = node;\r\n        this._scene = node.getScene();\r\n\r\n        if (!this._node.rotationQuaternion) {\r\n            this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\r\n        }\r\n\r\n        let lastTick = Date.now();\r\n        this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            const pose = this._getHandPose();\r\n\r\n            this._node.reservedDataStore = this._node.reservedDataStore || {};\r\n            this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\r\n            this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\r\n\r\n            if (pose) {\r\n                const zoneOffset = TmpVectors.Vector3[0];\r\n                const camera = this._scene.activeCamera;\r\n\r\n                zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\r\n\r\n                const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\r\n                if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\r\n                    const toCamera = TmpVectors.Vector3[1];\r\n                    toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\r\n                    if (this._scene.useRightHandedSystem) {\r\n                        Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    } else {\r\n                        Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    }\r\n                }\r\n\r\n                if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                } else {\r\n                    cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                }\r\n\r\n                Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\r\n                zoneOffset.scaleInPlace(this.targetOffset);\r\n\r\n                const targetPosition = TmpVectors.Vector3[2];\r\n                const targetRotation = TmpVectors.Quaternion[1];\r\n                targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\r\n\r\n                if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    targetRotation.copyFrom(pose.quaternion);\r\n                } else {\r\n                    targetRotation.copyFrom(cameraLookAtQuaternion);\r\n                }\r\n\r\n                const elapsed = Date.now() - lastTick;\r\n\r\n                Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\r\n                Quaternion.SmoothToRef(this._node.rotationQuaternion!, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion!);\r\n\r\n                this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\r\n            }\r\n\r\n            this._setVisibility(pose);\r\n\r\n            lastTick = Date.now();\r\n        });\r\n    }\r\n\r\n    private _setVisibility(pose: Nullable<HandPoseInfo>) {\r\n        let palmVisible = true;\r\n        let gazeVisible = true;\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            const cameraForward = camera.getForwardRay();\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                gazeVisible = false;\r\n                let gaze: Ray | undefined;\r\n                if (this._eyeTracking) {\r\n                    gaze = this._eyeTracking.getEyeGaze()!;\r\n                }\r\n\r\n                gaze = gaze || cameraForward;\r\n\r\n                const gazeToBehavior = TmpVectors.Vector3[0];\r\n                if (pose) {\r\n                    pose.position.subtractToRef(gaze.origin, gazeToBehavior);\r\n                } else {\r\n                    this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\r\n                }\r\n\r\n                const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\r\n                const projectedSquared = projectedDistance * projectedDistance;\r\n\r\n                if (projectedDistance > 0) {\r\n                    const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\r\n                    if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\r\n                        gazeVisible = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                palmVisible = false;\r\n\r\n                if (pose) {\r\n                    const palmDirection = TmpVectors.Vector3[0];\r\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\r\n\r\n                    if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\r\n                        palmVisible = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._node.setEnabled(palmVisible && gazeVisible);\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the `TransformNode`\r\n     */\r\n    public detach(): void {\r\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n    }\r\n\r\n    /**\r\n     * Links the behavior to the XR experience in which to retrieve hand transform information.\r\n     * @param xr xr experience\r\n     */\r\n    public linkToXRExperience(xr: WebXRExperienceHelper | WebXRFeaturesManager) {\r\n        const featuresManager: WebXRFeaturesManager = (xr as WebXRExperienceHelper).featuresManager ? (xr as WebXRExperienceHelper).featuresManager : (xr as WebXRFeaturesManager);\r\n        if (!featuresManager) {\r\n            Tools.Error(\"XR features manager must be available or provided directly for the Hand Menu to work\");\r\n        } else {\r\n            try {\r\n                this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING) as WebXREyeTracking;\r\n            } catch {}\r\n\r\n            try {\r\n                this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING) as WebXRHandTracking;\r\n            } catch {\r\n                Tools.Error(\"Hand tracking must be enabled for the Hand Menu to work\");\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}