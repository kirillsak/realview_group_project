{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\nimport { Material } from \"../../../Materials/material.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture.js\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent.js\";\nimport \"../../../Engines/Extensions/engine.renderTarget.js\";\nimport \"../../../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../../../Shaders/procedural.vertex.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { DrawWrapper } from \"../../drawWrapper.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\n * This is the base class of any Procedural texture and contains most of the shareable code.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n */\nexport class ProceduralTexture extends Texture {\n  /**\n   * Instantiates a new procedural texture.\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n   * This is the base class of any Procedural texture and contains most of the shareable code.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n   * @param name  Define the name of the texture\n   * @param size Define the size of the texture to create\n   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\n   * @param scene Define the scene the texture belongs to\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n   * @param generateMipMaps Define if the texture should creates mip maps or not\n   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\n   * @param textureType The FBO internal texture type\n   */\n  constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {\n    super(null, scene, !generateMipMaps);\n    /**\n     * Define if the texture is enabled or not (disabled texture will not render)\n     */\n    this.isEnabled = true;\n    /**\n     * Define if the texture must be cleared before rendering (default is true)\n     */\n    this.autoClear = true;\n    /**\n     * Event raised when the texture is generated\n     */\n    this.onGeneratedObservable = new Observable();\n    /**\n     * Event raised before the texture is generated\n     */\n    this.onBeforeGenerationObservable = new Observable();\n    /**\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\n     */\n    this.nodeMaterialSource = null;\n    /** @internal */\n    this._textures = {};\n    this._currentRefreshId = -1;\n    this._frameId = -1;\n    this._refreshRate = 1;\n    this._vertexBuffers = {};\n    this._uniforms = new Array();\n    this._samplers = new Array();\n    this._floats = {};\n    this._ints = {};\n    this._floatsArrays = {};\n    this._colors3 = {};\n    this._colors4 = {};\n    this._vectors2 = {};\n    this._vectors3 = {};\n    this._matrices = {};\n    this._fallbackTextureUsed = false;\n    this._cachedDefines = null;\n    this._contentUpdateId = -1;\n    this._rtWrapper = null;\n    scene = this.getScene() || EngineStore.LastCreatedScene;\n    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n    if (!component) {\n      component = new ProceduralTextureSceneComponent(scene);\n      scene._addComponent(component);\n    }\n    scene.proceduralTextures.push(this);\n    this._fullEngine = scene.getEngine();\n    this.name = name;\n    this.isRenderTarget = true;\n    this._size = size;\n    this._textureType = textureType;\n    this._generateMipMaps = generateMipMaps;\n    this._drawWrapper = new DrawWrapper(this._fullEngine);\n    this.setFragment(fragment);\n    this._fallbackTexture = fallbackTexture;\n    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\n    this._texture = rtWrapper.texture;\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._createIndexBuffer();\n  }\n  _createRtWrapper(isCube, size, generateMipMaps, textureType) {\n    if (isCube) {\n      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n      this.setFloat(\"face\", 0);\n    } else {\n      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n    }\n    return this._rtWrapper;\n  }\n  /**\n   * The effect that is created when initializing the post process.\n   * @returns The created effect corresponding the the postprocess.\n   */\n  getEffect() {\n    return this._drawWrapper.effect;\n  }\n  /**\n   * @internal*\n   */\n  _setEffect(effect) {\n    this._drawWrapper.effect = effect;\n  }\n  /**\n   * Gets texture content (Use this function wisely as reading from a texture can be slow)\n   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\n   */\n  getContent() {\n    if (this._contentData && this._frameId === this._contentUpdateId) {\n      return this._contentData;\n    }\n    if (this._contentData) {\n      this._contentData.then(buffer => {\n        this._contentData = this.readPixels(0, 0, buffer);\n        this._contentUpdateId = this._frameId;\n      });\n    } else {\n      this._contentData = this.readPixels(0, 0);\n      this._contentUpdateId = this._frameId;\n    }\n    return this._contentData;\n  }\n  _createIndexBuffer() {\n    const engine = this._fullEngine;\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  }\n  /** @internal */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n  }\n  /**\n   * Resets the texture in order to recreate its associated resources.\n   * This can be called in case of context loss\n   */\n  reset() {\n    var _a;\n    (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n  _getDefines() {\n    return \"\";\n  }\n  /**\n   * Is the texture ready to be used ? (rendered at least once)\n   * @returns true if ready, otherwise, false.\n   */\n  isReady() {\n    const engine = this._fullEngine;\n    let shaders;\n    if (this.nodeMaterialSource) {\n      return this._drawWrapper.effect.isReady();\n    }\n    if (!this._fragment) {\n      return false;\n    }\n    if (this._fallbackTextureUsed) {\n      return true;\n    }\n    if (!this._texture) {\n      return false;\n    }\n    const defines = this._getDefines();\n    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\n      return true;\n    }\n    if (this._fragment.fragmentElement !== undefined) {\n      shaders = {\n        vertex: \"procedural\",\n        fragmentElement: this._fragment.fragmentElement\n      };\n    } else {\n      shaders = {\n        vertex: \"procedural\",\n        fragment: this._fragment\n      };\n    }\n    if (this._cachedDefines !== defines) {\n      this._cachedDefines = defines;\n      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\n        var _a;\n        (_a = this._rtWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._rtWrapper = this._texture = null;\n        if (this._fallbackTexture) {\n          this._texture = this._fallbackTexture._texture;\n          if (this._texture) {\n            this._texture.incrementReferences();\n          }\n        }\n        this._fallbackTextureUsed = true;\n      });\n    }\n    return this._drawWrapper.effect.isReady();\n  }\n  /**\n   * Resets the refresh counter of the texture and start bak from scratch.\n   * Could be useful to regenerate the texture if it is setup to render only once.\n   */\n  resetRefreshCounter() {\n    this._currentRefreshId = -1;\n  }\n  /**\n   * Set the fragment shader to use in order to render the texture.\n   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\n   */\n  setFragment(fragment) {\n    this._fragment = fragment;\n  }\n  /**\n   * Define the refresh rate of the texture or the rendering frequency.\n   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n   */\n  get refreshRate() {\n    return this._refreshRate;\n  }\n  set refreshRate(value) {\n    this._refreshRate = value;\n    this.resetRefreshCounter();\n  }\n  /** @internal */\n  _shouldRender() {\n    if (!this.isEnabled || !this.isReady() || !this._texture) {\n      if (this._texture) {\n        this._texture.isReady = false;\n      }\n      return false;\n    }\n    if (this._fallbackTextureUsed) {\n      return false;\n    }\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n    this._currentRefreshId++;\n    return false;\n  }\n  /**\n   * Get the size the texture is rendering at.\n   * @returns the size (on cube texture it is always squared)\n   */\n  getRenderSize() {\n    return this._size;\n  }\n  /**\n   * Resize the texture to new value.\n   * @param size Define the new size the texture should have\n   * @param generateMipMaps Define whether the new texture should create mip maps\n   */\n  resize(size, generateMipMaps) {\n    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\n      return;\n    }\n    const isCube = this._texture.isCube;\n    this._rtWrapper.dispose();\n    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\n    this._texture = rtWrapper.texture;\n    // Update properties\n    this._size = size;\n    this._generateMipMaps = generateMipMaps;\n  }\n  _checkUniform(uniformName) {\n    if (this._uniforms.indexOf(uniformName) === -1) {\n      this._uniforms.push(uniformName);\n    }\n  }\n  /**\n   * Set a texture in the shader program used to render.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setTexture(name, texture) {\n    if (this._samplers.indexOf(name) === -1) {\n      this._samplers.push(name);\n    }\n    this._textures[name] = texture;\n    return this;\n  }\n  /**\n   * Set a float in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setFloat(name, value) {\n    this._checkUniform(name);\n    this._floats[name] = value;\n    return this;\n  }\n  /**\n   * Set a int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setInt(name, value) {\n    this._checkUniform(name);\n    this._ints[name] = value;\n    return this;\n  }\n  /**\n   * Set an array of floats in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setFloats(name, value) {\n    this._checkUniform(name);\n    this._floatsArrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Color3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setColor3(name, value) {\n    this._checkUniform(name);\n    this._colors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Color4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setColor4(name, value) {\n    this._checkUniform(name);\n    this._colors4[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec2 in the shader from a Vector2.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setVector2(name, value) {\n    this._checkUniform(name);\n    this._vectors2[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Vector3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setVector3(name, value) {\n    this._checkUniform(name);\n    this._vectors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a mat4 in the shader from a MAtrix.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix(name, value) {\n    this._checkUniform(name);\n    this._matrices[name] = value;\n    return this;\n  }\n  /**\n   * Render the texture to its associated render target.\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(useCameraPostProcess) {\n    var _a, _b;\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const engine = this._fullEngine;\n    // Render\n    engine.enableEffect(this._drawWrapper);\n    this.onBeforeGenerationObservable.notifyObservers(this);\n    engine.setState(false);\n    if (!this.nodeMaterialSource) {\n      // Texture\n      for (const name in this._textures) {\n        this._drawWrapper.effect.setTexture(name, this._textures[name]);\n      }\n      // Float\n      for (const name in this._ints) {\n        this._drawWrapper.effect.setInt(name, this._ints[name]);\n      }\n      // Float\n      for (const name in this._floats) {\n        this._drawWrapper.effect.setFloat(name, this._floats[name]);\n      }\n      // Floats\n      for (const name in this._floatsArrays) {\n        this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);\n      }\n      // Color3\n      for (const name in this._colors3) {\n        this._drawWrapper.effect.setColor3(name, this._colors3[name]);\n      }\n      // Color4\n      for (const name in this._colors4) {\n        const color = this._colors4[name];\n        this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      }\n      // Vector2\n      for (const name in this._vectors2) {\n        this._drawWrapper.effect.setVector2(name, this._vectors2[name]);\n      }\n      // Vector3\n      for (const name in this._vectors3) {\n        this._drawWrapper.effect.setVector3(name, this._vectors3[name]);\n      }\n      // Matrix\n      for (const name in this._matrices) {\n        this._drawWrapper.effect.setMatrix(name, this._matrices[name]);\n      }\n    }\n    if (!this._texture || !this._rtWrapper) {\n      return;\n    }\n    (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `procedural texture generation for ${this.name}`, 1);\n    const viewPort = engine.currentViewport;\n    if (this.isCube) {\n      for (let face = 0; face < 6; face++) {\n        engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\n        // VBOs\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n        this._drawWrapper.effect.setFloat(\"face\", face);\n        // Clear\n        if (this.autoClear) {\n          engine.clear(scene.clearColor, true, false, false);\n        }\n        // Draw order\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      }\n    } else {\n      engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n      // Clear\n      if (this.autoClear) {\n        engine.clear(scene.clearColor, true, false, false);\n      }\n      // Draw order\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    // Unbind and restore viewport\n    engine.unBindFramebuffer(this._rtWrapper, this.isCube);\n    if (viewPort) {\n      engine.setViewport(viewPort);\n    }\n    // Mipmaps\n    if (this.isCube) {\n      engine.generateMipMapsForCubemap(this._texture);\n    }\n    (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n    if (this.onGenerated) {\n      this.onGenerated();\n    }\n    this.onGeneratedObservable.notifyObservers(this);\n  }\n  /**\n   * Clone the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    const textureSize = this.getSize();\n    const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);\n    // Base texture\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level;\n    // RenderTarget Texture\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const index = scene.proceduralTextures.indexOf(this);\n    if (index >= 0) {\n      scene.proceduralTextures.splice(index, 1);\n    }\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n      this._indexBuffer = null;\n    }\n    this.onGeneratedObservable.clear();\n    this.onBeforeGenerationObservable.clear();\n    super.dispose();\n  }\n}\n__decorate([serialize()], ProceduralTexture.prototype, \"isEnabled\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"autoClear\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"_size\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"refreshRate\", null);\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);","map":{"version":3,"mappings":"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","names":["serialize","Observable","VertexBuffer","SceneComponentConstants","Material","Texture","RenderTargetTexture","ProceduralTextureSceneComponent","RegisterClass","EngineStore","DrawWrapper","ProceduralTexture","constructor","name","size","fragment","scene","fallbackTexture","generateMipMaps","isCube","textureType","Array","getScene","LastCreatedScene","component","_getComponent","NAME_PROCEDURALTEXTURE","_addComponent","proceduralTextures","push","_fullEngine","getEngine","isRenderTarget","_size","_textureType","_generateMipMaps","_drawWrapper","setFragment","_fallbackTexture","rtWrapper","_createRtWrapper","_texture","texture","vertices","_vertexBuffers","PositionKind","_createIndexBuffer","_rtWrapper","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","type","setFloat","createRenderTargetTexture","getEffect","effect","_setEffect","getContent","_contentData","_frameId","_contentUpdateId","then","buffer","readPixels","engine","indices","_indexBuffer","createIndexBuffer","_rebuild","vb","refreshRate","REFRESHRATE_RENDER_ONCE","reset","dispose","_getDefines","isReady","shaders","nodeMaterialSource","_fragment","_fallbackTextureUsed","defines","_cachedDefines","fragmentElement","undefined","vertex","createEffect","_uniforms","_samplers","incrementReferences","resetRefreshCounter","_currentRefreshId","_refreshRate","value","_shouldRender","isEnabled","getRenderSize","resize","_checkUniform","uniformName","indexOf","setTexture","_textures","_floats","setInt","_ints","setFloats","_floatsArrays","setColor3","_colors3","setColor4","_colors4","setVector2","_vectors2","setVector3","_vectors3","setMatrix","_matrices","render","useCameraPostProcess","enableEffect","onBeforeGenerationObservable","notifyObservers","setState","setArray","color","setFloat4","r","g","b","a","_debugPushGroup","viewPort","currentViewport","face","bindFramebuffer","bindBuffers","autoClear","clear","clearColor","drawElementsType","TriangleFillMode","unBindFramebuffer","setViewport","generateMipMapsForCubemap","_debugPopGroup","onGenerated","onGeneratedObservable","clone","textureSize","getSize","newTexture","width","hasAlpha","level","coordinatesMode","index","splice","vertexBuffer","_releaseBuffer","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/Procedurals/proceduralTexture.ts"],"sourcesContent":["import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport \"../../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../../../Shaders/procedural.vertex\";\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: Texture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: Engine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        this._fallbackTexture = fallbackTexture;\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal*\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n        let shaders;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        if (this._fragment.fragmentElement !== undefined) {\r\n            shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\r\n        } else {\r\n            shaders = { vertex: \"procedural\", fragment: this._fragment };\r\n        }\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\r\n                this._rtWrapper?.dispose();\r\n                this._rtWrapper = this._texture = null;\r\n\r\n                if (this._fallbackTexture) {\r\n                    this._texture = this._fallbackTexture._texture;\r\n\r\n                    if (this._texture) {\r\n                        this._texture.incrementReferences();\r\n                    }\r\n                }\r\n\r\n                this._fallbackTextureUsed = true;\r\n            });\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: Texture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            }\r\n        } else {\r\n            engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n            // Clear\r\n            if (this.autoClear) {\r\n                engine.clear(scene.clearColor, true, false, false);\r\n            }\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Unbind and restore viewport\r\n        engine.unBindFramebuffer(this._rtWrapper, this.isCube);\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}