{"ast":null,"code":"import { MultiRenderTarget } from \"./multiRenderTarget.js\";\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess.js\";\n/**\n * A multi render target designed to render the prepass.\n * Prepass is a scene component used to render information in multiple textures\n * alongside with the scene materials rendering.\n * Note : This is an internal class, and you should NOT need to instanciate this.\n * Only the `PrePassRenderer` should instanciate this class.\n * It is more likely that you need a regular `MultiRenderTarget`\n * @internal\n */\nexport class PrePassRenderTarget extends MultiRenderTarget {\n  constructor(name, renderTargetTexture, size, count, scene, options) {\n    super(name, size, count, scene, options);\n    /**\n     * @internal\n     */\n    this._beforeCompositionPostProcesses = [];\n    /**\n     * @internal\n     */\n    this._internalTextureDirty = false;\n    /**\n     * Is this render target enabled for prepass rendering\n     */\n    this.enabled = false;\n    /**\n     * Render target associated with this prePassRenderTarget\n     * If this is `null`, it means this prePassRenderTarget is associated with the scene\n     */\n    this.renderTargetTexture = null;\n    this.renderTargetTexture = renderTargetTexture;\n  }\n  /**\n   * Creates a composition effect for this RT\n   * @internal\n   */\n  _createCompositionEffect() {\n    this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"prePassComposition\", 1, null, undefined, this._engine);\n    this.imageProcessingPostProcess._updateParameters();\n  }\n  /**\n   * Checks that the size of this RT is still adapted to the desired render size.\n   * @internal\n   */\n  _checkSize() {\n    const requiredWidth = this._engine.getRenderWidth(true);\n    const requiredHeight = this._engine.getRenderHeight(true);\n    const width = this.getRenderWidth();\n    const height = this.getRenderHeight();\n    if (width !== requiredWidth || height !== requiredHeight) {\n      this.resize({\n        width: requiredWidth,\n        height: requiredHeight\n      });\n      this._internalTextureDirty = true;\n    }\n  }\n  /**\n   * Changes the number of render targets in this MRT\n   * Be careful as it will recreate all the data in the new texture.\n   * @param count new texture count\n   * @param options Specifies texture types and sampling modes for new textures\n   * @param textureNames Specifies the names of the textures (optional)\n   */\n  updateCount(count, options, textureNames) {\n    super.updateCount(count, options, textureNames);\n    this._internalTextureDirty = true;\n  }\n  /**\n   * Resets the post processes chains applied to this RT.\n   * @internal\n   */\n  _resetPostProcessChain() {\n    this._beforeCompositionPostProcesses.length = 0;\n  }\n  /**\n   * Diposes this render target\n   */\n  dispose() {\n    const scene = this._scene;\n    super.dispose();\n    if (scene && scene.prePassRenderer) {\n      const index = scene.prePassRenderer.renderTargets.indexOf(this);\n      if (index !== -1) {\n        scene.prePassRenderer.renderTargets.splice(index, 1);\n      }\n    }\n    if (this.imageProcessingPostProcess) {\n      this.imageProcessingPostProcess.dispose();\n    }\n    if (this.renderTargetTexture) {\n      this.renderTargetTexture._prePassRenderTarget = null;\n    }\n    if (this._outputPostProcess) {\n      this._outputPostProcess.autoClear = true;\n      this._outputPostProcess.restoreDefaultInputTexture();\n    }\n  }\n}","map":{"version":3,"mappings":"AACA,SAASA,iBAAiB,QAAQ,wBAAsB;AAKxD,SAASC,0BAA0B,QAAQ,mDAAiD;AAG5F;;;;;;;;;AASA,OAAM,MAAOC,mBAAoB,SAAQF,iBAAiB;EAyCtDG,YAAmBC,IAAY,EAAEC,mBAAkD,EAAEC,IAAS,EAAEC,KAAa,EAAEC,KAAa,EAAEC,OAA+C;IACzK,KAAK,CAACL,IAAI,EAAEE,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAEC,OAAO,CAAC;IAzC5C;;;IAGO,oCAA+B,GAAkB,EAAE;IAqB1D;;;IAGO,0BAAqB,GAAG,KAAK;IAEpC;;;IAGO,YAAO,GAAY,KAAK;IAE/B;;;;IAIO,wBAAmB,GAAkC,IAAI;IAK5D,IAAI,CAACJ,mBAAmB,GAAGA,mBAAmB;EAClD;EAEA;;;;EAIOK,wBAAwB;IAC3B,IAAI,CAACC,0BAA0B,GAAG,IAAIV,0BAA0B,CAAC,oBAAoB,EAAE,CAAC,EAAE,IAAI,EAAEW,SAAS,EAAE,IAAI,CAACC,OAAO,CAAC;IACxH,IAAI,CAACF,0BAA0B,CAACG,iBAAiB,EAAE;EACvD;EAEA;;;;EAIOC,UAAU;IACb,MAAMC,aAAa,GAAG,IAAI,CAACH,OAAO,CAACI,cAAc,CAAC,IAAI,CAAC;IACvD,MAAMC,cAAc,GAAG,IAAI,CAACL,OAAO,CAACM,eAAe,CAAC,IAAI,CAAC;IAEzD,MAAMC,KAAK,GAAG,IAAI,CAACH,cAAc,EAAE;IACnC,MAAMI,MAAM,GAAG,IAAI,CAACF,eAAe,EAAE;IAErC,IAAIC,KAAK,KAAKJ,aAAa,IAAIK,MAAM,KAAKH,cAAc,EAAE;MACtD,IAAI,CAACI,MAAM,CAAC;QAAEF,KAAK,EAAEJ,aAAa;QAAEK,MAAM,EAAEH;MAAc,CAAE,CAAC;MAE7D,IAAI,CAACK,qBAAqB,GAAG,IAAI;;EAEzC;EAEA;;;;;;;EAOOC,WAAW,CAACjB,KAAa,EAAEE,OAAmC,EAAEgB,YAAuB;IAC1F,KAAK,CAACD,WAAW,CAACjB,KAAK,EAAEE,OAAO,EAAEgB,YAAY,CAAC;IAC/C,IAAI,CAACF,qBAAqB,GAAG,IAAI;EACrC;EAEA;;;;EAIOG,sBAAsB;IACzB,IAAI,CAACC,+BAA+B,CAACC,MAAM,GAAG,CAAC;EACnD;EAEA;;;EAGOC,OAAO;IACV,MAAMrB,KAAK,GAAG,IAAI,CAACsB,MAAM;IAEzB,KAAK,CAACD,OAAO,EAAE;IAEf,IAAIrB,KAAK,IAAIA,KAAK,CAACuB,eAAe,EAAE;MAChC,MAAMC,KAAK,GAAGxB,KAAK,CAACuB,eAAe,CAACE,aAAa,CAACC,OAAO,CAAC,IAAI,CAAC;MAE/D,IAAIF,KAAK,KAAK,CAAC,CAAC,EAAE;QACdxB,KAAK,CAACuB,eAAe,CAACE,aAAa,CAACE,MAAM,CAACH,KAAK,EAAE,CAAC,CAAC;;;IAI5D,IAAI,IAAI,CAACrB,0BAA0B,EAAE;MACjC,IAAI,CAACA,0BAA0B,CAACkB,OAAO,EAAE;;IAG7C,IAAI,IAAI,CAACxB,mBAAmB,EAAE;MAC1B,IAAI,CAACA,mBAAmB,CAAC+B,oBAAoB,GAAG,IAAI;;IAGxD,IAAI,IAAI,CAACC,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,CAACC,SAAS,GAAG,IAAI;MACxC,IAAI,CAACD,kBAAkB,CAACE,0BAA0B,EAAE;;EAE5D","names":["MultiRenderTarget","ImageProcessingPostProcess","PrePassRenderTarget","constructor","name","renderTargetTexture","size","count","scene","options","_createCompositionEffect","imageProcessingPostProcess","undefined","_engine","_updateParameters","_checkSize","requiredWidth","getRenderWidth","requiredHeight","getRenderHeight","width","height","resize","_internalTextureDirty","updateCount","textureNames","_resetPostProcessChain","_beforeCompositionPostProcesses","length","dispose","_scene","prePassRenderer","index","renderTargets","indexOf","splice","_prePassRenderTarget","_outputPostProcess","autoClear","restoreDefaultInputTexture"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/prePassRenderTarget.ts"],"sourcesContent":["import type { IMultiRenderTargetOptions } from \"./multiRenderTarget\";\r\nimport { MultiRenderTarget } from \"./multiRenderTarget\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { RenderTargetTexture } from \"./renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * A multi render target designed to render the prepass.\r\n * Prepass is a scene component used to render information in multiple textures\r\n * alongside with the scene materials rendering.\r\n * Note : This is an internal class, and you should NOT need to instanciate this.\r\n * Only the `PrePassRenderer` should instanciate this class.\r\n * It is more likely that you need a regular `MultiRenderTarget`\r\n * @internal\r\n */\r\nexport class PrePassRenderTarget extends MultiRenderTarget {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _beforeCompositionPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Image processing post process for composition\r\n     */\r\n    public imageProcessingPostProcess: ImageProcessingPostProcess;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _engine: Engine;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _scene: Scene;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _outputPostProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _internalTextureDirty = false;\r\n\r\n    /**\r\n     * Is this render target enabled for prepass rendering\r\n     */\r\n    public enabled: boolean = false;\r\n\r\n    /**\r\n     * Render target associated with this prePassRenderTarget\r\n     * If this is `null`, it means this prePassRenderTarget is associated with the scene\r\n     */\r\n    public renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n\r\n    public constructor(name: string, renderTargetTexture: Nullable<RenderTargetTexture>, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions | undefined) {\r\n        super(name, size, count, scene, options);\r\n\r\n        this.renderTargetTexture = renderTargetTexture;\r\n    }\r\n\r\n    /**\r\n     * Creates a composition effect for this RT\r\n     * @internal\r\n     */\r\n    public _createCompositionEffect() {\r\n        this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"prePassComposition\", 1, null, undefined, this._engine);\r\n        this.imageProcessingPostProcess._updateParameters();\r\n    }\r\n\r\n    /**\r\n     * Checks that the size of this RT is still adapted to the desired render size.\r\n     * @internal\r\n     */\r\n    public _checkSize() {\r\n        const requiredWidth = this._engine.getRenderWidth(true);\r\n        const requiredHeight = this._engine.getRenderHeight(true);\r\n\r\n        const width = this.getRenderWidth();\r\n        const height = this.getRenderHeight();\r\n\r\n        if (width !== requiredWidth || height !== requiredHeight) {\r\n            this.resize({ width: requiredWidth, height: requiredHeight });\r\n\r\n            this._internalTextureDirty = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        super.updateCount(count, options, textureNames);\r\n        this._internalTextureDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the post processes chains applied to this RT.\r\n     * @internal\r\n     */\r\n    public _resetPostProcessChain() {\r\n        this._beforeCompositionPostProcesses.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Diposes this render target\r\n     */\r\n    public dispose() {\r\n        const scene = this._scene;\r\n\r\n        super.dispose();\r\n\r\n        if (scene && scene.prePassRenderer) {\r\n            const index = scene.prePassRenderer.renderTargets.indexOf(this);\r\n\r\n            if (index !== -1) {\r\n                scene.prePassRenderer.renderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this.imageProcessingPostProcess) {\r\n            this.imageProcessingPostProcess.dispose();\r\n        }\r\n\r\n        if (this.renderTargetTexture) {\r\n            this.renderTargetTexture._prePassRenderTarget = null;\r\n        }\r\n\r\n        if (this._outputPostProcess) {\r\n            this._outputPostProcess.autoClear = true;\r\n            this._outputPostProcess.restoreDefaultInputTexture();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}