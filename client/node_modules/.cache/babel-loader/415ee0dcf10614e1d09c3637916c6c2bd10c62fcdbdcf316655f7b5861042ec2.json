{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput.js\";\n/**\n * Manage the pointers inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\n  constructor() {\n    super(...arguments);\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Defines the pointer angular sensibility  along the X axis or how fast is\n     * the camera rotating.\n     */\n    this.angularSensibilityX = 1000.0;\n    /**\n     * Defines the pointer angular sensibility along the Y axis or how fast is\n     * the camera rotating.\n     */\n    this.angularSensibilityY = 1000.0;\n    /**\n     * Defines the pointer pinch precision or how fast is the camera zooming.\n     */\n    this.pinchPrecision = 12.0;\n    /**\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\n     * from 0.\n     * It defines the percentage of current camera.radius to use as delta when\n     * pinch zoom is used.\n     */\n    this.pinchDeltaPercentage = 0;\n    /**\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\n     * that any object in the plane at the camera's target point will scale\n     * perfectly with finger motion.\n     * Overrides pinchDeltaPercentage and pinchPrecision.\n     */\n    this.useNaturalPinchZoom = false;\n    /**\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\n     */\n    this.pinchZoom = true;\n    /**\n     * Defines the pointer panning sensibility or how fast is the camera moving.\n     */\n    this.panningSensibility = 1000.0;\n    /**\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\n     */\n    this.multiTouchPanning = true;\n    /**\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\n     * zoom (pinch) through multitouch.\n     */\n    this.multiTouchPanAndZoom = true;\n    /**\n     * Revers pinch action direction.\n     */\n    this.pinchInwards = true;\n    this._isPanClick = false;\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ArcRotateCameraPointersInput\";\n  }\n  /**\n   * Move camera from multi touch panning positions.\n   * @param previousMultiTouchPanPosition\n   * @param multiTouchPanPosition\n   */\n  _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\n      const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n      const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n      this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n      this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n    }\n  }\n  /**\n   * Move camera from pinch zoom distances.\n   * @param previousPinchSquaredDistance\n   * @param pinchSquaredDistance\n   */\n  _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {\n    const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\n    if (this.useNaturalPinchZoom) {\n      this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);\n    } else if (this.pinchDeltaPercentage) {\n      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\n    } else {\n      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n    }\n  }\n  /**\n   * Called on pointer POINTERMOVE event if only a single touch is active.\n   * @param point\n   * @param offsetX\n   * @param offsetY\n   */\n  onTouch(point, offsetX, offsetY) {\n    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {\n      this.camera.inertialPanningX += -offsetX / this.panningSensibility;\n      this.camera.inertialPanningY += offsetY / this.panningSensibility;\n    } else {\n      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\n      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\n    }\n  }\n  /**\n   * Called on pointer POINTERDOUBLETAP event.\n   */\n  onDoubleTap() {\n    if (this.camera.useInputToRestoreState) {\n      this.camera.restoreState();\n    }\n  }\n  /**\n   * Called on pointer POINTERMOVE event if multiple touches are active.\n   * @param pointA\n   * @param pointB\n   * @param previousPinchSquaredDistance\n   * @param pinchSquaredDistance\n   * @param previousMultiTouchPanPosition\n   * @param multiTouchPanPosition\n   */\n  onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n      // First time this method is called for new pinch.\n      // Next time this is called there will be a\n      // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n      return;\n    }\n    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n      // Last time this method is called at the end of a pinch.\n      return;\n    }\n    // Zoom and panning enabled together\n    if (this.multiTouchPanAndZoom) {\n      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n      // Zoom and panning enabled but only one at a time\n    } else if (this.multiTouchPanning && this.pinchZoom) {\n      this._twoFingerActivityCount++;\n      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance) {\n        // Since pinch has not been active long, assume we intend to zoom.\n        this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n        // Since we are pinching, remain pinching on next iteration.\n        this._isPinching = true;\n      } else {\n        // Pause between pinch starting and moving implies not a zoom event. Pan instead.\n        this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n      }\n      // Panning enabled, zoom disabled\n    } else if (this.multiTouchPanning) {\n      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n      // Zoom enabled, panning disabled\n    } else if (this.pinchZoom) {\n      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n    }\n  }\n  /**\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\n   * press.\n   * @param evt\n   */\n  onButtonDown(evt) {\n    this._isPanClick = evt.button === this.camera._panningMouseButton;\n  }\n  /**\n   * Called each time a new POINTERUP event occurs. Ie, for each button\n   * release.\n   */\n  onButtonUp() {\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  }\n  /**\n   * Called when window becomes inactive.\n   */\n  onLostFocus() {\n    this._isPanClick = false;\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  }\n}\n/**\n * The minimum radius used for pinch, to avoid radius lock at 0\n */\nArcRotateCameraPointersInput.MinimumRadiusForPinch = 0.001;\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"useNaturalPinchZoom\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchZoom\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanning\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanAndZoom\", void 0);\nCameraInputTypes[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;","map":{"version":3,"mappings":"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","names":["serialize","CameraInputTypes","BaseCameraPointersInput","ArcRotateCameraPointersInput","constructor","getClassName","_computeMultiTouchPanning","previousMultiTouchPanPosition","multiTouchPanPosition","panningSensibility","moveDeltaX","x","moveDeltaY","y","camera","inertialPanningX","inertialPanningY","_computePinchZoom","previousPinchSquaredDistance","pinchSquaredDistance","radius","MinimumRadiusForPinch","useNaturalPinchZoom","Math","sqrt","pinchDeltaPercentage","inertialRadiusOffset","pinchPrecision","pinchInwards","angularSensibilityX","angularSensibilityY","onTouch","point","offsetX","offsetY","_ctrlKey","_useCtrlForPanning","_isPanClick","inertialAlphaOffset","inertialBetaOffset","onDoubleTap","useInputToRestoreState","restoreState","onMultiTouch","pointA","pointB","multiTouchPanAndZoom","multiTouchPanning","pinchZoom","_twoFingerActivityCount","_isPinching","abs","pinchToPanMaxDistance","onButtonDown","evt","button","_panningMouseButton","onButtonUp","onLostFocus","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/Inputs/arcRotateCameraPointersInput.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA\r\n     * @param pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt\r\n     */\r\n    public onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     */\r\n    public onButtonUp(): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}