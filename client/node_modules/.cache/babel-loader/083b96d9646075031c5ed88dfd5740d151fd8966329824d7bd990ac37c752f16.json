{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateLineSystem } from \"../Meshes/Builders/linesBuilder.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { DynamicTexture } from \"../Materials/Textures/dynamicTexture.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { ExtrudeShapeCustom } from \"../Meshes/Builders/shapeBuilder.js\";\n/**\n * Class used to render a debug view of a given skeleton\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\n */\nexport class SkeletonViewer {\n  /**\n   * Creates a new SkeletonViewer\n   * @param skeleton defines the skeleton to render\n   * @param mesh defines the mesh attached to the skeleton\n   * @param scene defines the hosting scene\n   * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\n   * @param renderingGroupId defines the rendering group id to use with the viewer\n   * @param options All of the extra constructor options for the SkeletonViewer\n   */\n  constructor( /** defines the skeleton to render */\n  skeleton, /** defines the mesh attached to the skeleton */\n  mesh, /** The Scene scope*/\n  scene, /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\n  autoUpdateBonesMatrices = true, /** defines the rendering group id to use with the viewer */\n  renderingGroupId = 3, /** is the options for the viewer */\n  options = {}) {\n    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n    this.skeleton = skeleton;\n    this.mesh = mesh;\n    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;\n    this.renderingGroupId = renderingGroupId;\n    this.options = options;\n    /** Gets or sets the color used to render the skeleton */\n    this.color = Color3.White();\n    /** Array of the points of the skeleton fo the line view. */\n    this._debugLines = new Array();\n    /** The local axes Meshes. */\n    this._localAxes = null;\n    /** If SkeletonViewer is enabled. */\n    this._isEnabled = true;\n    /** SkeletonViewer render observable. */\n    this._obs = null;\n    this._scene = scene;\n    this._ready = false;\n    //Defaults\n    options.pauseAnimations = (_a = options.pauseAnimations) !== null && _a !== void 0 ? _a : true;\n    options.returnToRest = (_c = options.returnToRest) !== null && _c !== void 0 ? _c : false;\n    options.displayMode = (_d = options.displayMode) !== null && _d !== void 0 ? _d : SkeletonViewer.DISPLAY_LINES;\n    options.displayOptions = (_e = options.displayOptions) !== null && _e !== void 0 ? _e : {};\n    options.displayOptions.midStep = (_f = options.displayOptions.midStep) !== null && _f !== void 0 ? _f : 0.235;\n    options.displayOptions.midStepFactor = (_g = options.displayOptions.midStepFactor) !== null && _g !== void 0 ? _g : 0.155;\n    options.displayOptions.sphereBaseSize = (_h = options.displayOptions.sphereBaseSize) !== null && _h !== void 0 ? _h : 0.15;\n    options.displayOptions.sphereScaleUnit = (_j = options.displayOptions.sphereScaleUnit) !== null && _j !== void 0 ? _j : 2;\n    options.displayOptions.sphereFactor = (_k = options.displayOptions.sphereFactor) !== null && _k !== void 0 ? _k : 0.865;\n    options.displayOptions.spurFollowsChild = (_l = options.displayOptions.spurFollowsChild) !== null && _l !== void 0 ? _l : false;\n    options.displayOptions.showLocalAxes = (_m = options.displayOptions.showLocalAxes) !== null && _m !== void 0 ? _m : false;\n    options.displayOptions.localAxesSize = (_o = options.displayOptions.localAxesSize) !== null && _o !== void 0 ? _o : 0.075;\n    options.computeBonesUsingShaders = (_p = options.computeBonesUsingShaders) !== null && _p !== void 0 ? _p : true;\n    options.useAllBones = (_q = options.useAllBones) !== null && _q !== void 0 ? _q : true;\n    const initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    this._boneIndices = new Set();\n    if (!options.useAllBones) {\n      if (initialMeshBoneIndices && initialMeshBoneWeights) {\n        for (let i = 0; i < initialMeshBoneIndices.length; ++i) {\n          const index = initialMeshBoneIndices[i],\n            weight = initialMeshBoneWeights[i];\n          if (weight !== 0) {\n            this._boneIndices.add(index);\n          }\n        }\n      }\n    }\n    /* Create Utility Layer */\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n    let displayMode = this.options.displayMode || 0;\n    if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      displayMode = SkeletonViewer.DISPLAY_LINES;\n    }\n    this.displayMode = displayMode;\n    //Prep the Systems\n    this.update();\n    this._bindObs();\n  }\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   * @see http://www.babylonjs-playground.com/#1BZJVJ#395\n   */\n  static CreateBoneWeightShader(options, scene) {\n    var _a, _c, _d, _e, _f, _g;\n    const skeleton = options.skeleton;\n    const colorBase = (_a = options.colorBase) !== null && _a !== void 0 ? _a : Color3.Black();\n    const colorZero = (_c = options.colorZero) !== null && _c !== void 0 ? _c : Color3.Blue();\n    const colorQuarter = (_d = options.colorQuarter) !== null && _d !== void 0 ? _d : Color3.Green();\n    const colorHalf = (_e = options.colorHalf) !== null && _e !== void 0 ? _e : Color3.Yellow();\n    const colorFull = (_f = options.colorFull) !== null && _f !== void 0 ? _f : Color3.Red();\n    const targetBoneIndex = (_g = options.targetBoneIndex) !== null && _g !== void 0 ? _g : 0;\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"VertexShader\"] = `precision highp float;\n\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 view;\n        uniform mat4 projection;\n        uniform mat4 worldViewProjection;\n\n        #include<bonesDeclaration>\n        #if NUM_BONE_INFLUENCERS == 0\n            attribute vec4 matricesIndices;\n            attribute vec4 matricesWeights;\n        #endif\n        #include<bakedVertexAnimationDeclaration>\n\n        #include<instancesDeclaration>\n\n        varying vec3 vColor;\n\n        uniform vec3 colorBase;\n        uniform vec3 colorZero;\n        uniform vec3 colorQuarter;\n        uniform vec3 colorHalf;\n        uniform vec3 colorFull;\n\n        uniform float targetBoneIndex;\n\n        void main() {\n            vec3 positionUpdated = position;\n\n            #include<instancesVertex>\n            #include<bonesVertex>\n            #include<bakedVertexAnimation>\n\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n            vec3 color = colorBase;\n            float totalWeight = 0.;\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\n                totalWeight += matricesWeights[0];\n            }\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\n                totalWeight += matricesWeights[1];\n            }\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\n                totalWeight += matricesWeights[2];\n            }\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\n                totalWeight += matricesWeights[3];\n            }\n\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\n            vColor = color;\n\n        gl_Position = projection * view * worldPos;\n        }`;\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"FragmentShader\"] = `\n            precision highp float;\n            varying vec3 vPosition;\n\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4(vColor, 1.0);\n                gl_FragColor = color;\n            }\n        `;\n    const shader = new ShaderMaterial(\"boneWeight:\" + skeleton.name, scene, {\n      vertex: \"boneWeights:\" + skeleton.name,\n      fragment: \"boneWeights:\" + skeleton.name\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorBase\", \"colorZero\", \"colorQuarter\", \"colorHalf\", \"colorFull\", \"targetBoneIndex\"]\n    });\n    shader.setColor3(\"colorBase\", colorBase);\n    shader.setColor3(\"colorZero\", colorZero);\n    shader.setColor3(\"colorQuarter\", colorQuarter);\n    shader.setColor3(\"colorHalf\", colorHalf);\n    shader.setColor3(\"colorFull\", colorFull);\n    shader.setFloat(\"targetBoneIndex\", targetBoneIndex);\n    shader.getClassName = () => {\n      return \"BoneWeightShader\";\n    };\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  }\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   */\n  static CreateSkeletonMapShader(options, scene) {\n    var _a;\n    const skeleton = options.skeleton;\n    const colorMap = (_a = options.colorMap) !== null && _a !== void 0 ? _a : [{\n      color: new Color3(1, 0.38, 0.18),\n      location: 0\n    }, {\n      color: new Color3(0.59, 0.18, 1.0),\n      location: 0.2\n    }, {\n      color: new Color3(0.59, 1, 0.18),\n      location: 0.4\n    }, {\n      color: new Color3(1, 0.87, 0.17),\n      location: 0.6\n    }, {\n      color: new Color3(1, 0.17, 0.42),\n      location: 0.8\n    }, {\n      color: new Color3(0.17, 0.68, 1.0),\n      location: 1.0\n    }];\n    const bufferWidth = skeleton.bones.length + 1;\n    const colorMapBuffer = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\n    const shader = new ShaderMaterial(\"boneWeights:\" + skeleton.name, scene, {\n      vertexSource: `precision highp float;\n\n            attribute vec3 position;\n            attribute vec2 uv;\n\n            uniform mat4 view;\n            uniform mat4 projection;\n            uniform mat4 worldViewProjection;\n            uniform float colorMap[` + skeleton.bones.length * 4 + `];\n\n            #include<bonesDeclaration>\n            #if NUM_BONE_INFLUENCERS == 0\n                attribute vec4 matricesIndices;\n                attribute vec4 matricesWeights;\n            #endif\n            #include<bakedVertexAnimationDeclaration>\n            #include<instancesDeclaration>\n\n            varying vec3 vColor;\n\n            void main() {\n                vec3 positionUpdated = position;\n\n                #include<instancesVertex>\n                #include<bonesVertex>\n                #include<bakedVertexAnimation>\n\n                vec3 color = vec3(0.);\n                bool first = true;\n\n                for (int i = 0; i < 4; i++) {\n                    int boneIdx = int(matricesIndices[i]);\n                    float boneWgt = matricesWeights[i];\n\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\n\n                    if (boneWgt > 0.) {\n                        if (first) {\n                            first = false;\n                            color = c;\n                        } else {\n                            color = mix(color, c, boneWgt);\n                        }\n                    }\n                }\n\n                vColor = color;\n\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n                gl_Position = projection * view * worldPos;\n            }`,\n      fragmentSource: `\n            precision highp float;\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4( vColor, 1.0 );\n                gl_FragColor = color;\n            }\n            `\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorMap\"]\n    });\n    shader.setFloats(\"colorMap\", colorMapBuffer);\n    shader.getClassName = () => {\n      return \"SkeletonMapShader\";\n    };\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  }\n  /** private static method to create a BoneWeight Shader\n   * @param size The size of the buffer to create (usually the bone count)\n   * @param colorMap The gradient data to generate\n   * @param scene The scene that the shader is scoped to\n   * @returns an Array of floats from the color gradient values\n   */\n  static _CreateBoneMapColorBuffer(size, colorMap, scene) {\n    const tempGrad = new DynamicTexture(\"temp\", {\n      width: size,\n      height: 1\n    }, scene, false);\n    const ctx = tempGrad.getContext();\n    const grad = ctx.createLinearGradient(0, 0, size, 0);\n    colorMap.forEach(stop => {\n      grad.addColorStop(stop.location, stop.color.toHexString());\n    });\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, size, 1);\n    tempGrad.update();\n    const buffer = [];\n    const data = ctx.getImageData(0, 0, size, 1).data;\n    const rUnit = 1 / 255;\n    for (let i = 0; i < data.length; i++) {\n      buffer.push(data[i] * rUnit);\n    }\n    tempGrad.dispose();\n    return buffer;\n  }\n  /** Gets the Scene. */\n  get scene() {\n    return this._scene;\n  }\n  /** Gets the utilityLayer. */\n  get utilityLayer() {\n    return this._utilityLayer;\n  }\n  /** Checks Ready Status. */\n  get isReady() {\n    return this._ready;\n  }\n  /** Sets Ready Status. */\n  set ready(value) {\n    this._ready = value;\n  }\n  /** Gets the debugMesh */\n  get debugMesh() {\n    return this._debugMesh;\n  }\n  /** Sets the debugMesh */\n  set debugMesh(value) {\n    this._debugMesh = value;\n  }\n  /** Gets the displayMode */\n  get displayMode() {\n    return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\n  }\n  /** Sets the displayMode */\n  set displayMode(value) {\n    if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      value = SkeletonViewer.DISPLAY_LINES;\n    }\n    this.options.displayMode = value;\n  }\n  /** The Dynamic bindings for the update functions */\n  _bindObs() {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._obs = this.scene.onBeforeRenderObservable.add(() => {\n            this._displayLinesUpdate();\n          });\n          break;\n        }\n    }\n  }\n  /** Update the viewer to sync with current skeleton state, only used to manually update. */\n  update() {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._displayLinesUpdate();\n          break;\n        }\n      case SkeletonViewer.DISPLAY_SPHERES:\n        {\n          this._buildSpheresAndSpurs(true);\n          break;\n        }\n      case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS:\n        {\n          this._buildSpheresAndSpurs(false);\n          break;\n        }\n    }\n    this._buildLocalAxes();\n  }\n  /** Gets or sets a boolean indicating if the viewer is enabled */\n  set isEnabled(value) {\n    if (this.isEnabled === value) {\n      return;\n    }\n    this._isEnabled = value;\n    if (this.debugMesh) {\n      this.debugMesh.setEnabled(value);\n    }\n    if (value && !this._obs) {\n      this._bindObs();\n    } else if (!value && this._obs) {\n      this.scene.onBeforeRenderObservable.remove(this._obs);\n      this._obs = null;\n    }\n  }\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  _getBonePosition(position, bone, meshMat, x = 0, y = 0, z = 0) {\n    const tmat = TmpVectors.Matrix[0];\n    const parentBone = bone.getParent();\n    tmat.copyFrom(bone.getLocalMatrix());\n    if (x !== 0 || y !== 0 || z !== 0) {\n      const tmat2 = TmpVectors.Matrix[1];\n      Matrix.IdentityToRef(tmat2);\n      tmat2.setTranslationFromFloats(x, y, z);\n      tmat2.multiplyToRef(tmat, tmat);\n    }\n    if (parentBone) {\n      tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\n    }\n    tmat.multiplyToRef(meshMat, tmat);\n    position.x = tmat.m[12];\n    position.y = tmat.m[13];\n    position.z = tmat.m[14];\n  }\n  _getLinesForBonesWithLength(bones, meshMat) {\n    const len = bones.length;\n    const mesh = this.mesh;\n    const meshPos = mesh.position;\n    let idx = 0;\n    for (let i = 0; i < len; i++) {\n      const bone = bones[i];\n      let points = this._debugLines[idx];\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[idx] = points;\n      }\n      this._getBonePosition(points[0], bone, meshMat);\n      this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      idx++;\n    }\n  }\n  _getLinesForBonesNoLength(bones) {\n    const len = bones.length;\n    let boneNum = 0;\n    const mesh = this.mesh;\n    const meshPos = mesh.position;\n    for (let i = len - 1; i >= 0; i--) {\n      const childBone = bones[i];\n      const parentBone = childBone.getParent();\n      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      let points = this._debugLines[boneNum];\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[boneNum] = points;\n      }\n      childBone.getAbsolutePositionToRef(mesh, points[0]);\n      parentBone.getAbsolutePositionToRef(mesh, points[1]);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      boneNum++;\n    }\n  }\n  /**\n   * function to revert the mesh and scene back to the initial state.\n   * @param animationState\n   */\n  _revert(animationState) {\n    if (this.options.pauseAnimations) {\n      this.scene.animationsEnabled = animationState;\n      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;\n    }\n  }\n  /**\n   * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.\n   * @param bone\n   * @param matrix\n   */\n  _getAbsoluteBindPoseToRef(bone, matrix) {\n    if (bone === null || bone._index === -1) {\n      matrix.copyFrom(Matrix.Identity());\n      return;\n    }\n    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\n    bone.getBaseMatrix().multiplyToRef(matrix, matrix);\n    return;\n  }\n  /**\n   * function to build and bind sphere joint points and spur bone representations.\n   * @param spheresOnly\n   */\n  _buildSpheresAndSpurs(spheresOnly = true) {\n    var _a, _c;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n      this.ready = false;\n    }\n    this._ready = false;\n    const utilityLayerScene = (_a = this.utilityLayer) === null || _a === void 0 ? void 0 : _a.utilityLayerScene;\n    const bones = this.skeleton.bones;\n    const spheres = [];\n    const spurs = [];\n    const animationState = this.scene.animationsEnabled;\n    try {\n      if (this.options.pauseAnimations) {\n        this.scene.animationsEnabled = false;\n        utilityLayerScene.animationsEnabled = false;\n      }\n      if (this.options.returnToRest) {\n        this.skeleton.returnToRest();\n      }\n      if (this.autoUpdateBonesMatrices) {\n        this.skeleton.computeAbsoluteTransforms();\n      }\n      let longestBoneLength = Number.NEGATIVE_INFINITY;\n      const displayOptions = this.options.displayOptions || {};\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i];\n        if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n          continue;\n        }\n        const boneAbsoluteBindPoseTransform = new Matrix();\n        this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n        const anchorPoint = new Vector3();\n        boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\n        bone.children.forEach(bc => {\n          const childAbsoluteBindPoseTransform = new Matrix();\n          bc.getBaseMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\n          const childPoint = new Vector3();\n          childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\n          const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\n          if (distanceFromParent > longestBoneLength) {\n            longestBoneLength = distanceFromParent;\n          }\n          if (spheresOnly) {\n            return;\n          }\n          const dir = childPoint.clone().subtract(anchorPoint.clone());\n          const h = dir.length();\n          const up = dir.normalize().scale(h);\n          const midStep = displayOptions.midStep || 0.165;\n          const midStepFactor = displayOptions.midStepFactor || 0.215;\n          const up0 = up.scale(midStep);\n          const spur = ExtrudeShapeCustom(\"skeletonViewer\", {\n            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\n            path: [Vector3.Zero(), up0, up],\n            scaleFunction: i => {\n              switch (i) {\n                case 0:\n                case 2:\n                  return 0;\n                case 1:\n                  return h * midStepFactor;\n              }\n              return 0;\n            },\n            sideOrientation: Mesh.DEFAULTSIDE,\n            updatable: false\n          }, utilityLayerScene);\n          const numVertices = spur.getTotalVertices();\n          const mwk = [],\n            mik = [];\n          for (let i = 0; i < numVertices; i++) {\n            mwk.push(1, 0, 0, 0);\n            // Select verts at end of spur (ie vert 10 to 14) and bind to child\n            // bone if spurFollowsChild is enabled.\n            if (displayOptions.spurFollowsChild && i > 9) {\n              mik.push(bc.getIndex(), 0, 0, 0);\n            } else {\n              mik.push(bone.getIndex(), 0, 0, 0);\n            }\n          }\n          spur.position = anchorPoint.clone();\n          spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n          spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n          spur.convertToFlatShadedMesh();\n          spurs.push(spur);\n        });\n        const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;\n        const sphere = CreateSphere(\"skeletonViewer\", {\n          segments: 6,\n          diameter: sphereBaseSize,\n          updatable: true\n        }, utilityLayerScene);\n        const numVertices = sphere.getTotalVertices();\n        const mwk = [],\n          mik = [];\n        for (let i = 0; i < numVertices; i++) {\n          mwk.push(1, 0, 0, 0);\n          mik.push(bone.getIndex(), 0, 0, 0);\n        }\n        sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n        sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n        sphere.position = anchorPoint.clone();\n        spheres.push([sphere, bone]);\n      }\n      const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;\n      const sphereFactor = displayOptions.sphereFactor || 0.85;\n      const meshes = [];\n      for (let i = 0; i < spheres.length; i++) {\n        const [sphere, bone] = spheres[i];\n        const scale = 1 / (sphereScaleUnit / longestBoneLength);\n        let _stepsOut = 0;\n        let _b = bone;\n        while (_b.getParent() && _b.getParent().getIndex() !== -1) {\n          _stepsOut++;\n          _b = _b.getParent();\n        }\n        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\n        meshes.push(sphere);\n      }\n      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\n      if (this.debugMesh) {\n        this.debugMesh.renderingGroupId = this.renderingGroupId;\n        this.debugMesh.skeleton = this.skeleton;\n        this.debugMesh.parent = this.mesh;\n        this.debugMesh.computeBonesUsingShaders = (_c = this.options.computeBonesUsingShaders) !== null && _c !== void 0 ? _c : true;\n        this.debugMesh.alwaysSelectAsActiveMesh = true;\n      }\n      const light = this.utilityLayer._getSharedGizmoLight();\n      light.intensity = 0.7;\n      this._revert(animationState);\n      this.ready = true;\n    } catch (err) {\n      console.error(err);\n      this._revert(animationState);\n      this.dispose();\n    }\n  }\n  _buildLocalAxes() {\n    var _a;\n    if (this._localAxes) {\n      this._localAxes.dispose();\n    }\n    this._localAxes = null;\n    const displayOptions = this.options.displayOptions || {};\n    if (!displayOptions.showLocalAxes) {\n      return;\n    }\n    const targetScene = this._utilityLayer.utilityLayerScene;\n    const size = displayOptions.localAxesSize || 0.075;\n    const lines = [];\n    const colors = [];\n    const red = new Color4(1, 0, 0, 1);\n    const green = new Color4(0, 1, 0, 1);\n    const blue = new Color4(0, 0, 1, 1);\n    const mwk = [];\n    const mik = [];\n    const vertsPerBone = 6;\n    for (const i in this.skeleton.bones) {\n      const bone = this.skeleton.bones[i];\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      const boneAbsoluteBindPoseTransform = new Matrix();\n      const boneOrigin = new Vector3();\n      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n      boneAbsoluteBindPoseTransform.decompose(undefined, TmpVectors.Quaternion[0], boneOrigin);\n      const m = new Matrix();\n      TmpVectors.Quaternion[0].toRotationMatrix(m);\n      const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\n      const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\n      const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\n      const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\n      const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\n      const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\n      const linePoints = [axisX, axisY, axisZ];\n      const lineColors = [[red, red], [green, green], [blue, blue]];\n      lines.push(...linePoints);\n      colors.push(...lineColors);\n      for (let j = 0; j < vertsPerBone; j++) {\n        mwk.push(1, 0, 0, 0);\n        mik.push(bone.getIndex(), 0, 0, 0);\n      }\n    }\n    this._localAxes = CreateLineSystem(\"localAxes\", {\n      lines: lines,\n      colors: colors,\n      updatable: true\n    }, targetScene);\n    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n    this._localAxes.skeleton = this.skeleton;\n    this._localAxes.renderingGroupId = this.renderingGroupId + 1;\n    this._localAxes.parent = this.mesh;\n    this._localAxes.computeBonesUsingShaders = (_a = this.options.computeBonesUsingShaders) !== null && _a !== void 0 ? _a : true;\n  }\n  /** Update the viewer to sync with current skeleton state, only used for the line display. */\n  _displayLinesUpdate() {\n    if (!this._utilityLayer) {\n      return;\n    }\n    if (this.autoUpdateBonesMatrices) {\n      this.skeleton.computeAbsoluteTransforms();\n    }\n    if (this.skeleton.bones[0].length === undefined) {\n      this._getLinesForBonesNoLength(this.skeleton.bones);\n    } else {\n      this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());\n    }\n    const targetScene = this._utilityLayer.utilityLayerScene;\n    if (targetScene) {\n      if (!this._debugMesh) {\n        this._debugMesh = CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: null\n        }, targetScene);\n        this._debugMesh.renderingGroupId = this.renderingGroupId;\n      } else {\n        CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: this._debugMesh\n        }, targetScene);\n      }\n      this._debugMesh.position.copyFrom(this.mesh.position);\n      this._debugMesh.color = this.color;\n    }\n  }\n  /** Changes the displayMode of the skeleton viewer\n   * @param mode The displayMode numerical value\n   */\n  changeDisplayMode(mode) {\n    const wasEnabled = this.isEnabled ? true : false;\n    if (this.displayMode !== mode) {\n      this.isEnabled = false;\n      if (this._debugMesh) {\n        this._debugMesh.dispose();\n        this._debugMesh = null;\n        this.ready = false;\n      }\n      this.displayMode = mode;\n      this.update();\n      this._bindObs();\n      this.isEnabled = wasEnabled;\n    }\n  }\n  /** Sets a display option of the skeleton viewer\n   *\n   * | Option           | Type    | Default | Description |\n   * | ---------------- | ------- | ------- | ----------- |\n   * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\n   * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\n   * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\n   *\n   * @param option String of the option name\n   * @param value The numerical option value\n   */\n  changeDisplayOptions(option, value) {\n    const wasEnabled = this.isEnabled ? true : false;\n    this.options.displayOptions[option] = value;\n    this.isEnabled = false;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n      this.ready = false;\n    }\n    this.update();\n    this._bindObs();\n    this.isEnabled = wasEnabled;\n  }\n  /** Release associated resources */\n  dispose() {\n    this.isEnabled = false;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n    }\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n      this._utilityLayer = null;\n    }\n    this.ready = false;\n  }\n}\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\nSkeletonViewer.DISPLAY_LINES = 0;\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\nSkeletonViewer.DISPLAY_SPHERES = 1;\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\nSkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","TmpVectors","Color3","Color4","Mesh","CreateLineSystem","UtilityLayerRenderer","Material","ShaderMaterial","DynamicTexture","VertexBuffer","Effect","CreateSphere","ExtrudeShapeCustom","SkeletonViewer","constructor","skeleton","mesh","scene","autoUpdateBonesMatrices","renderingGroupId","options","White","Array","_scene","_ready","pauseAnimations","returnToRest","displayMode","DISPLAY_LINES","displayOptions","midStep","midStepFactor","sphereBaseSize","sphereScaleUnit","sphereFactor","spurFollowsChild","showLocalAxes","localAxesSize","computeBonesUsingShaders","useAllBones","initialMeshBoneIndices","getVerticesData","MatricesIndicesKind","initialMeshBoneWeights","MatricesWeightsKind","_boneIndices","Set","i","length","index","weight","add","_utilityLayer","pickUtilitySceneFirst","utilityLayerScene","autoClearDepthAndStencil","DISPLAY_SPHERE_AND_SPURS","update","_bindObs","CreateBoneWeightShader","colorBase","Black","colorZero","Blue","colorQuarter","Green","colorHalf","Yellow","colorFull","Red","targetBoneIndex","ShadersStore","name","shader","vertex","fragment","attributes","uniforms","setColor3","setFloat","getClassName","transparencyMode","MATERIAL_OPAQUE","CreateSkeletonMapShader","colorMap","color","location","bufferWidth","bones","colorMapBuffer","_CreateBoneMapColorBuffer","vertexSource","fragmentSource","setFloats","size","tempGrad","width","height","ctx","getContext","grad","createLinearGradient","forEach","stop","addColorStop","toHexString","fillStyle","fillRect","buffer","data","getImageData","rUnit","push","dispose","utilityLayer","isReady","ready","value","debugMesh","_debugMesh","_obs","onBeforeRenderObservable","_displayLinesUpdate","DISPLAY_SPHERES","_buildSpheresAndSpurs","_buildLocalAxes","isEnabled","_isEnabled","setEnabled","remove","_getBonePosition","position","bone","meshMat","x","y","z","tmat","parentBone","getParent","copyFrom","getLocalMatrix","tmat2","IdentityToRef","setTranslationFromFloats","multiplyToRef","getAbsoluteTransform","m","_getLinesForBonesWithLength","len","meshPos","idx","points","_debugLines","_index","has","getIndex","Zero","subtractInPlace","_getLinesForBonesNoLength","boneNum","childBone","getAbsolutePositionToRef","_revert","animationState","animationsEnabled","_getAbsoluteBindPoseToRef","matrix","Identity","getBaseMatrix","spheresOnly","spheres","spurs","computeAbsoluteTransforms","longestBoneLength","Number","NEGATIVE_INFINITY","boneAbsoluteBindPoseTransform","anchorPoint","decompose","undefined","children","bc","childAbsoluteBindPoseTransform","childPoint","distanceFromParent","Distance","dir","clone","subtract","h","up","normalize","scale","up0","spur","shape","path","scaleFunction","sideOrientation","DEFAULTSIDE","updatable","numVertices","getTotalVertices","mwk","mik","setVerticesData","convertToFlatShadedMesh","sphere","segments","diameter","meshes","_stepsOut","_b","scaling","scaleInPlace","Math","pow","MergeMeshes","concat","parent","alwaysSelectAsActiveMesh","light","_getSharedGizmoLight","intensity","err","console","error","_localAxes","targetScene","lines","colors","red","green","blue","vertsPerBone","boneOrigin","Quaternion","toRotationMatrix","boneAxisX","TransformCoordinates","boneAxisY","boneAxisZ","axisX","axisY","axisZ","linePoints","lineColors","j","getWorldMatrix","instance","changeDisplayMode","mode","wasEnabled","changeDisplayOptions","option"],"sourceRoot":"","sources":["../../../../lts/core/generated/Debug/skeletonViewer.ts"],"sourcesContent":["import { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { CreateLineSystem } from \"../Meshes/Builders/linesBuilder\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { DynamicTexture } from \"../Materials/Textures/dynamicTexture\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport type { ISkeletonViewerOptions, IBoneWeightShaderOptions, ISkeletonMapShaderOptions, ISkeletonMapShaderColorMapKnot } from \"./ISkeletonViewer\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { ExtrudeShapeCustom } from \"../Meshes/Builders/shapeBuilder\";\r\n\r\n/**\r\n * Class used to render a debug view of a given skeleton\r\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\r\n */\r\nexport class SkeletonViewer {\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\r\n    public static readonly DISPLAY_LINES = 0;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\r\n    public static readonly DISPLAY_SPHERES = 1;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\r\n    public static readonly DISPLAY_SPHERE_AND_SPURS = 2;\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     * @see http://www.babylonjs-playground.com/#1BZJVJ#395\r\n     */\r\n    static CreateBoneWeightShader(options: IBoneWeightShaderOptions, scene: Scene): ShaderMaterial {\r\n        const skeleton: Skeleton = options.skeleton;\r\n        const colorBase: Color3 = options.colorBase ?? Color3.Black();\r\n        const colorZero: Color3 = options.colorZero ?? Color3.Blue();\r\n        const colorQuarter: Color3 = options.colorQuarter ?? Color3.Green();\r\n        const colorHalf: Color3 = options.colorHalf ?? Color3.Yellow();\r\n        const colorFull: Color3 = options.colorFull ?? Color3.Red();\r\n        const targetBoneIndex: number = options.targetBoneIndex ?? 0;\r\n\r\n        Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"VertexShader\"] = `precision highp float;\r\n\r\n        attribute vec3 position;\r\n        attribute vec2 uv;\r\n\r\n        uniform mat4 view;\r\n        uniform mat4 projection;\r\n        uniform mat4 worldViewProjection;\r\n\r\n        #include<bonesDeclaration>\r\n        #if NUM_BONE_INFLUENCERS == 0\r\n            attribute vec4 matricesIndices;\r\n            attribute vec4 matricesWeights;\r\n        #endif\r\n        #include<bakedVertexAnimationDeclaration>\r\n\r\n        #include<instancesDeclaration>\r\n\r\n        varying vec3 vColor;\r\n\r\n        uniform vec3 colorBase;\r\n        uniform vec3 colorZero;\r\n        uniform vec3 colorQuarter;\r\n        uniform vec3 colorHalf;\r\n        uniform vec3 colorFull;\r\n\r\n        uniform float targetBoneIndex;\r\n\r\n        void main() {\r\n            vec3 positionUpdated = position;\r\n\r\n            #include<instancesVertex>\r\n            #include<bonesVertex>\r\n            #include<bakedVertexAnimation>\r\n\r\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n            vec3 color = colorBase;\r\n            float totalWeight = 0.;\r\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\r\n                totalWeight += matricesWeights[0];\r\n            }\r\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\r\n                totalWeight += matricesWeights[1];\r\n            }\r\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\r\n                totalWeight += matricesWeights[2];\r\n            }\r\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\r\n                totalWeight += matricesWeights[3];\r\n            }\r\n\r\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\r\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\r\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\r\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\r\n            vColor = color;\r\n\r\n        gl_Position = projection * view * worldPos;\r\n        }`;\r\n        Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"FragmentShader\"] = `\r\n            precision highp float;\r\n            varying vec3 vPosition;\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4(vColor, 1.0);\r\n                gl_FragColor = color;\r\n            }\r\n        `;\r\n        const shader: ShaderMaterial = new ShaderMaterial(\r\n            \"boneWeight:\" + skeleton.name,\r\n            scene,\r\n            {\r\n                vertex: \"boneWeights:\" + skeleton.name,\r\n                fragment: \"boneWeights:\" + skeleton.name,\r\n            },\r\n            {\r\n                attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\r\n                uniforms: [\r\n                    \"world\",\r\n                    \"worldView\",\r\n                    \"worldViewProjection\",\r\n                    \"view\",\r\n                    \"projection\",\r\n                    \"viewProjection\",\r\n                    \"colorBase\",\r\n                    \"colorZero\",\r\n                    \"colorQuarter\",\r\n                    \"colorHalf\",\r\n                    \"colorFull\",\r\n                    \"targetBoneIndex\",\r\n                ],\r\n            }\r\n        );\r\n\r\n        shader.setColor3(\"colorBase\", colorBase);\r\n        shader.setColor3(\"colorZero\", colorZero);\r\n        shader.setColor3(\"colorQuarter\", colorQuarter);\r\n        shader.setColor3(\"colorHalf\", colorHalf);\r\n        shader.setColor3(\"colorFull\", colorFull);\r\n        shader.setFloat(\"targetBoneIndex\", targetBoneIndex);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"BoneWeightShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     */\r\n    static CreateSkeletonMapShader(options: ISkeletonMapShaderOptions, scene: Scene) {\r\n        const skeleton: Skeleton = options.skeleton;\r\n        const colorMap: ISkeletonMapShaderColorMapKnot[] = options.colorMap ?? [\r\n            {\r\n                color: new Color3(1, 0.38, 0.18),\r\n                location: 0,\r\n            },\r\n            {\r\n                color: new Color3(0.59, 0.18, 1.0),\r\n                location: 0.2,\r\n            },\r\n            {\r\n                color: new Color3(0.59, 1, 0.18),\r\n                location: 0.4,\r\n            },\r\n            {\r\n                color: new Color3(1, 0.87, 0.17),\r\n                location: 0.6,\r\n            },\r\n            {\r\n                color: new Color3(1, 0.17, 0.42),\r\n                location: 0.8,\r\n            },\r\n            {\r\n                color: new Color3(0.17, 0.68, 1.0),\r\n                location: 1.0,\r\n            },\r\n        ];\r\n\r\n        const bufferWidth: number = skeleton.bones.length + 1;\r\n        const colorMapBuffer: number[] = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\r\n        const shader = new ShaderMaterial(\r\n            \"boneWeights:\" + skeleton.name,\r\n            scene,\r\n            {\r\n                vertexSource:\r\n                    `precision highp float;\r\n\r\n            attribute vec3 position;\r\n            attribute vec2 uv;\r\n\r\n            uniform mat4 view;\r\n            uniform mat4 projection;\r\n            uniform mat4 worldViewProjection;\r\n            uniform float colorMap[` +\r\n                    skeleton.bones.length * 4 +\r\n                    `];\r\n\r\n            #include<bonesDeclaration>\r\n            #if NUM_BONE_INFLUENCERS == 0\r\n                attribute vec4 matricesIndices;\r\n                attribute vec4 matricesWeights;\r\n            #endif\r\n            #include<bakedVertexAnimationDeclaration>\r\n            #include<instancesDeclaration>\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec3 positionUpdated = position;\r\n\r\n                #include<instancesVertex>\r\n                #include<bonesVertex>\r\n                #include<bakedVertexAnimation>\r\n\r\n                vec3 color = vec3(0.);\r\n                bool first = true;\r\n\r\n                for (int i = 0; i < 4; i++) {\r\n                    int boneIdx = int(matricesIndices[i]);\r\n                    float boneWgt = matricesWeights[i];\r\n\r\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\r\n\r\n                    if (boneWgt > 0.) {\r\n                        if (first) {\r\n                            first = false;\r\n                            color = c;\r\n                        } else {\r\n                            color = mix(color, c, boneWgt);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vColor = color;\r\n\r\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n                gl_Position = projection * view * worldPos;\r\n            }`,\r\n                fragmentSource: `\r\n            precision highp float;\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4( vColor, 1.0 );\r\n                gl_FragColor = color;\r\n            }\r\n            `,\r\n            },\r\n            {\r\n                attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\r\n                uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorMap\"],\r\n            }\r\n        );\r\n\r\n        shader.setFloats(\"colorMap\", colorMapBuffer);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"SkeletonMapShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** private static method to create a BoneWeight Shader\r\n     * @param size The size of the buffer to create (usually the bone count)\r\n     * @param colorMap The gradient data to generate\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns an Array of floats from the color gradient values\r\n     */\r\n    private static _CreateBoneMapColorBuffer(size: number, colorMap: ISkeletonMapShaderColorMapKnot[], scene: Scene) {\r\n        const tempGrad = new DynamicTexture(\"temp\", { width: size, height: 1 }, scene, false);\r\n        const ctx = tempGrad.getContext();\r\n        const grad = ctx.createLinearGradient(0, 0, size, 0);\r\n\r\n        colorMap.forEach((stop) => {\r\n            grad.addColorStop(stop.location, stop.color.toHexString());\r\n        });\r\n\r\n        ctx.fillStyle = grad;\r\n        ctx.fillRect(0, 0, size, 1);\r\n        tempGrad.update();\r\n        const buffer: number[] = [];\r\n        const data: Uint8ClampedArray = ctx.getImageData(0, 0, size, 1).data;\r\n        const rUnit = 1 / 255;\r\n        for (let i = 0; i < data.length; i++) {\r\n            buffer.push(data[i] * rUnit);\r\n        }\r\n        tempGrad.dispose();\r\n        return buffer;\r\n    }\r\n\r\n    /** If SkeletonViewer scene scope. */\r\n    private _scene: Scene;\r\n\r\n    /** Gets or sets the color used to render the skeleton */\r\n    public color: Color3 = Color3.White();\r\n\r\n    /** Array of the points of the skeleton fo the line view. */\r\n    private _debugLines = new Array<Array<Vector3>>();\r\n\r\n    /** The SkeletonViewers Mesh. */\r\n    private _debugMesh: Nullable<LinesMesh>;\r\n\r\n    /** The local axes Meshes. */\r\n    private _localAxes: Nullable<LinesMesh> = null;\r\n\r\n    /** If SkeletonViewer is enabled. */\r\n    private _isEnabled = true;\r\n\r\n    /** If SkeletonViewer is ready. */\r\n    private _ready: boolean;\r\n\r\n    /** SkeletonViewer render observable. */\r\n    private _obs: Nullable<Observer<Scene>> = null;\r\n\r\n    /** The Utility Layer to render the gizmos in. */\r\n    private _utilityLayer: Nullable<UtilityLayerRenderer>;\r\n\r\n    private _boneIndices: Set<number>;\r\n\r\n    /** Gets the Scene. */\r\n    get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n    /** Gets the utilityLayer. */\r\n    get utilityLayer(): Nullable<UtilityLayerRenderer> {\r\n        return this._utilityLayer;\r\n    }\r\n    /** Checks Ready Status. */\r\n    get isReady(): Boolean {\r\n        return this._ready;\r\n    }\r\n    /** Sets Ready Status. */\r\n    set ready(value: boolean) {\r\n        this._ready = value;\r\n    }\r\n    /** Gets the debugMesh */\r\n    get debugMesh(): Nullable<AbstractMesh> | Nullable<LinesMesh> {\r\n        return this._debugMesh;\r\n    }\r\n    /** Sets the debugMesh */\r\n    set debugMesh(value: Nullable<AbstractMesh> | Nullable<LinesMesh>) {\r\n        this._debugMesh = value as any;\r\n    }\r\n    /** Gets the displayMode */\r\n    get displayMode(): number {\r\n        return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\r\n    }\r\n    /** Sets the displayMode */\r\n    set displayMode(value: number) {\r\n        if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            value = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.options.displayMode = value;\r\n    }\r\n    /**\r\n     * Creates a new SkeletonViewer\r\n     * @param skeleton defines the skeleton to render\r\n     * @param mesh defines the mesh attached to the skeleton\r\n     * @param scene defines the hosting scene\r\n     * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\r\n     * @param renderingGroupId defines the rendering group id to use with the viewer\r\n     * @param options All of the extra constructor options for the SkeletonViewer\r\n     */\r\n    constructor(\r\n        /** defines the skeleton to render */\r\n        public skeleton: Skeleton,\r\n        /** defines the mesh attached to the skeleton */\r\n        public mesh: AbstractMesh,\r\n        /** The Scene scope*/\r\n        scene: Scene,\r\n        /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\r\n        public autoUpdateBonesMatrices: boolean = true,\r\n        /** defines the rendering group id to use with the viewer */\r\n        public renderingGroupId: number = 3,\r\n        /** is the options for the viewer */\r\n        public options: Partial<ISkeletonViewerOptions> = {}\r\n    ) {\r\n        this._scene = scene;\r\n        this._ready = false;\r\n\r\n        //Defaults\r\n        options.pauseAnimations = options.pauseAnimations ?? true;\r\n        options.returnToRest = options.returnToRest ?? false;\r\n        options.displayMode = options.displayMode ?? SkeletonViewer.DISPLAY_LINES;\r\n        options.displayOptions = options.displayOptions ?? {};\r\n        options.displayOptions.midStep = options.displayOptions.midStep ?? 0.235;\r\n        options.displayOptions.midStepFactor = options.displayOptions.midStepFactor ?? 0.155;\r\n        options.displayOptions.sphereBaseSize = options.displayOptions.sphereBaseSize ?? 0.15;\r\n        options.displayOptions.sphereScaleUnit = options.displayOptions.sphereScaleUnit ?? 2;\r\n        options.displayOptions.sphereFactor = options.displayOptions.sphereFactor ?? 0.865;\r\n        options.displayOptions.spurFollowsChild = options.displayOptions.spurFollowsChild ?? false;\r\n        options.displayOptions.showLocalAxes = options.displayOptions.showLocalAxes ?? false;\r\n        options.displayOptions.localAxesSize = options.displayOptions.localAxesSize ?? 0.075;\r\n        options.computeBonesUsingShaders = options.computeBonesUsingShaders ?? true;\r\n        options.useAllBones = options.useAllBones ?? true;\r\n\r\n        const initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        this._boneIndices = new Set();\r\n\r\n        if (!options.useAllBones) {\r\n            if (initialMeshBoneIndices && initialMeshBoneWeights) {\r\n                for (let i = 0; i < initialMeshBoneIndices.length; ++i) {\r\n                    const index = initialMeshBoneIndices[i],\r\n                        weight = initialMeshBoneWeights[i];\r\n                    if (weight !== 0) {\r\n                        this._boneIndices.add(index);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /* Create Utility Layer */\r\n        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\r\n        this._utilityLayer.pickUtilitySceneFirst = false;\r\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\r\n\r\n        let displayMode = this.options.displayMode || 0;\r\n        if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            displayMode = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.displayMode = displayMode;\r\n        //Prep the Systems\r\n        this.update();\r\n        this._bindObs();\r\n    }\r\n\r\n    /** The Dynamic bindings for the update functions */\r\n    private _bindObs(): void {\r\n        switch (this.displayMode) {\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                this._obs = this.scene.onBeforeRenderObservable.add(() => {\r\n                    this._displayLinesUpdate();\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used to manually update. */\r\n    public update(): void {\r\n        switch (this.displayMode) {\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                this._displayLinesUpdate();\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERES: {\r\n                this._buildSpheresAndSpurs(true);\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS: {\r\n                this._buildSpheresAndSpurs(false);\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._buildLocalAxes();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the viewer is enabled */\r\n    public set isEnabled(value: boolean) {\r\n        if (this.isEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._isEnabled = value;\r\n\r\n        if (this.debugMesh) {\r\n            this.debugMesh.setEnabled(value);\r\n        }\r\n\r\n        if (value && !this._obs) {\r\n            this._bindObs();\r\n        } else if (!value && this._obs) {\r\n            this.scene.onBeforeRenderObservable.remove(this._obs);\r\n            this._obs = null;\r\n        }\r\n    }\r\n\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    private _getBonePosition(position: Vector3, bone: Bone, meshMat: Matrix, x = 0, y = 0, z = 0): void {\r\n        const tmat = TmpVectors.Matrix[0];\r\n        const parentBone = bone.getParent();\r\n        tmat.copyFrom(bone.getLocalMatrix());\r\n\r\n        if (x !== 0 || y !== 0 || z !== 0) {\r\n            const tmat2 = TmpVectors.Matrix[1];\r\n            Matrix.IdentityToRef(tmat2);\r\n            tmat2.setTranslationFromFloats(x, y, z);\r\n            tmat2.multiplyToRef(tmat, tmat);\r\n        }\r\n\r\n        if (parentBone) {\r\n            tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\r\n        }\r\n\r\n        tmat.multiplyToRef(meshMat, tmat);\r\n\r\n        position.x = tmat.m[12];\r\n        position.y = tmat.m[13];\r\n        position.z = tmat.m[14];\r\n    }\r\n\r\n    private _getLinesForBonesWithLength(bones: Bone[], meshMat: Matrix): void {\r\n        const len = bones.length;\r\n\r\n        const mesh = this.mesh;\r\n        const meshPos = mesh.position;\r\n        let idx = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            const bone = bones[i];\r\n            let points = this._debugLines[idx];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[idx] = points;\r\n            }\r\n            this._getBonePosition(points[0], bone, meshMat);\r\n            this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    private _getLinesForBonesNoLength(bones: Bone[]): void {\r\n        const len = bones.length;\r\n        let boneNum = 0;\r\n\r\n        const mesh = this.mesh;\r\n        const meshPos = mesh.position;\r\n        for (let i = len - 1; i >= 0; i--) {\r\n            const childBone = bones[i];\r\n            const parentBone = childBone.getParent();\r\n            if (!parentBone || (!this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            let points = this._debugLines[boneNum];\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[boneNum] = points;\r\n            }\r\n            childBone.getAbsolutePositionToRef(mesh, points[0]);\r\n            parentBone.getAbsolutePositionToRef(mesh, points[1]);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            boneNum++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * function to revert the mesh and scene back to the initial state.\r\n     * @param animationState\r\n     */\r\n    private _revert(animationState: boolean): void {\r\n        if (this.options.pauseAnimations) {\r\n            this.scene.animationsEnabled = animationState;\r\n            this.utilityLayer!.utilityLayerScene!.animationsEnabled = animationState;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.\r\n     * @param bone\r\n     * @param matrix\r\n     */\r\n    private _getAbsoluteBindPoseToRef(bone: Nullable<Bone>, matrix: Matrix) {\r\n        if (bone === null || bone._index === -1) {\r\n            matrix.copyFrom(Matrix.Identity());\r\n            return;\r\n        }\r\n\r\n        this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\r\n        bone.getBaseMatrix().multiplyToRef(matrix, matrix);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * function to build and bind sphere joint points and spur bone representations.\r\n     * @param spheresOnly\r\n     */\r\n    private _buildSpheresAndSpurs(spheresOnly = true): void {\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n\r\n        this._ready = false;\r\n        const utilityLayerScene = this.utilityLayer?.utilityLayerScene!;\r\n        const bones: Bone[] = this.skeleton.bones;\r\n        const spheres: Array<[Mesh, Bone]> = [];\r\n        const spurs: Mesh[] = [];\r\n\r\n        const animationState = this.scene.animationsEnabled;\r\n\r\n        try {\r\n            if (this.options.pauseAnimations) {\r\n                this.scene.animationsEnabled = false;\r\n                utilityLayerScene.animationsEnabled = false;\r\n            }\r\n\r\n            if (this.options.returnToRest) {\r\n                this.skeleton.returnToRest();\r\n            }\r\n\r\n            if (this.autoUpdateBonesMatrices) {\r\n                this.skeleton.computeAbsoluteTransforms();\r\n            }\r\n\r\n            let longestBoneLength = Number.NEGATIVE_INFINITY;\r\n            const displayOptions = this.options.displayOptions || {};\r\n\r\n            for (let i = 0; i < bones.length; i++) {\r\n                const bone = bones[i];\r\n\r\n                if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                    continue;\r\n                }\r\n\r\n                const boneAbsoluteBindPoseTransform = new Matrix();\r\n                this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n\r\n                const anchorPoint = new Vector3();\r\n\r\n                boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\r\n\r\n                bone.children.forEach((bc) => {\r\n                    const childAbsoluteBindPoseTransform: Matrix = new Matrix();\r\n                    bc.getBaseMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\r\n                    const childPoint = new Vector3();\r\n                    childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\r\n                    const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\r\n                    if (distanceFromParent > longestBoneLength) {\r\n                        longestBoneLength = distanceFromParent;\r\n                    }\r\n                    if (spheresOnly) {\r\n                        return;\r\n                    }\r\n\r\n                    const dir = childPoint.clone().subtract(anchorPoint.clone());\r\n                    const h = dir.length();\r\n                    const up = dir.normalize().scale(h);\r\n\r\n                    const midStep = displayOptions.midStep || 0.165;\r\n                    const midStepFactor = displayOptions.midStepFactor || 0.215;\r\n\r\n                    const up0 = up.scale(midStep);\r\n\r\n                    const spur = ExtrudeShapeCustom(\r\n                        \"skeletonViewer\",\r\n                        {\r\n                            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\r\n                            path: [Vector3.Zero(), up0, up],\r\n                            scaleFunction: (i: number) => {\r\n                                switch (i) {\r\n                                    case 0:\r\n                                    case 2:\r\n                                        return 0;\r\n                                    case 1:\r\n                                        return h * midStepFactor;\r\n                                }\r\n                                return 0;\r\n                            },\r\n                            sideOrientation: Mesh.DEFAULTSIDE,\r\n                            updatable: false,\r\n                        },\r\n                        utilityLayerScene\r\n                    );\r\n\r\n                    const numVertices = spur.getTotalVertices();\r\n                    const mwk: number[] = [],\r\n                        mik: number[] = [];\r\n\r\n                    for (let i = 0; i < numVertices; i++) {\r\n                        mwk.push(1, 0, 0, 0);\r\n\r\n                        // Select verts at end of spur (ie vert 10 to 14) and bind to child\r\n                        // bone if spurFollowsChild is enabled.\r\n                        if (displayOptions.spurFollowsChild && i > 9) {\r\n                            mik.push(bc.getIndex(), 0, 0, 0);\r\n                        } else {\r\n                            mik.push(bone.getIndex(), 0, 0, 0);\r\n                        }\r\n                    }\r\n\r\n                    spur.position = anchorPoint.clone();\r\n\r\n                    spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                    spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n                    spur.convertToFlatShadedMesh();\r\n\r\n                    spurs.push(spur);\r\n                });\r\n\r\n                const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;\r\n\r\n                const sphere = CreateSphere(\r\n                    \"skeletonViewer\",\r\n                    {\r\n                        segments: 6,\r\n                        diameter: sphereBaseSize,\r\n                        updatable: true,\r\n                    },\r\n                    utilityLayerScene\r\n                );\r\n\r\n                const numVertices = sphere.getTotalVertices();\r\n\r\n                const mwk: number[] = [],\r\n                    mik: number[] = [];\r\n\r\n                for (let i = 0; i < numVertices; i++) {\r\n                    mwk.push(1, 0, 0, 0);\r\n                    mik.push(bone.getIndex(), 0, 0, 0);\r\n                }\r\n\r\n                sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n\r\n                sphere.position = anchorPoint.clone();\r\n                spheres.push([sphere, bone]);\r\n            }\r\n\r\n            const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;\r\n            const sphereFactor = displayOptions.sphereFactor || 0.85;\r\n\r\n            const meshes = [];\r\n            for (let i = 0; i < spheres.length; i++) {\r\n                const [sphere, bone] = spheres[i];\r\n                const scale = 1 / (sphereScaleUnit / longestBoneLength);\r\n\r\n                let _stepsOut = 0;\r\n                let _b = bone;\r\n\r\n                while (_b.getParent() && (_b.getParent() as Bone).getIndex() !== -1) {\r\n                    _stepsOut++;\r\n                    _b = _b.getParent() as Bone;\r\n                }\r\n                sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\r\n                meshes.push(sphere);\r\n            }\r\n\r\n            this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\r\n            if (this.debugMesh) {\r\n                this.debugMesh.renderingGroupId = this.renderingGroupId;\r\n                this.debugMesh.skeleton = this.skeleton;\r\n                this.debugMesh.parent = this.mesh;\r\n                this.debugMesh.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n                this.debugMesh.alwaysSelectAsActiveMesh = true;\r\n            }\r\n\r\n            const light = this.utilityLayer!._getSharedGizmoLight();\r\n            light.intensity = 0.7;\r\n\r\n            this._revert(animationState);\r\n            this.ready = true;\r\n        } catch (err) {\r\n            console.error(err);\r\n            this._revert(animationState);\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    private _buildLocalAxes(): void {\r\n        if (this._localAxes) {\r\n            this._localAxes.dispose();\r\n        }\r\n\r\n        this._localAxes = null;\r\n\r\n        const displayOptions = this.options.displayOptions || {};\r\n\r\n        if (!displayOptions.showLocalAxes) {\r\n            return;\r\n        }\r\n\r\n        const targetScene = this._utilityLayer!.utilityLayerScene;\r\n        const size = displayOptions.localAxesSize || 0.075;\r\n        const lines = [];\r\n        const colors = [];\r\n        const red = new Color4(1, 0, 0, 1);\r\n        const green = new Color4(0, 1, 0, 1);\r\n        const blue = new Color4(0, 0, 1, 1);\r\n\r\n        const mwk: number[] = [];\r\n        const mik: number[] = [];\r\n        const vertsPerBone = 6;\r\n\r\n        for (const i in this.skeleton.bones) {\r\n            const bone = this.skeleton.bones[i];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n\r\n            const boneAbsoluteBindPoseTransform = new Matrix();\r\n            const boneOrigin = new Vector3();\r\n\r\n            this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n            boneAbsoluteBindPoseTransform.decompose(undefined, TmpVectors.Quaternion[0], boneOrigin);\r\n\r\n            const m = new Matrix();\r\n            TmpVectors.Quaternion[0].toRotationMatrix(m);\r\n\r\n            const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\r\n            const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\r\n            const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\r\n\r\n            const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\r\n            const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\r\n            const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\r\n\r\n            const linePoints = [axisX, axisY, axisZ];\r\n            const lineColors = [\r\n                [red, red],\r\n                [green, green],\r\n                [blue, blue],\r\n            ];\r\n\r\n            lines.push(...linePoints);\r\n            colors.push(...lineColors);\r\n\r\n            for (let j = 0; j < vertsPerBone; j++) {\r\n                mwk.push(1, 0, 0, 0);\r\n                mik.push(bone.getIndex(), 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        this._localAxes = CreateLineSystem(\"localAxes\", { lines: lines, colors: colors, updatable: true }, targetScene);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n        this._localAxes.skeleton = this.skeleton;\r\n        this._localAxes.renderingGroupId = this.renderingGroupId + 1;\r\n        this._localAxes.parent = this.mesh;\r\n        this._localAxes.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used for the line display. */\r\n    private _displayLinesUpdate(): void {\r\n        if (!this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        if (this.autoUpdateBonesMatrices) {\r\n            this.skeleton.computeAbsoluteTransforms();\r\n        }\r\n\r\n        if (this.skeleton.bones[0].length === undefined) {\r\n            this._getLinesForBonesNoLength(this.skeleton.bones);\r\n        } else {\r\n            this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());\r\n        }\r\n\r\n        const targetScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        if (targetScene) {\r\n            if (!this._debugMesh) {\r\n                this._debugMesh = CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: null }, targetScene);\r\n                this._debugMesh.renderingGroupId = this.renderingGroupId;\r\n            } else {\r\n                CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);\r\n            }\r\n            this._debugMesh.position.copyFrom(this.mesh.position);\r\n            this._debugMesh.color = this.color;\r\n        }\r\n    }\r\n    /** Changes the displayMode of the skeleton viewer\r\n     * @param mode The displayMode numerical value\r\n     */\r\n    public changeDisplayMode(mode: number): void {\r\n        const wasEnabled = this.isEnabled ? true : false;\r\n        if (this.displayMode !== mode) {\r\n            this.isEnabled = false;\r\n            if (this._debugMesh) {\r\n                this._debugMesh.dispose();\r\n                this._debugMesh = null;\r\n                this.ready = false;\r\n            }\r\n            this.displayMode = mode;\r\n\r\n            this.update();\r\n            this._bindObs();\r\n            this.isEnabled = wasEnabled;\r\n        }\r\n    }\r\n\r\n    /** Sets a display option of the skeleton viewer\r\n     *\r\n     * | Option           | Type    | Default | Description |\r\n     * | ---------------- | ------- | ------- | ----------- |\r\n     * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\r\n     * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\r\n     * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\r\n     *\r\n     * @param option String of the option name\r\n     * @param value The numerical option value\r\n     */\r\n    public changeDisplayOptions(option: string, value: number): void {\r\n        const wasEnabled = this.isEnabled ? true : false;\r\n        (this.options.displayOptions as any)[option] = value;\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n        this.update();\r\n        this._bindObs();\r\n        this.isEnabled = wasEnabled;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose(): void {\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n        }\r\n\r\n        if (this._utilityLayer) {\r\n            this._utilityLayer.dispose();\r\n            this._utilityLayer = null;\r\n        }\r\n\r\n        this.ready = false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}