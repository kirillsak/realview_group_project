{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PivotTools } from \"../Misc/pivotTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Bounding box gizmo\n */\nexport class BoundingBoxGizmo extends Gizmo {\n  /**\n   * Creates an BoundingBoxGizmo\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n    super(gizmoLayer);\n    this._boundingDimensions = new Vector3(1, 1, 1);\n    this._renderObserver = null;\n    this._pointerObserver = null;\n    this._scaleDragSpeed = 0.2;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVector = new Vector3(0, 0, 0);\n    this._tmpRotationMatrix = new Matrix();\n    /**\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\n     */\n    this.ignoreChildren = false;\n    /**\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\n     */\n    this.includeChildPredicate = null;\n    /**\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\n     */\n    this.rotationSphereSize = 0.1;\n    /**\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\n     */\n    this.scaleBoxSize = 0.1;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n    this.fixedDragMeshScreenSize = false;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n    this.fixedDragMeshBoundsSize = false;\n    /**\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\n     */\n    this.fixedDragMeshScreenSizeDistanceFactor = 10;\n    /**\n     * Fired when a rotation sphere or scale box is dragged\n     */\n    this.onDragStartObservable = new Observable();\n    /**\n     * Fired when a scale box is dragged\n     */\n    this.onScaleBoxDragObservable = new Observable();\n    /**\n     * Fired when a scale box drag is ended\n     */\n    this.onScaleBoxDragEndObservable = new Observable();\n    /**\n     * Fired when a rotation sphere is dragged\n     */\n    this.onRotationSphereDragObservable = new Observable();\n    /**\n     * Fired when a rotation sphere drag is ended\n     */\n    this.onRotationSphereDragEndObservable = new Observable();\n    /**\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\n     */\n    this.scalePivot = null;\n    /**\n     * Scale factor used for masking some axis\n     */\n    this._axisFactor = new Vector3(1, 1, 1);\n    this._existingMeshScale = new Vector3();\n    // Dragging\n    this._dragMesh = null;\n    this._pointerDragBehavior = new PointerDragBehavior();\n    // Do not update the gizmo's scale so it has a fixed size to the object its attached to\n    this.updateScale = false;\n    this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene);\n    // Create Materials\n    this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.disableLighting = true;\n    this._hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._hoverColoredMaterial.disableLighting = true;\n    // Build bounding box out of lines\n    this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._lineBoundingBox.rotationQuaternion = new Quaternion();\n    const lines = [];\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.forEach(l => {\n      l.color = color;\n      l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n      l.isPickable = false;\n      this._lineBoundingBox.addChild(l);\n    });\n    this._rootMesh.addChild(this._lineBoundingBox);\n    this.setColor(color);\n    // Create rotation spheres\n    this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._rotateSpheresParent.rotationQuaternion = new Quaternion();\n    for (let i = 0; i < 12; i++) {\n      const sphere = CreateSphere(\"\", {\n        diameter: 1\n      }, gizmoLayer.utilityLayerScene);\n      sphere.rotationQuaternion = new Quaternion();\n      sphere.material = this._coloredMaterial;\n      sphere.isNearGrabbable = true;\n      // Drag behavior\n      const _dragBehavior = new PointerDragBehavior({});\n      _dragBehavior.moveAttached = false;\n      _dragBehavior.updateDragPlane = false;\n      sphere.addBehavior(_dragBehavior);\n      const startingTurnDirection = new Vector3(1, 0, 0);\n      let totalTurnAmountOfDrag = 0;\n      _dragBehavior.onDragStartObservable.add(() => {\n        startingTurnDirection.copyFrom(sphere.forward);\n        totalTurnAmountOfDrag = 0;\n      });\n      _dragBehavior.onDragObservable.add(event => {\n        this.onRotationSphereDragObservable.notifyObservers({});\n        if (this.attachedMesh) {\n          const originalParent = this.attachedMesh.parent;\n          if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n            Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n            return;\n          }\n          PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n          const worldDragDirection = startingTurnDirection;\n          // Project the world right on to the drag plane\n          const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\n          const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();\n          // project drag delta on to the resulting drag axis and rotate based on that\n          let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());\n          // Make rotation relative to size of mesh.\n          projectDist = projectDist / this._boundingDimensions.length() * this._anchorMesh.scaling.length();\n          // Rotate based on axis\n          if (!this.attachedMesh.rotationQuaternion) {\n            this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n          }\n          if (!this._anchorMesh.rotationQuaternion) {\n            this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n          }\n          // Do not allow the object to turn more than a full circle\n          totalTurnAmountOfDrag += projectDist;\n          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\n            if (i >= 8) {\n              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);\n            } else if (i >= 4) {\n              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);\n            } else {\n              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);\n            }\n            // Rotate around center of bounding box\n            this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);\n            if (this._anchorMesh.getScene().useRightHandedSystem) {\n              this._tmpQuaternion.conjugateInPlace();\n            }\n            this._anchorMesh.rotationQuaternion.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion);\n            this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);\n            this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\n          }\n          this.updateBoundingBox();\n          PivotTools._RestorePivotPoint(this.attachedMesh);\n        }\n        this._updateDummy();\n      });\n      // Selection/deselection\n      _dragBehavior.onDragStartObservable.add(() => {\n        this.onDragStartObservable.notifyObservers({});\n        this._selectNode(sphere);\n      });\n      _dragBehavior.onDragEndObservable.add(event => {\n        this.onRotationSphereDragEndObservable.notifyObservers({});\n        this._selectNode(null);\n        this._updateDummy();\n        this._unhoverMeshOnTouchUp(event.pointerInfo, sphere);\n      });\n      this._rotateSpheresParent.addChild(sphere);\n    }\n    this._rootMesh.addChild(this._rotateSpheresParent);\n    // Create scale cubes\n    this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._scaleBoxesParent.rotationQuaternion = new Quaternion();\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          // create box for relevant axis\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          const box = CreateBox(\"\", {\n            size: 1\n          }, gizmoLayer.utilityLayerScene);\n          box.material = this._coloredMaterial;\n          box._internalMetadata = zeroAxisCount === 2; // None homogenous scale handle\n          box.isNearGrabbable = true;\n          // Dragging logic\n          const dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\n          const _dragBehavior = new PointerDragBehavior({\n            dragAxis: dragAxis\n          });\n          _dragBehavior.updateDragPlane = false;\n          _dragBehavior.moveAttached = false;\n          box.addBehavior(_dragBehavior);\n          _dragBehavior.onDragObservable.add(event => {\n            this.onScaleBoxDragObservable.notifyObservers({});\n            if (this.attachedMesh) {\n              const originalParent = this.attachedMesh.parent;\n              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n                return;\n              }\n              PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n              const relativeDragDistance = event.dragDistance / this._boundingDimensions.length() * this._anchorMesh.scaling.length();\n              const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\n              if (zeroAxisCount === 2) {\n                // scale on 1 axis when using the anchor box in the face middle\n                deltaScale.x *= Math.abs(dragAxis.x);\n                deltaScale.y *= Math.abs(dragAxis.y);\n                deltaScale.z *= Math.abs(dragAxis.z);\n              }\n              deltaScale.scaleInPlace(this._scaleDragSpeed);\n              deltaScale.multiplyInPlace(this._axisFactor);\n              this.updateBoundingBox();\n              if (this.scalePivot) {\n                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);\n                // Move anchor to desired pivot point (Bottom left corner + dimension/2)\n                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);\n                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\n                this._anchorMesh.position.subtractInPlace(this._tmpVector);\n                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);\n                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\n                this._anchorMesh.position.addInPlace(this._tmpVector);\n              } else {\n                // Scale from the position of the opposite corner\n                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);\n                this._anchorMesh.position.subtractInPlace(this._tmpVector);\n              }\n              this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);\n              this._anchorMesh.scaling.addInPlace(deltaScale);\n              if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {\n                this._anchorMesh.scaling.subtractInPlace(deltaScale);\n              }\n              this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);\n              this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\n              PivotTools._RestorePivotPoint(this.attachedMesh);\n            }\n            this._updateDummy();\n          });\n          // Selection/deselection\n          _dragBehavior.onDragStartObservable.add(() => {\n            this.onDragStartObservable.notifyObservers({});\n            this._selectNode(box);\n          });\n          _dragBehavior.onDragEndObservable.add(event => {\n            this.onScaleBoxDragEndObservable.notifyObservers({});\n            this._selectNode(null);\n            this._updateDummy();\n            this._unhoverMeshOnTouchUp(event.pointerInfo, box);\n          });\n          this._scaleBoxesParent.addChild(box);\n        }\n      }\n    }\n    this._rootMesh.addChild(this._scaleBoxesParent);\n    // Hover color change\n    const pointerIds = new Array();\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!pointerIds[pointerInfo.event.pointerId]) {\n        this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(mesh => {\n          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\n            pointerIds[pointerInfo.event.pointerId] = mesh;\n            mesh.material = this._hoverColoredMaterial;\n          }\n        });\n      } else {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {\n          pointerIds[pointerInfo.event.pointerId].material = this._coloredMaterial;\n          delete pointerIds[pointerInfo.event.pointerId];\n        }\n      }\n    });\n    // Update bounding box positions\n    this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\n      // Only update the bounding box if scaling has changed\n      if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {\n        this.updateBoundingBox();\n      } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {\n        this._updateRotationSpheres();\n        this._updateScaleBoxes();\n      }\n      // If drag mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\n      if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {\n        this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion, this._tmpVector);\n        this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));\n      }\n    });\n    this.updateBoundingBox();\n  }\n  /**\n   * Sets the axis factor\n   * @param factor the Vector3 value\n   */\n  set axisFactor(factor) {\n    this._axisFactor = factor;\n    // update scale cube visibility\n    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          if (scaleBoxes[index]) {\n            const dragAxis = new Vector3(i - 1, j - 1, k - 1);\n            dragAxis.multiplyInPlace(this._axisFactor);\n            scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);\n          }\n          index++;\n        }\n      }\n    }\n  }\n  /**\n   * Gets the axis factor\n   * @returns the Vector3 factor value\n   */\n  get axisFactor() {\n    return this._axisFactor;\n  }\n  /**\n   * Sets scale drag speed value\n   * @param value the new speed value\n   */\n  set scaleDragSpeed(value) {\n    this._scaleDragSpeed = value;\n  }\n  /**\n   * Gets scale drag speed\n   * @returns the scale speed number\n   */\n  get scaleDragSpeed() {\n    return this._scaleDragSpeed;\n  }\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse*/\n  get hoverMaterial() {\n    return this._hoverColoredMaterial;\n  }\n  /**\n   * Get the pointerDragBehavior\n   */\n  get pointerDragBehavior() {\n    return this._pointerDragBehavior;\n  }\n  /**\n   * Sets the color of the bounding box gizmo\n   * @param color the color to set\n   */\n  setColor(color) {\n    this._coloredMaterial.emissiveColor = color;\n    this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\n    this._lineBoundingBox.getChildren().forEach(l => {\n      if (l.color) {\n        l.color = color;\n      }\n    });\n  }\n  _attachedNodeChanged(value) {\n    if (value) {\n      // Reset anchor mesh to match attached mesh's scale\n      // This is needed to avoid invalid box/sphere position on first drag\n      this._anchorMesh.scaling.setAll(1);\n      PivotTools._RemoveAndStorePivotPoint(value);\n      const originalParent = value.parent;\n      this._anchorMesh.addChild(value, Gizmo.PreserveScaling);\n      this._anchorMesh.removeChild(value, Gizmo.PreserveScaling);\n      value.setParent(originalParent, Gizmo.PreserveScaling);\n      PivotTools._RestorePivotPoint(value);\n      this.updateBoundingBox();\n      value.getChildMeshes(false).forEach(m => {\n        m.markAsDirty(\"scaling\");\n      });\n      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {\n        this._updateDummy();\n      });\n    }\n  }\n  _selectNode(selectedMesh) {\n    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(m => {\n      m.isVisible = !selectedMesh || m == selectedMesh;\n    });\n  }\n  _unhoverMeshOnTouchUp(pointerInfo, selectedMesh) {\n    // force unhover mesh if not a mouse event\n    if ((pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.event) instanceof PointerEvent && (pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.event.pointerType) === \"touch\") {\n      selectedMesh.material = this._coloredMaterial;\n    }\n  }\n  /**\n   * returns an array containing all boxes used for scaling (in increasing x, y and z orders)\n   */\n  getScaleBoxes() {\n    return this._scaleBoxesParent.getChildMeshes();\n  }\n  /**\n   * Updates the bounding box information for the Gizmo\n   */\n  updateBoundingBox() {\n    if (this.attachedMesh) {\n      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n      // Store original parent\n      const originalParent = this.attachedMesh.parent;\n      this.attachedMesh.setParent(null, Gizmo.PreserveScaling);\n      this._update();\n      // Rotate based on axis\n      if (!this.attachedMesh.rotationQuaternion) {\n        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n      }\n      if (!this._anchorMesh.rotationQuaternion) {\n        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n      }\n      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n      // Store original position and reset mesh to origin before computing the bounding box\n      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n      this._tmpVector.copyFrom(this.attachedMesh.position);\n      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\n      this.attachedMesh.position.set(0, 0, 0);\n      // Update bounding dimensions/positions\n      const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\n      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\n      // Update gizmo to match bounding box scaling and rotation\n      // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\n      // The position of the gizmo is then set to the attachedMesh in gizmo._update\n      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\n      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\n      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\n      this._lineBoundingBox.computeWorldMatrix();\n      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);\n      // Restore position/rotation values\n      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\n      this.attachedMesh.position.copyFrom(this._tmpVector);\n      // Restore original parent\n      this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\n    }\n    this._updateRotationSpheres();\n    this._updateScaleBoxes();\n    if (this.attachedMesh) {\n      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\n      PivotTools._RestorePivotPoint(this.attachedMesh);\n    }\n  }\n  _updateRotationSpheres() {\n    const rotateSpheres = this._rotateSpheresParent.getChildMeshes();\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 2; j++) {\n        for (let k = 0; k < 2; k++) {\n          const index = i * 4 + j * 2 + k;\n          if (i == 0) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (i == 1) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (i == 2) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n            const distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n          } else if (this.fixedDragMeshBoundsSize) {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);\n          } else {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\n          }\n        }\n      }\n    }\n  }\n  _updateScaleBoxes() {\n    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          if (scaleBoxes[index]) {\n            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\n            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n              const distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n            } else if (this.fixedDragMeshBoundsSize) {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);\n            } else {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\n            }\n          }\n          index++;\n        }\n      }\n    }\n  }\n  /**\n   * Enables rotation on the specified axis and disables rotation on the others\n   * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\n   */\n  setEnabledRotationAxis(axis) {\n    this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {\n      if (i < 4) {\n        m.setEnabled(axis.indexOf(\"x\") != -1);\n      } else if (i < 8) {\n        m.setEnabled(axis.indexOf(\"y\") != -1);\n      } else {\n        m.setEnabled(axis.indexOf(\"z\") != -1);\n      }\n    });\n  }\n  /**\n   * Enables/disables scaling\n   * @param enable if scaling should be enabled\n   * @param homogeneousScaling defines if scaling should only be homogeneous\n   */\n  setEnabledScaling(enable, homogeneousScaling = false) {\n    this._scaleBoxesParent.getChildMeshes().forEach(m => {\n      let enableMesh = enable;\n      // Disable heterogeneous scale handles if requested.\n      if (homogeneousScaling && m._internalMetadata === true) {\n        enableMesh = false;\n      }\n      m.setEnabled(enableMesh);\n    });\n  }\n  _updateDummy() {\n    if (this._dragMesh) {\n      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\n      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\n      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);\n    }\n  }\n  /**\n   * Enables a pointer drag behavior on the bounding box of the gizmo\n   */\n  enableDragBehavior() {\n    this._dragMesh = CreateBox(\"dummy\", {\n      size: 1\n    }, this.gizmoLayer.utilityLayerScene);\n    this._dragMesh.visibility = 0;\n    this._dragMesh.rotationQuaternion = new Quaternion();\n    this._pointerDragBehavior.useObjectOrientationForDragging = false;\n    this._dragMesh.addBehavior(this._pointerDragBehavior);\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\n    this._lineBoundingBox.dispose();\n    this._rotateSpheresParent.dispose();\n    this._scaleBoxesParent.dispose();\n    if (this._dragMesh) {\n      this._dragMesh.dispose();\n    }\n    super.dispose();\n  }\n  /**\n   * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\n   * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\n   * @returns the bounding box mesh with the passed in mesh as a child\n   */\n  static MakeNotPickableAndWrapInBoundingBox(mesh) {\n    const makeNotPickable = root => {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(c => {\n        makeNotPickable(c);\n      });\n    };\n    makeNotPickable(mesh);\n    // Reset position to get bounding box from origin with no rotation\n    if (!mesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\n    }\n    const oldPos = mesh.position.clone();\n    const oldRot = mesh.rotationQuaternion.clone();\n    mesh.rotationQuaternion.set(0, 0, 0, 1);\n    mesh.position.set(0, 0, 0);\n    // Update bounding dimensions/positions\n    const box = CreateBox(\"box\", {\n      size: 1\n    }, mesh.getScene());\n    const boundingMinMax = mesh.getHierarchyBoundingVectors();\n    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);\n    // Adjust scale to avoid undefined behavior when adding child\n    if (box.scaling.y === 0) {\n      box.scaling.y = Epsilon;\n    }\n    if (box.scaling.x === 0) {\n      box.scaling.x = Epsilon;\n    }\n    if (box.scaling.z === 0) {\n      box.scaling.z = Epsilon;\n    }\n    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n    // Restore original positions\n    mesh.addChild(box);\n    mesh.rotationQuaternion.copyFrom(oldRot);\n    mesh.position.copyFrom(oldPos);\n    // Reverse parenting\n    mesh.removeChild(box);\n    box.addChild(mesh);\n    box.visibility = 0;\n    return box;\n  }\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n  setCustomMesh() {\n    Logger.Error(\"Custom meshes are not supported on this gizmo\");\n  }\n}","map":{"version":3,"mappings":"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","names":["Observable","Logger","Quaternion","Matrix","Vector3","AbstractMesh","CreateSphere","CreateBox","CreateLines","PointerDragBehavior","Gizmo","UtilityLayerRenderer","StandardMaterial","PivotTools","Color3","Epsilon","BoundingBoxGizmo","constructor","color","Gray","gizmoLayer","DefaultKeepDepthUtilityLayer","updateScale","_anchorMesh","utilityLayerScene","_coloredMaterial","disableLighting","_hoverColoredMaterial","_lineBoundingBox","rotationQuaternion","lines","push","points","_boundingDimensions","x","y","z","forEach","l","position","addInPlace","isPickable","addChild","_rootMesh","setColor","_rotateSpheresParent","i","sphere","diameter","material","isNearGrabbable","_dragBehavior","moveAttached","updateDragPlane","addBehavior","startingTurnDirection","totalTurnAmountOfDrag","onDragStartObservable","add","copyFrom","forward","onDragObservable","event","onRotationSphereDragObservable","notifyObservers","attachedMesh","originalParent","parent","scaling","isNonUniformWithinEpsilon","Warn","_RemoveAndStorePivotPoint","worldDragDirection","toSub","dragPlaneNormal","scale","Dot","dragAxis","subtract","normalizeToNew","projectDist","delta","Math","abs","length","RotationYawPitchRoll","rotation","PI","RotationYawPitchRollToRef","_tmpQuaternion","PreserveScaling","getScene","useRightHandedSystem","conjugateInPlace","multiplyToRef","removeChild","setParent","updateBoundingBox","_RestorePivotPoint","_updateDummy","_selectNode","onDragEndObservable","onRotationSphereDragEndObservable","_unhoverMeshOnTouchUp","pointerInfo","_scaleBoxesParent","j","k","zeroAxisCount","box","size","_internalMetadata","normalize","onScaleBoxDragObservable","relativeDragDistance","dragDistance","deltaScale","scaleInPlace","_scaleDragSpeed","multiplyInPlace","_axisFactor","scalePivot","getWorldMatrix","getRotationMatrixToRef","_tmpRotationMatrix","scaleToRef","_tmpVector","TransformCoordinatesToRef","subtractInPlace","absolutePosition","subtractToRef","onScaleBoxDragEndObservable","pointerIds","Array","_pointerObserver","onPointerObservable","pointerId","getChildMeshes","concat","mesh","pickInfo","pickedMesh","_renderObserver","originalScene","onBeforeRenderObservable","_existingMeshScale","equals","fixedDragMeshScreenSize","fixedDragMeshBoundsSize","_updateRotationSpheres","_updateScaleBoxes","_dragMesh","_pointerDragBehavior","dragging","rotateByQuaternionToRef","setAbsolutePosition","axisFactor","factor","scaleBoxes","index","setEnabled","lengthSquared","scaleDragSpeed","value","coloredMaterial","hoverMaterial","pointerDragBehavior","emissiveColor","clone","getChildren","_attachedNodeChanged","setAll","m","markAsDirty","onAfterRenderObservable","addOnce","selectedMesh","isVisible","PointerEvent","pointerType","getScaleBoxes","_update","set","boundingMinMax","getHierarchyBoundingVectors","ignoreChildren","includeChildPredicate","max","min","computeWorldMatrix","rotateSpheres","lookAt","Cross","Right","Up","Forward","activeCamera","distanceFromCamera","rotationSphereSize","fixedDragMeshScreenSizeDistanceFactor","scaleBoxSize","setEnabledRotationAxis","axis","indexOf","setEnabledScaling","enable","homogeneousScaling","enableMesh","getAbsolutePosition","enableDragBehavior","visibility","useObjectOrientationForDragging","dispose","remove","MakeNotPickableAndWrapInBoundingBox","makeNotPickable","root","c","oldPos","oldRot","setCustomMesh","Error"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gizmos/boundingBoxGizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder\";\r\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { PivotTools } from \"../Misc/pivotTools\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Interface for bounding box gizmo\r\n */\r\nexport interface IBoundingBoxGizmo extends IGizmo {\r\n    /**\r\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes.\r\n     */\r\n    ignoreChildren: boolean;\r\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored.\r\n     */\r\n    includeChildPredicate: Nullable<(abstractMesh: AbstractMesh) => boolean>;\r\n    /** The size of the rotation spheres attached to the bounding box */\r\n    rotationSphereSize: number;\r\n    /** The size of the scale boxes attached to the bounding box */\r\n    scaleBoxSize: number;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    fixedDragMeshScreenSize: boolean;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    fixedDragMeshBoundsSize: boolean;\r\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true\r\n     */\r\n    fixedDragMeshScreenSizeDistanceFactor: number;\r\n    /** Fired when a rotation sphere or scale box is dragged */\r\n    onDragStartObservable: Observable<{}>;\r\n    /** Fired when a scale box is dragged */\r\n    onScaleBoxDragObservable: Observable<{}>;\r\n    /** Fired when a scale box drag is ended */\r\n    onScaleBoxDragEndObservable: Observable<{}>;\r\n    /** Fired when a rotation sphere is dragged */\r\n    onRotationSphereDragObservable: Observable<{}>;\r\n    /** Fired when a rotation sphere drag is ended */\r\n    onRotationSphereDragEndObservable: Observable<{}>;\r\n    /** Relative bounding box pivot used when scaling the attached node. */\r\n    scalePivot: Nullable<Vector3>;\r\n    /** Scale factor vector used for masking some axis */\r\n    axisFactor: Vector3;\r\n    /** Scale factor scalar affecting all axes' drag speed */\r\n    scaleDragSpeed: number;\r\n    /**\r\n     * Sets the color of the bounding box gizmo\r\n     * @param color the color to set\r\n     */\r\n    setColor(color: Color3): void;\r\n    /** Returns an array containing all boxes used for scaling (in increasing x, y and z orders) */\r\n    getScaleBoxes(): AbstractMesh[];\r\n    /** Updates the bounding box information for the Gizmo */\r\n    updateBoundingBox(): void;\r\n    /**\r\n     * Enables rotation on the specified axis and disables rotation on the others\r\n     * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n     */\r\n    setEnabledRotationAxis(axis: string): void;\r\n    /**\r\n     * Enables/disables scaling\r\n     * @param enable if scaling should be enabled\r\n     * @param homogeneousScaling defines if scaling should only be homogeneous\r\n     */\r\n    setEnabledScaling(enable: boolean, homogeneousScaling?: boolean): void;\r\n    /** Enables a pointer drag behavior on the bounding box of the gizmo */\r\n    enableDragBehavior(): void;\r\n\r\n    /** Default material used to render when gizmo is not disabled or hovered */\r\n    coloredMaterial: StandardMaterial;\r\n    /** Material used to render when gizmo is hovered with mouse*/\r\n    hoverMaterial: StandardMaterial;\r\n}\r\n\r\n/**\r\n * Bounding box gizmo\r\n */\r\nexport class BoundingBoxGizmo extends Gizmo implements IBoundingBoxGizmo {\r\n    protected _lineBoundingBox: AbstractMesh;\r\n    protected _rotateSpheresParent: AbstractMesh;\r\n    protected _scaleBoxesParent: AbstractMesh;\r\n    protected _boundingDimensions = new Vector3(1, 1, 1);\r\n    protected _renderObserver: Nullable<Observer<Scene>> = null;\r\n    protected _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n    protected _scaleDragSpeed = 0.2;\r\n\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _tmpRotationMatrix = new Matrix();\r\n    /**\r\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\r\n     */\r\n    public ignoreChildren = false;\r\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\r\n     */\r\n    public includeChildPredicate: Nullable<(abstractMesh: AbstractMesh) => boolean> = null;\r\n\r\n    /**\r\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\r\n     */\r\n    public rotationSphereSize = 0.1;\r\n    /**\r\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\r\n     */\r\n    public scaleBoxSize = 0.1;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshScreenSize = false;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshBoundsSize = false;\r\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\r\n     */\r\n    public fixedDragMeshScreenSizeDistanceFactor = 10;\r\n    /**\r\n     * Fired when a rotation sphere or scale box is dragged\r\n     */\r\n    public onDragStartObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a scale box is dragged\r\n     */\r\n    public onScaleBoxDragObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a scale box drag is ended\r\n     */\r\n    public onScaleBoxDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere is dragged\r\n     */\r\n    public onRotationSphereDragObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere drag is ended\r\n     */\r\n    public onRotationSphereDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\r\n     */\r\n    public scalePivot: Nullable<Vector3> = null;\r\n    /**\r\n     * Scale factor used for masking some axis\r\n     */\r\n    protected _axisFactor = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Sets the axis factor\r\n     * @param factor the Vector3 value\r\n     */\r\n    public set axisFactor(factor: Vector3) {\r\n        this._axisFactor = factor;\r\n        // update scale cube visibility\r\n        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\r\n        let index = 0;\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n                    if (scaleBoxes[index]) {\r\n                        const dragAxis = new Vector3(i - 1, j - 1, k - 1);\r\n                        dragAxis.multiplyInPlace(this._axisFactor);\r\n                        scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the axis factor\r\n     * @returns the Vector3 factor value\r\n     */\r\n    public get axisFactor(): Vector3 {\r\n        return this._axisFactor;\r\n    }\r\n\r\n    /**\r\n     * Sets scale drag speed value\r\n     * @param value the new speed value\r\n     */\r\n    public set scaleDragSpeed(value: number) {\r\n        this._scaleDragSpeed = value;\r\n    }\r\n\r\n    /**\r\n     * Gets scale drag speed\r\n     * @returns the scale speed number\r\n     */\r\n    public get scaleDragSpeed(): number {\r\n        return this._scaleDragSpeed;\r\n    }\r\n\r\n    /**\r\n     * Mesh used as a pivot to rotate the attached node\r\n     */\r\n    protected _anchorMesh: AbstractMesh;\r\n\r\n    protected _existingMeshScale = new Vector3();\r\n\r\n    // Dragging\r\n    protected _dragMesh: Nullable<Mesh> = null;\r\n    protected _pointerDragBehavior = new PointerDragBehavior();\r\n\r\n    protected _coloredMaterial: StandardMaterial;\r\n    protected _hoverColoredMaterial: StandardMaterial;\r\n\r\n    /** Default material used to render when gizmo is not disabled or hovered */\r\n    public get coloredMaterial() {\r\n        return this._coloredMaterial;\r\n    }\r\n\r\n    /** Material used to render when gizmo is hovered with mouse*/\r\n    public get hoverMaterial() {\r\n        return this._hoverColoredMaterial;\r\n    }\r\n    /**\r\n     * Get the pointerDragBehavior\r\n     */\r\n    public get pointerDragBehavior(): PointerDragBehavior {\r\n        return this._pointerDragBehavior;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the bounding box gizmo\r\n     * @param color the color to set\r\n     */\r\n    public setColor(color: Color3) {\r\n        this._coloredMaterial.emissiveColor = color;\r\n        this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\r\n        this._lineBoundingBox.getChildren().forEach((l) => {\r\n            if ((l as LinesMesh).color) {\r\n                (l as LinesMesh).color = color;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Creates an BoundingBoxGizmo\r\n     * @param color The color of the gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\r\n        super(gizmoLayer);\r\n\r\n        // Do not update the gizmo's scale so it has a fixed size to the object its attached to\r\n        this.updateScale = false;\r\n\r\n        this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene);\r\n        // Create Materials\r\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._coloredMaterial.disableLighting = true;\r\n        this._hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this._hoverColoredMaterial.disableLighting = true;\r\n\r\n        // Build bounding box out of lines\r\n        this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._lineBoundingBox.rotationQuaternion = new Quaternion();\r\n        const lines = [];\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.push(\r\n            CreateLines(\r\n                \"lines\",\r\n                {\r\n                    points: [\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),\r\n                        new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0),\r\n                    ],\r\n                },\r\n                gizmoLayer.utilityLayerScene\r\n            )\r\n        );\r\n        lines.forEach((l) => {\r\n            l.color = color;\r\n            l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n            l.isPickable = false;\r\n            this._lineBoundingBox.addChild(l);\r\n        });\r\n        this._rootMesh.addChild(this._lineBoundingBox);\r\n\r\n        this.setColor(color);\r\n\r\n        // Create rotation spheres\r\n        this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._rotateSpheresParent.rotationQuaternion = new Quaternion();\r\n        for (let i = 0; i < 12; i++) {\r\n            const sphere = CreateSphere(\"\", { diameter: 1 }, gizmoLayer.utilityLayerScene);\r\n            sphere.rotationQuaternion = new Quaternion();\r\n            sphere.material = this._coloredMaterial;\r\n            sphere.isNearGrabbable = true;\r\n\r\n            // Drag behavior\r\n            const _dragBehavior = new PointerDragBehavior({});\r\n            _dragBehavior.moveAttached = false;\r\n            _dragBehavior.updateDragPlane = false;\r\n            sphere.addBehavior(_dragBehavior);\r\n            const startingTurnDirection = new Vector3(1, 0, 0);\r\n            let totalTurnAmountOfDrag = 0;\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                startingTurnDirection.copyFrom(sphere.forward);\r\n                totalTurnAmountOfDrag = 0;\r\n            });\r\n            _dragBehavior.onDragObservable.add((event) => {\r\n                this.onRotationSphereDragObservable.notifyObservers({});\r\n                if (this.attachedMesh) {\r\n                    const originalParent = this.attachedMesh.parent;\r\n                    if (originalParent && (originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001)) {\r\n                        Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                        return;\r\n                    }\r\n                    PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n                    const worldDragDirection = startingTurnDirection;\r\n\r\n                    // Project the world right on to the drag plane\r\n                    const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\r\n                    const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();\r\n\r\n                    // project drag delta on to the resulting drag axis and rotate based on that\r\n                    let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());\r\n\r\n                    // Make rotation relative to size of mesh.\r\n                    projectDist = (projectDist / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n\r\n                    // Rotate based on axis\r\n                    if (!this.attachedMesh.rotationQuaternion) {\r\n                        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(\r\n                            this.attachedMesh.rotation.y,\r\n                            this.attachedMesh.rotation.x,\r\n                            this.attachedMesh.rotation.z\r\n                        );\r\n                    }\r\n                    if (!this._anchorMesh.rotationQuaternion) {\r\n                        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(\r\n                            this._anchorMesh.rotation.y,\r\n                            this._anchorMesh.rotation.x,\r\n                            this._anchorMesh.rotation.z\r\n                        );\r\n                    }\r\n\r\n                    // Do not allow the object to turn more than a full circle\r\n                    totalTurnAmountOfDrag += projectDist;\r\n                    if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\r\n                        if (i >= 8) {\r\n                            Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);\r\n                        } else if (i >= 4) {\r\n                            Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);\r\n                        } else {\r\n                            Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);\r\n                        }\r\n\r\n                        // Rotate around center of bounding box\r\n                        this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                        if (this._anchorMesh.getScene().useRightHandedSystem) {\r\n                            this._tmpQuaternion.conjugateInPlace();\r\n                        }\r\n                        this._anchorMesh.rotationQuaternion!.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion!);\r\n                        this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                        this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\r\n                    }\r\n                    this.updateBoundingBox();\r\n\r\n                    PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                }\r\n                this._updateDummy();\r\n            });\r\n\r\n            // Selection/deselection\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n                this._selectNode(sphere);\r\n            });\r\n            _dragBehavior.onDragEndObservable.add((event) => {\r\n                this.onRotationSphereDragEndObservable.notifyObservers({});\r\n                this._selectNode(null);\r\n                this._updateDummy();\r\n                this._unhoverMeshOnTouchUp(event.pointerInfo, sphere);\r\n            });\r\n\r\n            this._rotateSpheresParent.addChild(sphere);\r\n        }\r\n        this._rootMesh.addChild(this._rotateSpheresParent);\r\n\r\n        // Create scale cubes\r\n        this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._scaleBoxesParent.rotationQuaternion = new Quaternion();\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    // create box for relevant axis\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n\r\n                    const box = CreateBox(\"\", { size: 1 }, gizmoLayer.utilityLayerScene);\r\n                    box.material = this._coloredMaterial;\r\n                    box._internalMetadata = zeroAxisCount === 2; // None homogenous scale handle\r\n                    box.isNearGrabbable = true;\r\n\r\n                    // Dragging logic\r\n                    const dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\r\n                    const _dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });\r\n                    _dragBehavior.updateDragPlane = false;\r\n                    _dragBehavior.moveAttached = false;\r\n                    box.addBehavior(_dragBehavior);\r\n                    _dragBehavior.onDragObservable.add((event) => {\r\n                        this.onScaleBoxDragObservable.notifyObservers({});\r\n                        if (this.attachedMesh) {\r\n                            const originalParent = this.attachedMesh.parent;\r\n                            if (originalParent && (originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001)) {\r\n                                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                                return;\r\n                            }\r\n                            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n                            const relativeDragDistance = (event.dragDistance / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n                            const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\r\n                            if (zeroAxisCount === 2) {\r\n                                // scale on 1 axis when using the anchor box in the face middle\r\n                                deltaScale.x *= Math.abs(dragAxis.x);\r\n                                deltaScale.y *= Math.abs(dragAxis.y);\r\n                                deltaScale.z *= Math.abs(dragAxis.z);\r\n                            }\r\n                            deltaScale.scaleInPlace(this._scaleDragSpeed);\r\n                            deltaScale.multiplyInPlace(this._axisFactor);\r\n                            this.updateBoundingBox();\r\n                            if (this.scalePivot) {\r\n                                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);\r\n                                // Move anchor to desired pivot point (Bottom left corner + dimension/2)\r\n                                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.addInPlace(this._tmpVector);\r\n                            } else {\r\n                                // Scale from the position of the opposite corner\r\n                                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                            }\r\n\r\n                            this._anchorMesh.addChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                            this._anchorMesh.scaling.addInPlace(deltaScale);\r\n                            if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {\r\n                                this._anchorMesh.scaling.subtractInPlace(deltaScale);\r\n                            }\r\n                            this._anchorMesh.removeChild(this.attachedMesh, Gizmo.PreserveScaling);\r\n                            this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\r\n                            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                        }\r\n                        this._updateDummy();\r\n                    });\r\n\r\n                    // Selection/deselection\r\n                    _dragBehavior.onDragStartObservable.add(() => {\r\n                        this.onDragStartObservable.notifyObservers({});\r\n                        this._selectNode(box);\r\n                    });\r\n                    _dragBehavior.onDragEndObservable.add((event) => {\r\n                        this.onScaleBoxDragEndObservable.notifyObservers({});\r\n                        this._selectNode(null);\r\n                        this._updateDummy();\r\n                        this._unhoverMeshOnTouchUp(event.pointerInfo, box);\r\n                    });\r\n\r\n                    this._scaleBoxesParent.addChild(box);\r\n                }\r\n            }\r\n        }\r\n        this._rootMesh.addChild(this._scaleBoxesParent);\r\n\r\n        // Hover color change\r\n        const pointerIds = new Array<AbstractMesh>();\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!pointerIds[(<IPointerEvent>pointerInfo.event).pointerId]) {\r\n                this._rotateSpheresParent\r\n                    .getChildMeshes()\r\n                    .concat(this._scaleBoxesParent.getChildMeshes())\r\n                    .forEach((mesh) => {\r\n                        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\r\n                            pointerIds[(<IPointerEvent>pointerInfo.event).pointerId] = mesh;\r\n                            mesh.material = this._hoverColoredMaterial;\r\n                        }\r\n                    });\r\n            } else {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[(<IPointerEvent>pointerInfo.event).pointerId]) {\r\n                    pointerIds[(<IPointerEvent>pointerInfo.event).pointerId].material = this._coloredMaterial;\r\n                    delete pointerIds[(<IPointerEvent>pointerInfo.event).pointerId];\r\n                }\r\n            }\r\n        });\r\n\r\n        // Update bounding box positions\r\n        this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\r\n            // Only update the bounding box if scaling has changed\r\n            if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {\r\n                this.updateBoundingBox();\r\n            } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {\r\n                this._updateRotationSpheres();\r\n                this._updateScaleBoxes();\r\n            }\r\n\r\n            // If drag mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\r\n            if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {\r\n                this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion!, this._tmpVector);\r\n                this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));\r\n            }\r\n        });\r\n        this.updateBoundingBox();\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<AbstractMesh>) {\r\n        if (value) {\r\n            // Reset anchor mesh to match attached mesh's scale\r\n            // This is needed to avoid invalid box/sphere position on first drag\r\n            this._anchorMesh.scaling.setAll(1);\r\n            PivotTools._RemoveAndStorePivotPoint(value);\r\n            const originalParent = value.parent;\r\n            this._anchorMesh.addChild(value, Gizmo.PreserveScaling);\r\n            this._anchorMesh.removeChild(value, Gizmo.PreserveScaling);\r\n            value.setParent(originalParent, Gizmo.PreserveScaling);\r\n            PivotTools._RestorePivotPoint(value);\r\n            this.updateBoundingBox();\r\n            value.getChildMeshes(false).forEach((m) => {\r\n                m.markAsDirty(\"scaling\");\r\n            });\r\n\r\n            this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {\r\n                this._updateDummy();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _selectNode(selectedMesh: Nullable<Mesh>) {\r\n        this._rotateSpheresParent\r\n            .getChildMeshes()\r\n            .concat(this._scaleBoxesParent.getChildMeshes())\r\n            .forEach((m) => {\r\n                m.isVisible = !selectedMesh || m == selectedMesh;\r\n            });\r\n    }\r\n\r\n    protected _unhoverMeshOnTouchUp(pointerInfo: Nullable<PointerInfo>, selectedMesh: AbstractMesh) {\r\n        // force unhover mesh if not a mouse event\r\n        if (pointerInfo?.event instanceof PointerEvent && pointerInfo?.event.pointerType === \"touch\") {\r\n            selectedMesh.material = this._coloredMaterial;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns an array containing all boxes used for scaling (in increasing x, y and z orders)\r\n     */\r\n    public getScaleBoxes() {\r\n        return this._scaleBoxesParent.getChildMeshes();\r\n    }\r\n\r\n    /**\r\n     * Updates the bounding box information for the Gizmo\r\n     */\r\n    public updateBoundingBox() {\r\n        if (this.attachedMesh) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n            // Store original parent\r\n            const originalParent = this.attachedMesh.parent;\r\n            this.attachedMesh.setParent(null, Gizmo.PreserveScaling);\r\n\r\n            this._update();\r\n\r\n            // Rotate based on axis\r\n            if (!this.attachedMesh.rotationQuaternion) {\r\n                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\r\n            }\r\n            if (!this._anchorMesh.rotationQuaternion) {\r\n                this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\r\n            }\r\n            this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n\r\n            // Store original position and reset mesh to origin before computing the bounding box\r\n            this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n            this._tmpVector.copyFrom(this.attachedMesh.position);\r\n            this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\r\n            this.attachedMesh.position.set(0, 0, 0);\r\n\r\n            // Update bounding dimensions/positions\r\n            const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\r\n            boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\r\n\r\n            // Update gizmo to match bounding box scaling and rotation\r\n            // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\r\n            // The position of the gizmo is then set to the attachedMesh in gizmo._update\r\n            this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\r\n            this._lineBoundingBox.position.set(\r\n                (boundingMinMax.max.x + boundingMinMax.min.x) / 2,\r\n                (boundingMinMax.max.y + boundingMinMax.min.y) / 2,\r\n                (boundingMinMax.max.z + boundingMinMax.min.z) / 2\r\n            );\r\n            this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._lineBoundingBox.computeWorldMatrix();\r\n            this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);\r\n\r\n            // Restore position/rotation values\r\n            this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\r\n            this.attachedMesh.position.copyFrom(this._tmpVector);\r\n\r\n            // Restore original parent\r\n            this.attachedMesh.setParent(originalParent, Gizmo.PreserveScaling);\r\n        }\r\n\r\n        this._updateRotationSpheres();\r\n        this._updateScaleBoxes();\r\n\r\n        if (this.attachedMesh) {\r\n            this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\r\n            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n        }\r\n    }\r\n\r\n    protected _updateRotationSpheres() {\r\n        const rotateSpheres = this._rotateSpheresParent.getChildMeshes();\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                for (let k = 0; k < 2; k++) {\r\n                    const index = i * 4 + j * 2 + k;\r\n                    if (i == 0) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (i == 1) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (i == 2) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(\r\n                            Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position)\r\n                        );\r\n                    }\r\n                    if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                        rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                        const distanceFromCamera = (this.rotationSphereSize * this._tmpVector.length()) / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                        rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                    } else if (this.fixedDragMeshBoundsSize) {\r\n                        rotateSpheres[index].scaling.set(\r\n                            this.rotationSphereSize * this._boundingDimensions.x,\r\n                            this.rotationSphereSize * this._boundingDimensions.y,\r\n                            this.rotationSphereSize * this._boundingDimensions.z\r\n                        );\r\n                    } else {\r\n                        rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _updateScaleBoxes() {\r\n        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\r\n        let index = 0;\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                for (let k = 0; k < 3; k++) {\r\n                    const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n                    if (scaleBoxes[index]) {\r\n                        scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\r\n                        scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                            scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                            const distanceFromCamera = (this.scaleBoxSize * this._tmpVector.length()) / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                            scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                        } else if (this.fixedDragMeshBoundsSize) {\r\n                            scaleBoxes[index].scaling.set(\r\n                                this.scaleBoxSize * this._boundingDimensions.x,\r\n                                this.scaleBoxSize * this._boundingDimensions.y,\r\n                                this.scaleBoxSize * this._boundingDimensions.z\r\n                            );\r\n                        } else {\r\n                            scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\r\n                        }\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables rotation on the specified axis and disables rotation on the others\r\n     * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n     */\r\n    public setEnabledRotationAxis(axis: string) {\r\n        this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {\r\n            if (i < 4) {\r\n                m.setEnabled(axis.indexOf(\"x\") != -1);\r\n            } else if (i < 8) {\r\n                m.setEnabled(axis.indexOf(\"y\") != -1);\r\n            } else {\r\n                m.setEnabled(axis.indexOf(\"z\") != -1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enables/disables scaling\r\n     * @param enable if scaling should be enabled\r\n     * @param homogeneousScaling defines if scaling should only be homogeneous\r\n     */\r\n    public setEnabledScaling(enable: boolean, homogeneousScaling = false) {\r\n        this._scaleBoxesParent.getChildMeshes().forEach((m) => {\r\n            let enableMesh = enable;\r\n            // Disable heterogeneous scale handles if requested.\r\n            if (homogeneousScaling && m._internalMetadata === true) {\r\n                enableMesh = false;\r\n            }\r\n            m.setEnabled(enableMesh);\r\n        });\r\n    }\r\n\r\n    protected _updateDummy() {\r\n        if (this._dragMesh) {\r\n            this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\r\n            this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\r\n            this._dragMesh.rotationQuaternion!.copyFrom(this._rootMesh.rotationQuaternion!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables a pointer drag behavior on the bounding box of the gizmo\r\n     */\r\n    public enableDragBehavior() {\r\n        this._dragMesh = CreateBox(\"dummy\", { size: 1 }, this.gizmoLayer.utilityLayerScene);\r\n        this._dragMesh.visibility = 0;\r\n        this._dragMesh.rotationQuaternion = new Quaternion();\r\n        this._pointerDragBehavior.useObjectOrientationForDragging = false;\r\n        this._dragMesh.addBehavior(this._pointerDragBehavior);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\r\n        this._lineBoundingBox.dispose();\r\n        this._rotateSpheresParent.dispose();\r\n        this._scaleBoxesParent.dispose();\r\n        if (this._dragMesh) {\r\n            this._dragMesh.dispose();\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\r\n     * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\r\n     * @returns the bounding box mesh with the passed in mesh as a child\r\n     */\r\n    public static MakeNotPickableAndWrapInBoundingBox(mesh: Mesh): Mesh {\r\n        const makeNotPickable = (root: AbstractMesh) => {\r\n            root.isPickable = false;\r\n            root.getChildMeshes().forEach((c) => {\r\n                makeNotPickable(c);\r\n            });\r\n        };\r\n        makeNotPickable(mesh);\r\n\r\n        // Reset position to get bounding box from origin with no rotation\r\n        if (!mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\r\n        }\r\n        const oldPos = mesh.position.clone();\r\n        const oldRot = mesh.rotationQuaternion.clone();\r\n        mesh.rotationQuaternion.set(0, 0, 0, 1);\r\n        mesh.position.set(0, 0, 0);\r\n\r\n        // Update bounding dimensions/positions\r\n        const box = CreateBox(\"box\", { size: 1 }, mesh.getScene());\r\n        const boundingMinMax = mesh.getHierarchyBoundingVectors();\r\n        boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);\r\n\r\n        // Adjust scale to avoid undefined behavior when adding child\r\n        if (box.scaling.y === 0) {\r\n            box.scaling.y = Epsilon;\r\n        }\r\n        if (box.scaling.x === 0) {\r\n            box.scaling.x = Epsilon;\r\n        }\r\n        if (box.scaling.z === 0) {\r\n            box.scaling.z = Epsilon;\r\n        }\r\n\r\n        box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\r\n\r\n        // Restore original positions\r\n        mesh.addChild(box);\r\n        mesh.rotationQuaternion.copyFrom(oldRot);\r\n        mesh.position.copyFrom(oldPos);\r\n\r\n        // Reverse parenting\r\n        mesh.removeChild(box);\r\n\r\n        box.addChild(mesh);\r\n        box.visibility = 0;\r\n        return box;\r\n    }\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     */\r\n    public setCustomMesh() {\r\n        Logger.Error(\"Custom meshes are not supported on this gizmo\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}