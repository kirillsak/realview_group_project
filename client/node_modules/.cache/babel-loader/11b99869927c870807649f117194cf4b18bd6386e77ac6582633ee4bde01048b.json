{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nThinEngine.prototype.updateRawTexture = function (texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n  if (!texture) {\n    return;\n  }\n  // Babylon's internalSizedFomat but gl's texImage2D internalFormat\n  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\n  // Babylon's internalFormat but gl's texImage2D format\n  const internalFormat = this._getInternalFormat(format);\n  const textureType = this._getWebGLTextureType(type);\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n    texture.format = format;\n    texture.type = type;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n  if (texture.width % 4 !== 0) {\n    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n  }\n  if (compression && data) {\n    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);\n  } else {\n    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\n  }\n  if (texture.generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n  //  this.resetTextureCache();\n  texture.isReady = true;\n};\nThinEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ncreationFlags = 0, useSRGBBuffer = false) {\n  const texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n  texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n  // Filters\n  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\n  if (generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nThinEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {\n  const gl = this._gl;\n  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n  texture.isCube = true;\n  texture.format = format;\n  texture.type = type;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n  const textureType = this._getWebGLTextureType(type);\n  let internalFormat = this._getInternalFormat(format);\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n  }\n  // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\n  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n  const width = size;\n  const height = width;\n  texture.width = width;\n  texture.height = height;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  // Double check on POT to generate Mips.\n  const isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n  if (!isPot) {\n    generateMipMaps = false;\n  }\n  // Upload data if needed. The texture won't be ready until then.\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  } else {\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n    const level = 0;\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      if (compression) {\n        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, undefined);\n      } else {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\n      }\n    }\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\n  // Filters\n  if (data && generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.isReady = true;\n  return texture;\n};\nThinEngine.prototype.updateRawCubeTexture = function (texture, data, format, type, invertY, compression = null, level = 0) {\n  texture._bufferViewArray = data;\n  texture.format = format;\n  texture.type = type;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  const gl = this._gl;\n  const textureType = this._getWebGLTextureType(type);\n  let internalFormat = this._getInternalFormat(format);\n  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n  let needConversion = false;\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n    needConversion = true;\n  }\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n  if (texture.width % 4 !== 0) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n  }\n  // Data are known to be in +X +Y +Z -X -Y -Z\n  for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n    let faceData = data[faceIndex];\n    if (compression) {\n      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);\n    } else {\n      if (needConversion) {\n        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\n      }\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\n    }\n  }\n  const isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n  if (isPot && texture.generateMipMaps && level === 0) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n  // this.resetTextureCache();\n  texture.isReady = true;\n};\nThinEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {\n  const gl = this._gl;\n  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene === null || scene === void 0 ? void 0 : scene.addPendingData(texture);\n  texture.url = url;\n  this._internalTexturesCache.push(texture);\n  const onerror = (request, exception) => {\n    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n  const internalCallback = data => {\n    const width = texture.width;\n    const faceDataArrays = callback(data);\n    if (!faceDataArrays) {\n      return;\n    }\n    if (mipmapGenerator) {\n      const textureType = this._getWebGLTextureType(type);\n      let internalFormat = this._getInternalFormat(format);\n      const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n      let needConversion = false;\n      if (internalFormat === gl.RGB) {\n        internalFormat = gl.RGBA;\n        needConversion = true;\n      }\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n      this._unpackFlipY(false);\n      const mipData = mipmapGenerator(faceDataArrays);\n      for (let level = 0; level < mipData.length; level++) {\n        const mipSize = width >> level;\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n          let mipFaceData = mipData[level][faceIndex];\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\n        }\n      }\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\n    }\n    texture.isReady = true;\n    // this.resetTextureCache();\n    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad();\n    }\n  };\n  this._loadFile(url, data => {\n    internalCallback(data);\n  }, undefined, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);\n  return texture;\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  let rgbaData;\n  let val1 = 1;\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else if (textureType === 2) {\n    rgbaData = new Uint16Array(width * height * 4);\n    val1 = 15360; // 15360 is the encoding of 1 in half float\n  } else if (textureType === 7) {\n    rgbaData = new Uint32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint8Array(width * height * 4);\n  }\n  // Convert each pixel.\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const index = (y * width + x) * 3;\n      const newIndex = (y * width + x) * 4;\n      // Map Old Value to new value.\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2];\n      // Add fully opaque alpha channel.\n      rgbaData[newIndex + 3] = val1;\n    }\n  }\n  return rgbaData;\n}\n/**\n * Create a function for createRawTexture3D/createRawTexture2DArray\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _makeCreateRawTextureFunction(is3D) {\n  return function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {\n    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n    const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\n    const texture = new InternalTexture(this, source);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    if (is3D) {\n      texture.is3D = true;\n    } else {\n      texture.is2DArray = true;\n    }\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n    if (is3D) {\n      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n    } else {\n      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n    }\n    this._bindTextureDirectly(target, texture, true);\n    // Filters\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\n    if (generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n    this._bindTextureDirectly(target, null);\n    this._internalTexturesCache.push(texture);\n    return texture;\n  };\n}\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\n/**\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _makeUpdateRawTextureFunction(is3D) {\n  return function (texture, data, format, invertY, compression = null, textureType = 0) {\n    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n    const internalType = this._getWebGLTextureType(textureType);\n    const internalFormat = this._getInternalFormat(format);\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\n    this._bindTextureDirectly(target, texture, true);\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n    }\n    if (texture.width % 4 !== 0) {\n      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n    }\n    if (compression && data) {\n      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);\n    } else {\n      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\n    }\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n    this._bindTextureDirectly(target, null);\n    // this.resetTextureCache();\n    texture.isReady = true;\n  };\n}\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","Logger","Tools","ThinEngine","prototype","updateRawTexture","texture","data","format","invertY","compression","type","internalSizedFomat","_getRGBABufferInternalSizedFormat","useSRGBBuffer","internalFormat","_getInternalFormat","textureType","_getWebGLTextureType","_bindTextureDirectly","_gl","TEXTURE_2D","_unpackFlipY","undefined","_doNotHandleContextLost","_bufferView","_compression","width","pixelStorei","UNPACK_ALIGNMENT","compressedTexImage2D","getCaps","s3tc","height","texImage2D","generateMipMaps","generateMipmap","isReady","createRawTexture","samplingMode","creationFlags","Raw","baseWidth","baseHeight","_useSRGBBuffer","_getUseSRGBBuffer","filters","_getSamplingParameters","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","min","_internalTexturesCache","push","createRawCubeTexture","size","gl","CubeRaw","isCube","_bufferViewArray","RGB","RGBA","FLOAT","_caps","textureFloatLinearFiltering","Warn","HALF_FLOAT_OES","textureHalfFloatLinearFiltering","textureFloatRender","HALF_FLOAT","colorBufferFloat","isPot","needPOTTextures","IsExponentOfTwo","updateRawCubeTexture","level","TEXTURE_CUBE_MAP","faceIndex","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","needConversion","faceData","_convertRGBtoRGBATextureData","createRawCubeTextureFromUrl","url","scene","noMipmap","callback","mipmapGenerator","onLoad","onError","addPendingData","onerror","request","exception","removePendingData","status","statusText","internalCallback","faceDataArrays","mipData","length","mipSize","mipFaceData","onLoadedObservable","notifyObservers","clear","_loadFile","offlineProvider","rgbData","rgbaData","val1","Float32Array","Uint16Array","Uint32Array","Uint8Array","x","y","index","newIndex","_makeCreateRawTextureFunction","is3D","depth","target","TEXTURE_3D","TEXTURE_2D_ARRAY","source","Raw3D","Raw2DArray","baseDepth","is2DArray","updateRawTexture3D","updateRawTexture2DArray","createRawTexture2DArray","createRawTexture3D","_makeUpdateRawTextureFunction","internalType","compressedTexImage3D","texImage3D"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Extensions/engine.rawTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            creationFlags?: number,\r\n            useSRGBBuffer?: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    data: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    const internalFormat = this._getInternalFormat(format);\r\n    const textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    creationFlags = 0,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    const width = size;\r\n    const height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    // Double check on POT to generate Mips.\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    } else {\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n        const level = 0;\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            if (compression) {\r\n                gl.compressedTexImage2D(\r\n                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                    level,\r\n                    (<any>this.getCaps().s3tc)[compression],\r\n                    texture.width,\r\n                    texture.height,\r\n                    0,\r\n                    undefined as any\r\n                );\r\n            } else {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    data: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    level: number = 0\r\n): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gl = this._gl;\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    let needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                level,\r\n                (<any>this.getCaps().s3tc)[compression],\r\n                texture.width,\r\n                texture.height,\r\n                0,\r\n                <DataView>faceData\r\n            );\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const textureType = this._getWebGLTextureType(type);\r\n            let internalFormat = this._getInternalFormat(format);\r\n            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            let needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        const texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): void {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const internalType = this._getWebGLTextureType(textureType);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}