{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport \"../Shaders/imageProcessing.fragment.js\";\nimport \"../Shaders/subSurfaceScattering.fragment.js\";\nimport \"../Shaders/postprocess.vertex.js\";\n/**\n * Sub surface scattering post process\n */\nexport class SubSurfaceScatteringPostProcess extends PostProcess {\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"SubSurfaceScatteringPostProcess\" string\n   */\n  getClassName() {\n    return \"SubSurfaceScatteringPostProcess\";\n  }\n  constructor(name, scene, options, camera = null, samplingMode, engine, reusable, textureType = 0) {\n    super(name, \"subSurfaceScattering\", [\"texelSize\", \"viewportSize\", \"metersPerUnit\"], [\"diffusionS\", \"diffusionD\", \"filterRadii\", \"irradianceSampler\", \"depthSampler\", \"albedoSampler\"], options, camera, samplingMode || Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, \"postprocess\", undefined, true);\n    this._scene = scene;\n    this.updateEffect();\n    this.onApplyObservable.add(effect => {\n      if (!scene.prePassRenderer || !scene.subSurfaceConfiguration) {\n        Logger.Error(\"PrePass and subsurface configuration needs to be enabled for subsurface scattering.\");\n        return;\n      }\n      const texelSize = this.texelSize;\n      effect.setFloat(\"metersPerUnit\", scene.subSurfaceConfiguration.metersPerUnit);\n      effect.setFloat2(\"texelSize\", texelSize.x, texelSize.y);\n      effect.setTexture(\"irradianceSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(0)]);\n      effect.setTexture(\"depthSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(5)]);\n      effect.setTexture(\"albedoSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(7)]);\n      effect.setFloat2(\"viewportSize\", Math.tan(scene.activeCamera.fov / 2) * scene.getEngine().getAspectRatio(scene.activeCamera, true), Math.tan(scene.activeCamera.fov / 2));\n      effect.setArray3(\"diffusionS\", scene.subSurfaceConfiguration.ssDiffusionS);\n      effect.setArray(\"diffusionD\", scene.subSurfaceConfiguration.ssDiffusionD);\n      effect.setArray(\"filterRadii\", scene.subSurfaceConfiguration.ssFilterRadii);\n    });\n  }\n}","map":{"version":3,"mappings":"AAGA,SAASA,OAAO,QAAQ,kCAAgC;AAExD,SAASC,WAAW,QAAQ,kBAAgB;AAI5C,SAASC,MAAM,QAAQ,mBAAiB;AAExC,OAAO,wCAAsC;AAC7C,OAAO,6CAA2C;AAClD,OAAO,kCAAgC;AAEvC;;;AAGA,OAAM,MAAOC,+BAAgC,SAAQF,WAAW;EAC5D;;;;EAIOG,YAAY;IACf,OAAO,iCAAiC;EAC5C;EAEAC,YACIC,IAAY,EACZC,KAAY,EACZC,OAAoC,EACpCC,SAA2B,IAAI,EAC/BC,YAAqB,EACrBC,MAAe,EACfC,QAAkB,EAClBC,cAAsB;IAEtB,KAAK,CACDP,IAAI,EACJ,sBAAsB,EACtB,CAAC,WAAW,EAAE,cAAc,EAAE,eAAe,CAAC,EAC9C,CAAC,YAAY,EAAE,YAAY,EAAE,aAAa,EAAE,mBAAmB,EAAE,cAAc,EAAE,eAAe,CAAC,EACjGE,OAAO,EACPC,MAAM,EACNC,YAAY,IAAIV,OAAO,CAACc,qBAAqB,EAC7CH,MAAM,EACNC,QAAQ,EACR,IAAI,EACJC,WAAW,EACX,aAAa,EACbE,SAAS,EACT,IAAI,CACP;IACD,IAAI,CAACC,MAAM,GAAGT,KAAK;IAEnB,IAAI,CAACU,YAAY,EAAE;IAEnB,IAAI,CAACC,iBAAiB,CAACC,GAAG,CAAEC,MAAc,IAAI;MAC1C,IAAI,CAACb,KAAK,CAACc,eAAe,IAAI,CAACd,KAAK,CAACe,uBAAuB,EAAE;QAC1DpB,MAAM,CAACqB,KAAK,CAAC,qFAAqF,CAAC;QACnG;;MAEJ,MAAMC,SAAS,GAAG,IAAI,CAACA,SAAS;MAChCJ,MAAM,CAACK,QAAQ,CAAC,eAAe,EAAElB,KAAK,CAACe,uBAAuB,CAACI,aAAa,CAAC;MAC7EN,MAAM,CAACO,SAAS,CAAC,WAAW,EAAEH,SAAS,CAACI,CAAC,EAAEJ,SAAS,CAACK,CAAC,CAAC;MACvDT,MAAM,CAACU,UAAU,CAAC,mBAAmB,EAAEvB,KAAK,CAACc,eAAe,CAACU,eAAe,EAAE,CAACC,QAAQ,CAACzB,KAAK,CAACc,eAAe,CAACY,QAAQ,CAAC;MACvHb,MAAM,CAACU,UAAU,CAAC,cAAc,EAAEvB,KAAK,CAACc,eAAe,CAACU,eAAe,EAAE,CAACC,QAAQ,CAACzB,KAAK,CAACc,eAAe,CAACY,QAAQ,CAAC;MAClHb,MAAM,CAACU,UAAU,CAAC,eAAe,EAAEvB,KAAK,CAACc,eAAe,CAACU,eAAe,EAAE,CAACC,QAAQ,CAACzB,KAAK,CAACc,eAAe,CAACY,QAAQ,CAAC;MACnHb,MAAM,CAACO,SAAS,CACZ,cAAc,EACdO,IAAI,CAACC,GAAG,CAAC5B,KAAK,CAAC6B,YAAa,CAACC,GAAG,GAAG,CAAC,CAAC,GAAG9B,KAAK,CAAC+B,SAAS,EAAE,CAACC,cAAc,CAAChC,KAAK,CAAC6B,YAAa,EAAE,IAAI,CAAC,EACnGF,IAAI,CAACC,GAAG,CAAC5B,KAAK,CAAC6B,YAAa,CAACC,GAAG,GAAG,CAAC,CAAC,CACxC;MACDjB,MAAM,CAACoB,SAAS,CAAC,YAAY,EAAEjC,KAAK,CAACe,uBAAuB,CAACmB,YAAY,CAAC;MAC1ErB,MAAM,CAACsB,QAAQ,CAAC,YAAY,EAAEnC,KAAK,CAACe,uBAAuB,CAACqB,YAAY,CAAC;MACzEvB,MAAM,CAACsB,QAAQ,CAAC,aAAa,EAAEnC,KAAK,CAACe,uBAAuB,CAACsB,aAAa,CAAC;IAC/E,CAAC,CAAC;EACN","names":["Texture","PostProcess","Logger","SubSurfaceScatteringPostProcess","getClassName","constructor","name","scene","options","camera","samplingMode","engine","reusable","textureType","BILINEAR_SAMPLINGMODE","undefined","_scene","updateEffect","onApplyObservable","add","effect","prePassRenderer","subSurfaceConfiguration","Error","texelSize","setFloat","metersPerUnit","setFloat2","x","y","setTexture","getRenderTarget","textures","getIndex","Math","tan","activeCamera","fov","getEngine","getAspectRatio","setArray3","ssDiffusionS","setArray","ssDiffusionD","ssFilterRadii"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/subSurfaceScatteringPostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\nimport \"../Shaders/imageProcessing.fragment\";\r\nimport \"../Shaders/subSurfaceScattering.fragment\";\r\nimport \"../Shaders/postprocess.vertex\";\r\n\r\n/**\r\n * Sub surface scattering post process\r\n */\r\nexport class SubSurfaceScatteringPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"SubSurfaceScatteringPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubSurfaceScatteringPostProcess\";\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(\r\n            name,\r\n            \"subSurfaceScattering\",\r\n            [\"texelSize\", \"viewportSize\", \"metersPerUnit\"],\r\n            [\"diffusionS\", \"diffusionD\", \"filterRadii\", \"irradianceSampler\", \"depthSampler\", \"albedoSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode || Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            \"postprocess\",\r\n            undefined,\r\n            true\r\n        );\r\n        this._scene = scene;\r\n\r\n        this.updateEffect();\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (!scene.prePassRenderer || !scene.subSurfaceConfiguration) {\r\n                Logger.Error(\"PrePass and subsurface configuration needs to be enabled for subsurface scattering.\");\r\n                return;\r\n            }\r\n            const texelSize = this.texelSize;\r\n            effect.setFloat(\"metersPerUnit\", scene.subSurfaceConfiguration.metersPerUnit);\r\n            effect.setFloat2(\"texelSize\", texelSize.x, texelSize.y);\r\n            effect.setTexture(\"irradianceSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE)]);\r\n            effect.setTexture(\"depthSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE)]);\r\n            effect.setTexture(\"albedoSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE)]);\r\n            effect.setFloat2(\r\n                \"viewportSize\",\r\n                Math.tan(scene.activeCamera!.fov / 2) * scene.getEngine().getAspectRatio(scene.activeCamera!, true),\r\n                Math.tan(scene.activeCamera!.fov / 2)\r\n            );\r\n            effect.setArray3(\"diffusionS\", scene.subSurfaceConfiguration.ssDiffusionS);\r\n            effect.setArray(\"diffusionD\", scene.subSurfaceConfiguration.ssDiffusionD);\r\n            effect.setArray(\"filterRadii\", scene.subSurfaceConfiguration.ssFilterRadii);\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}