{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nconst intersectBoxAASphere = (boxMin, boxMax, sphereCenter, sphereRadius) => {\n  if (boxMin.x > sphereCenter.x + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.x - sphereRadius > boxMax.x) {\n    return false;\n  }\n  if (boxMin.y > sphereCenter.y + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.y - sphereRadius > boxMax.y) {\n    return false;\n  }\n  if (boxMin.z > sphereCenter.z + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.z - sphereRadius > boxMax.z) {\n    return false;\n  }\n  return true;\n};\nconst getLowestRoot = function () {\n  const result = {\n    root: 0,\n    found: false\n  };\n  return function (a, b, c, maxR) {\n    result.root = 0;\n    result.found = false;\n    const determinant = b * b - 4.0 * a * c;\n    if (determinant < 0) {\n      return result;\n    }\n    const sqrtD = Math.sqrt(determinant);\n    let r1 = (-b - sqrtD) / (2.0 * a);\n    let r2 = (-b + sqrtD) / (2.0 * a);\n    if (r1 > r2) {\n      const temp = r2;\n      r2 = r1;\n      r1 = temp;\n    }\n    if (r1 > 0 && r1 < maxR) {\n      result.root = r1;\n      result.found = true;\n      return result;\n    }\n    if (r2 > 0 && r2 < maxR) {\n      result.root = r2;\n      result.found = true;\n      return result;\n    }\n    return result;\n  };\n}();\n/** @internal */\nexport class Collider {\n  constructor() {\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\n    // https://www.peroxide.dk/papers/collision/collision.pdf\n    this._collisionPoint = Vector3.Zero();\n    this._planeIntersectionPoint = Vector3.Zero();\n    this._tempVector = Vector3.Zero();\n    this._tempVector2 = Vector3.Zero();\n    this._tempVector3 = Vector3.Zero();\n    this._tempVector4 = Vector3.Zero();\n    this._edge = Vector3.Zero();\n    this._baseToVertex = Vector3.Zero();\n    this._destinationPoint = Vector3.Zero();\n    this._slidePlaneNormal = Vector3.Zero();\n    this._displacementVector = Vector3.Zero();\n    /** @internal */\n    this._radius = Vector3.One();\n    /** @internal */\n    this._retry = 0;\n    /** @internal */\n    this._basePointWorld = Vector3.Zero();\n    this._velocityWorld = Vector3.Zero();\n    this._normalizedVelocity = Vector3.Zero();\n    this._collisionMask = -1;\n  }\n  get collisionMask() {\n    return this._collisionMask;\n  }\n  set collisionMask(mask) {\n    this._collisionMask = !isNaN(mask) ? mask : -1;\n  }\n  /**\n   * Gets the plane normal used to compute the sliding response (in local space)\n   */\n  get slidePlaneNormal() {\n    return this._slidePlaneNormal;\n  }\n  // Methods\n  /**\n   * @internal\n   */\n  _initialize(source, dir, e) {\n    this._velocity = dir;\n    this._velocitySquaredLength = this._velocity.lengthSquared();\n    const len = Math.sqrt(this._velocitySquaredLength);\n    if (len === 0 || len === 1.0) {\n      this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\n    } else {\n      dir.scaleToRef(1.0 / len, this._normalizedVelocity);\n    }\n    this._basePoint = source;\n    source.multiplyToRef(this._radius, this._basePointWorld);\n    dir.multiplyToRef(this._radius, this._velocityWorld);\n    this._velocityWorldLength = this._velocityWorld.length();\n    this._epsilon = e;\n    this.collisionFound = false;\n  }\n  /**\n   * @internal\n   */\n  _checkPointInTriangle(point, pa, pb, pc, n) {\n    pa.subtractToRef(point, this._tempVector);\n    pb.subtractToRef(point, this._tempVector2);\n    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n    let d = Vector3.Dot(this._tempVector4, n);\n    if (d < 0) {\n      return false;\n    }\n    pc.subtractToRef(point, this._tempVector3);\n    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    if (d < 0) {\n      return false;\n    }\n    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    return d >= 0;\n  }\n  /**\n   * @internal\n   */\n  _canDoCollision(sphereCenter, sphereRadius, vecMin, vecMax) {\n    const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\n    const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\n    if (distance > this._velocityWorldLength + max + sphereRadius) {\n      return false;\n    }\n    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _testTriangle(faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {\n    let t0;\n    let embeddedInPlane = false;\n    //defensive programming, actually not needed.\n    if (!trianglePlaneArray) {\n      trianglePlaneArray = [];\n    }\n    if (!trianglePlaneArray[faceIndex]) {\n      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\n      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n    }\n    const trianglePlane = trianglePlaneArray[faceIndex];\n    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\n      return;\n    }\n    const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\n    const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\n    // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\n    // if true, it discard the faces having normal not facing velocity\n    if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\n      return;\n    }\n    if (normalDotVelocity == 0) {\n      if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\n        return;\n      }\n      embeddedInPlane = true;\n      t0 = 0;\n    } else {\n      t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      if (t0 > t1) {\n        const temp = t1;\n        t1 = t0;\n        t0 = temp;\n      }\n      if (t0 > 1.0 || t1 < 0.0) {\n        return;\n      }\n      if (t0 < 0) {\n        t0 = 0;\n      }\n      if (t0 > 1.0) {\n        t0 = 1.0;\n      }\n    }\n    this._collisionPoint.copyFromFloats(0, 0, 0);\n    let found = false;\n    let t = 1.0;\n    if (!embeddedInPlane) {\n      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n      this._velocity.scaleToRef(t0, this._tempVector);\n      this._planeIntersectionPoint.addInPlace(this._tempVector);\n      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n        found = true;\n        t = t0;\n        this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n      }\n    }\n    if (!found) {\n      let a = this._velocitySquaredLength;\n      this._basePoint.subtractToRef(p1, this._tempVector);\n      let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      let c = this._tempVector.lengthSquared() - 1.0;\n      let lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p1);\n      }\n      this._basePoint.subtractToRef(p2, this._tempVector);\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p2);\n      }\n      this._basePoint.subtractToRef(p3, this._tempVector);\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p3);\n      }\n      p2.subtractToRef(p1, this._edge);\n      p1.subtractToRef(this._basePoint, this._baseToVertex);\n      let edgeSquaredLength = this._edge.lengthSquared();\n      let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p1.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n      p3.subtractToRef(p2, this._edge);\n      p2.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p2.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n      p1.subtractToRef(p3, this._edge);\n      p3.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p3.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n    }\n    if (found) {\n      const distToCollisionSquared = t * t * this._velocitySquaredLength;\n      if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\n        // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\n        // onCollide observable are triggered if collideMesh is set\n        // this allow trigger volumes to be created.\n        if (hostMesh.collisionResponse) {\n          if (!this.intersectionPoint) {\n            this.intersectionPoint = this._collisionPoint.clone();\n          } else {\n            this.intersectionPoint.copyFrom(this._collisionPoint);\n          }\n          this._nearestDistanceSquared = distToCollisionSquared;\n          this._nearestDistance = Math.sqrt(distToCollisionSquared);\n          this.collisionFound = true;\n        }\n        this.collidedMesh = hostMesh;\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _collide(trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh, invertTriangles, triangleStrip = false) {\n    if (triangleStrip) {\n      if (!indices || indices.length === 0) {\n        for (let i = 0; i < pts.length - 2; i += 1) {\n          const p1 = pts[i];\n          const p2 = pts[i + 1];\n          const p3 = pts[i + 2];\n          // stay defensive and don't check against undefined positions.\n          if (!p1 || !p2 || !p3) {\n            continue;\n          }\n          // Handles strip faces one on two is reversed\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      } else {\n        for (let i = indexStart; i < indexEnd - 2; i += 1) {\n          const indexA = indices[i];\n          const indexB = indices[i + 1];\n          const indexC = indices[i + 2];\n          if (indexC === 0xffffffff) {\n            i += 2;\n            continue;\n          }\n          const p1 = pts[indexA];\n          const p2 = pts[indexB];\n          const p3 = pts[indexC];\n          // stay defensive and don't check against undefined positions.\n          if (!p1 || !p2 || !p3) {\n            continue;\n          }\n          // Handles strip faces one on two is reversed\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      }\n    } else if (!indices || indices.length === 0) {\n      for (let i = 0; i < pts.length; i += 3) {\n        const p1 = pts[i];\n        const p2 = pts[i + 1];\n        const p3 = pts[i + 2];\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    } else {\n      for (let i = indexStart; i < indexEnd; i += 3) {\n        const p1 = pts[indices[i] - decal];\n        const p2 = pts[indices[i + 1] - decal];\n        const p3 = pts[indices[i + 2] - decal];\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _getResponse(pos, vel) {\n    pos.addToRef(vel, this._destinationPoint);\n    vel.scaleInPlace(this._nearestDistance / vel.length());\n    this._basePoint.addToRef(vel, pos);\n    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n    this._slidePlaneNormal.normalize();\n    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\n    pos.addInPlace(this._displacementVector);\n    this.intersectionPoint.addInPlace(this._displacementVector);\n    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n  }\n}\n/**\n * If true, it check for double sided faces and only returns 1 collision instead of 2\n */\nCollider.DoubleSidedCheck = false;","map":{"version":3,"mappings":"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","names":["Vector3","Plane","intersectBoxAASphere","boxMin","boxMax","sphereCenter","sphereRadius","x","y","z","getLowestRoot","result","root","found","a","b","c","maxR","determinant","sqrtD","Math","sqrt","r1","r2","temp","Collider","constructor","Zero","One","collisionMask","_collisionMask","mask","isNaN","slidePlaneNormal","_slidePlaneNormal","_initialize","source","dir","e","_velocity","_velocitySquaredLength","lengthSquared","len","_normalizedVelocity","copyFromFloats","_x","_y","_z","scaleToRef","_basePoint","multiplyToRef","_radius","_basePointWorld","_velocityWorld","_velocityWorldLength","length","_epsilon","collisionFound","_checkPointInTriangle","point","pa","pb","pc","n","subtractToRef","_tempVector","_tempVector2","CrossToRef","_tempVector4","d","Dot","_tempVector3","_canDoCollision","vecMin","vecMax","distance","Distance","max","_testTriangle","faceIndex","trianglePlaneArray","p1","p2","p3","hasMaterial","hostMesh","t0","embeddedInPlane","copyFromPoints","trianglePlane","isFrontFacingTo","signedDistToTrianglePlane","signedDistanceTo","normalDotVelocity","normal","DoubleSidedCheck","abs","t1","_collisionPoint","t","_planeIntersectionPoint","addInPlace","copyFrom","lowestRoot","_edge","_baseToVertex","edgeSquaredLength","edgeDotVelocity","edgeDotBaseToVertex","f","scaleInPlace","addToRef","distToCollisionSquared","_nearestDistanceSquared","collisionResponse","intersectionPoint","clone","_nearestDistance","collidedMesh","_collide","pts","indices","indexStart","indexEnd","decal","invertTriangles","triangleStrip","i","indexA","indexB","indexC","_getResponse","pos","vel","_destinationPoint","normalize","_displacementVector","SignedDistanceToPlaneFromPositionAndNormal","subtractInPlace"],"sourceRoot":"","sources":["../../../../lts/core/generated/Collisions/collider.ts"],"sourcesContent":["import type { Nullable, IndicesArray } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\n\r\nconst intersectBoxAASphere = (boxMin: Vector3, boxMax: Vector3, sphereCenter: Vector3, sphereRadius: number): boolean => {\r\n    if (boxMin.x > sphereCenter.x + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.x - sphereRadius > boxMax.x) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.y > sphereCenter.y + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.y - sphereRadius > boxMax.y) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.z > sphereCenter.z + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.z - sphereRadius > boxMax.z) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst getLowestRoot: (a: number, b: number, c: number, maxR: number) => { root: number; found: boolean } = (function () {\r\n    const result = { root: 0, found: false };\r\n    return function (a: number, b: number, c: number, maxR: number) {\r\n        result.root = 0;\r\n        result.found = false;\r\n        const determinant = b * b - 4.0 * a * c;\r\n        if (determinant < 0) {\r\n            return result;\r\n        }\r\n\r\n        const sqrtD = Math.sqrt(determinant);\r\n        let r1 = (-b - sqrtD) / (2.0 * a);\r\n        let r2 = (-b + sqrtD) / (2.0 * a);\r\n\r\n        if (r1 > r2) {\r\n            const temp = r2;\r\n            r2 = r1;\r\n            r1 = temp;\r\n        }\r\n\r\n        if (r1 > 0 && r1 < maxR) {\r\n            result.root = r1;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        if (r2 > 0 && r2 < maxR) {\r\n            result.root = r2;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        return result;\r\n    };\r\n})();\r\n\r\n/** @internal */\r\nexport class Collider {\r\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\r\n    // https://www.peroxide.dk/papers/collision/collision.pdf\r\n\r\n    /** Define if a collision was found */\r\n    public collisionFound: boolean;\r\n\r\n    /**\r\n     * Define last intersection point in local space\r\n     */\r\n    public intersectionPoint: Vector3;\r\n\r\n    /**\r\n     * Define last collided mesh\r\n     */\r\n    public collidedMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * If true, it check for double sided faces and only returns 1 collision instead of 2\r\n     */\r\n    public static DoubleSidedCheck = false;\r\n\r\n    private _collisionPoint = Vector3.Zero();\r\n    private _planeIntersectionPoint = Vector3.Zero();\r\n    private _tempVector = Vector3.Zero();\r\n    private _tempVector2 = Vector3.Zero();\r\n    private _tempVector3 = Vector3.Zero();\r\n    private _tempVector4 = Vector3.Zero();\r\n    private _edge = Vector3.Zero();\r\n    private _baseToVertex = Vector3.Zero();\r\n    private _destinationPoint = Vector3.Zero();\r\n    private _slidePlaneNormal = Vector3.Zero();\r\n    private _displacementVector = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _radius = Vector3.One();\r\n    /** @internal */\r\n    public _retry = 0;\r\n    private _velocity: Vector3;\r\n    private _basePoint: Vector3;\r\n    private _epsilon: number;\r\n    /** @internal */\r\n    public _velocityWorldLength: number;\r\n    /** @internal */\r\n    public _basePointWorld = Vector3.Zero();\r\n    private _velocityWorld = Vector3.Zero();\r\n    private _normalizedVelocity = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialVelocity: Vector3;\r\n    /** @internal */\r\n    public _initialPosition: Vector3;\r\n    private _nearestDistance: number;\r\n\r\n    private _collisionMask = -1;\r\n    private _velocitySquaredLength: number;\r\n    private _nearestDistanceSquared: number;\r\n\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the plane normal used to compute the sliding response (in local space)\r\n     */\r\n    public get slidePlaneNormal(): Vector3 {\r\n        return this._slidePlaneNormal;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _initialize(source: Vector3, dir: Vector3, e: number): void {\r\n        this._velocity = dir;\r\n        this._velocitySquaredLength = this._velocity.lengthSquared();\r\n        const len = Math.sqrt(this._velocitySquaredLength);\r\n        if (len === 0 || len === 1.0) {\r\n            this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\r\n        } else {\r\n            dir.scaleToRef(1.0 / len, this._normalizedVelocity);\r\n        }\r\n        this._basePoint = source;\r\n\r\n        source.multiplyToRef(this._radius, this._basePointWorld);\r\n        dir.multiplyToRef(this._radius, this._velocityWorld);\r\n\r\n        this._velocityWorldLength = this._velocityWorld.length();\r\n\r\n        this._epsilon = e;\r\n        this.collisionFound = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkPointInTriangle(point: Vector3, pa: Vector3, pb: Vector3, pc: Vector3, n: Vector3): boolean {\r\n        pa.subtractToRef(point, this._tempVector);\r\n        pb.subtractToRef(point, this._tempVector2);\r\n\r\n        Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\r\n        let d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        pc.subtractToRef(point, this._tempVector3);\r\n        Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        return d >= 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _canDoCollision(sphereCenter: Vector3, sphereRadius: number, vecMin: Vector3, vecMax: Vector3): boolean {\r\n        const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\r\n\r\n        const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\r\n\r\n        if (distance > this._velocityWorldLength + max + sphereRadius) {\r\n            return false;\r\n        }\r\n\r\n        if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _testTriangle(faceIndex: number, trianglePlaneArray: Array<Plane>, p1: Vector3, p2: Vector3, p3: Vector3, hasMaterial: boolean, hostMesh: AbstractMesh): void {\r\n        let t0;\r\n        let embeddedInPlane = false;\r\n\r\n        //defensive programming, actually not needed.\r\n        if (!trianglePlaneArray) {\r\n            trianglePlaneArray = [];\r\n        }\r\n\r\n        if (!trianglePlaneArray[faceIndex]) {\r\n            trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\r\n            trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\r\n        }\r\n\r\n        const trianglePlane = trianglePlaneArray[faceIndex];\r\n\r\n        if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\r\n            return;\r\n        }\r\n\r\n        const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\r\n        const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\r\n\r\n        // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\r\n        // if true, it discard the faces having normal not facing velocity\r\n        if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\r\n            return;\r\n        }\r\n\r\n        if (normalDotVelocity == 0) {\r\n            if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\r\n                return;\r\n            }\r\n            embeddedInPlane = true;\r\n            t0 = 0;\r\n        } else {\r\n            t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n            let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n\r\n            if (t0 > t1) {\r\n                const temp = t1;\r\n                t1 = t0;\r\n                t0 = temp;\r\n            }\r\n\r\n            if (t0 > 1.0 || t1 < 0.0) {\r\n                return;\r\n            }\r\n\r\n            if (t0 < 0) {\r\n                t0 = 0;\r\n            }\r\n            if (t0 > 1.0) {\r\n                t0 = 1.0;\r\n            }\r\n        }\r\n\r\n        this._collisionPoint.copyFromFloats(0, 0, 0);\r\n\r\n        let found = false;\r\n        let t = 1.0;\r\n\r\n        if (!embeddedInPlane) {\r\n            this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\r\n            this._velocity.scaleToRef(t0, this._tempVector);\r\n            this._planeIntersectionPoint.addInPlace(this._tempVector);\r\n\r\n            if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\r\n                found = true;\r\n                t = t0;\r\n                this._collisionPoint.copyFrom(this._planeIntersectionPoint);\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            let a = this._velocitySquaredLength;\r\n\r\n            this._basePoint.subtractToRef(p1, this._tempVector);\r\n            let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            let c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            let lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p1);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p2, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p2);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p3, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p3);\r\n            }\r\n\r\n            p2.subtractToRef(p1, this._edge);\r\n            p1.subtractToRef(this._basePoint, this._baseToVertex);\r\n            let edgeSquaredLength = this._edge.lengthSquared();\r\n            let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p1.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p3.subtractToRef(p2, this._edge);\r\n            p2.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p2.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p1.subtractToRef(p3, this._edge);\r\n            p3.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p3.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            const distToCollisionSquared = t * t * this._velocitySquaredLength;\r\n\r\n            if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\r\n                // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\r\n                // onCollide observable are triggered if collideMesh is set\r\n                // this allow trigger volumes to be created.\r\n                if (hostMesh.collisionResponse) {\r\n                    if (!this.intersectionPoint) {\r\n                        this.intersectionPoint = this._collisionPoint.clone();\r\n                    } else {\r\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\r\n                    }\r\n                    this._nearestDistanceSquared = distToCollisionSquared;\r\n                    this._nearestDistance = Math.sqrt(distToCollisionSquared);\r\n                    this.collisionFound = true;\r\n                }\r\n                this.collidedMesh = hostMesh;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collide(\r\n        trianglePlaneArray: Array<Plane>,\r\n        pts: Vector3[],\r\n        indices: IndicesArray,\r\n        indexStart: number,\r\n        indexEnd: number,\r\n        decal: number,\r\n        hasMaterial: boolean,\r\n        hostMesh: AbstractMesh,\r\n        invertTriangles?: boolean,\r\n        triangleStrip: boolean = false\r\n    ): void {\r\n        if (triangleStrip) {\r\n            if (!indices || indices.length === 0) {\r\n                for (let i = 0; i < pts.length - 2; i += 1) {\r\n                    const p1 = pts[i];\r\n                    const p2 = pts[i + 1];\r\n                    const p3 = pts[i + 2];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = indexStart; i < indexEnd - 2; i += 1) {\r\n                    const indexA = indices[i];\r\n                    const indexB = indices[i + 1];\r\n                    const indexC = indices[i + 2];\r\n\r\n                    if (indexC === 0xffffffff) {\r\n                        i += 2;\r\n                        continue;\r\n                    }\r\n\r\n                    const p1 = pts[indexA];\r\n                    const p2 = pts[indexB];\r\n                    const p3 = pts[indexC];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            }\r\n        } else if (!indices || indices.length === 0) {\r\n            for (let i = 0; i < pts.length; i += 3) {\r\n                const p1 = pts[i];\r\n                const p2 = pts[i + 1];\r\n                const p3 = pts[i + 2];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = indexStart; i < indexEnd; i += 3) {\r\n                const p1 = pts[indices[i] - decal];\r\n                const p2 = pts[indices[i + 1] - decal];\r\n                const p3 = pts[indices[i + 2] - decal];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getResponse(pos: Vector3, vel: Vector3): void {\r\n        pos.addToRef(vel, this._destinationPoint);\r\n        vel.scaleInPlace(this._nearestDistance / vel.length());\r\n\r\n        this._basePoint.addToRef(vel, pos);\r\n        pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\r\n        this._slidePlaneNormal.normalize();\r\n        this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\r\n\r\n        pos.addInPlace(this._displacementVector);\r\n        this.intersectionPoint.addInPlace(this._displacementVector);\r\n\r\n        this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\r\n        this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\r\n\r\n        this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}