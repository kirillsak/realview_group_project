{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { WebVRController } from \"./webVRController.js\";\nimport { GenericController } from \"./genericController.js\";\nimport { PoseEnabledController, PoseEnabledControllerType, PoseEnabledControllerHelper } from \"./poseEnabledController.js\";\n/**\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\n */\nclass LoadedMeshInfo {\n  constructor() {\n    /**\n     * Map of the button meshes contained in the controller\n     */\n    this.buttonMeshes = {};\n    /**\n     * Map of the axis meshes contained in the controller\n     */\n    this.axisMeshes = {};\n  }\n}\n/**\n * Defines the WindowsMotionController object that the state of the windows motion controller\n */\nexport class WindowsMotionController extends WebVRController {\n  /**\n   * Creates a new WindowsMotionController from a gamepad\n   * @param vrGamepad the gamepad that the controller should be created from\n   */\n  constructor(vrGamepad) {\n    super(vrGamepad);\n    this._mapping = {\n      // Semantic button names\n      buttons: [\"thumbstick\", \"trigger\", \"grip\", \"menu\", \"trackpad\"],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        trigger: \"SELECT\",\n        menu: \"MENU\",\n        grip: \"GRASP\",\n        thumbstick: \"THUMBSTICK_PRESS\",\n        trackpad: \"TOUCHPAD_PRESS\"\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        trigger: \"onTriggerStateChangedObservable\",\n        menu: \"onSecondaryButtonStateChangedObservable\",\n        grip: \"onMainButtonStateChangedObservable\",\n        thumbstick: \"onPadStateChangedObservable\",\n        trackpad: \"onTrackpadChangedObservable\"\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: [\"THUMBSTICK_X\", \"THUMBSTICK_Y\", \"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\"],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\n     * Fired when the trackpad on this controller is clicked\n     */\n    this.onTrackpadChangedObservable = new Observable();\n    /**\n     * Fired when the trackpad on this controller is modified\n     */\n    this.onTrackpadValuesChangedObservable = new Observable();\n    /**\n     * The current x and y values of this controller's trackpad\n     */\n    this.trackpad = {\n      x: 0,\n      y: 0\n    };\n    this.controllerType = PoseEnabledControllerType.WINDOWS;\n    this._loadedMeshInfo = null;\n  }\n  /**\n   * Fired when the trigger on this controller is modified\n   */\n  get onTriggerButtonStateChangedObservable() {\n    return this.onTriggerStateChangedObservable;\n  }\n  /**\n   * Fired when the menu button on this controller is modified\n   */\n  get onMenuButtonStateChangedObservable() {\n    return this.onSecondaryButtonStateChangedObservable;\n  }\n  /**\n   * Fired when the grip button on this controller is modified\n   */\n  get onGripButtonStateChangedObservable() {\n    return this.onMainButtonStateChangedObservable;\n  }\n  /**\n   * Fired when the thumbstick button on this controller is modified\n   */\n  get onThumbstickButtonStateChangedObservable() {\n    return this.onPadStateChangedObservable;\n  }\n  /**\n   * Fired when the touchpad button on this controller is modified\n   */\n  get onTouchpadButtonStateChangedObservable() {\n    return this.onTrackpadChangedObservable;\n  }\n  /**\n   * Fired when the touchpad values on this controller are modified\n   */\n  get onTouchpadValuesChangedObservable() {\n    return this.onTrackpadValuesChangedObservable;\n  }\n  _updateTrackpad() {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_X\")];\n      this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_Y\")];\n      this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  }\n  /**\n   * Called once per frame by the engine.\n   */\n  update() {\n    super.update();\n    if (this.browserGamepad.axes) {\n      this._updateTrackpad();\n      // Only need to animate axes if there is a loaded mesh\n      if (this._loadedMeshInfo) {\n        for (let axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\n          this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\n        }\n      }\n    }\n  }\n  /**\n   * Called once for each button that changed state since the last frame\n   * @param buttonIdx Which button index changed\n   * @param state New state of the button\n   */\n  _handleButtonChange(buttonIdx, state) {\n    const buttonName = this._mapping.buttons[buttonIdx];\n    if (!buttonName) {\n      return;\n    }\n    // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\n    this._updateTrackpad();\n    // Only emit events for buttons that we know how to map from index to name\n    const observable = this[this._mapping.buttonObservableNames[buttonName]];\n    if (observable) {\n      observable.notifyObservers(state);\n    }\n    this._lerpButtonTransform(buttonName, state.value);\n  }\n  /**\n   * Moves the buttons on the controller mesh based on their current state\n   * @param buttonName the name of the button to move\n   * @param buttonValue the value of the button which determines the buttons new position\n   */\n  _lerpButtonTransform(buttonName, buttonValue) {\n    // If there is no loaded mesh, there is nothing to transform.\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n    const meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\n    if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    }\n    Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);\n  }\n  /**\n   * Moves the axis on the controller mesh based on its current state\n   * @param axis the index of the axis\n   * @param axisValue the value of the axis which determines the meshes new position\n   * @internal\n   */\n  _lerpAxisTransform(axis, axisValue) {\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n    const meshInfo = this._loadedMeshInfo.axisMeshes[axis];\n    if (!meshInfo) {\n      return;\n    }\n    if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    }\n    // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n    const lerpValue = axisValue * 0.5 + 0.5;\n    Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);\n  }\n  /**\n   * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\n   * @param scene scene in which to add meshes\n   * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\n   * @param forceDefault\n   */\n  initControllerMesh(scene, meshLoaded, forceDefault = false) {\n    let path;\n    let filename;\n    // Checking if GLB loader is present\n    if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\n      // Determine the device specific folder based on the ID suffix\n      let device = \"default\";\n      if (this.id && !forceDefault) {\n        const match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\n        device = match && match[0] || device;\n      }\n      // Hand\n      if (this.hand === \"left\") {\n        filename = WindowsMotionController.MODEL_LEFT_FILENAME;\n      } else {\n        // Right is the default if no hand is specified\n        filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\n      }\n      path = WindowsMotionController.MODEL_BASE_URL + device + \"/\";\n    } else {\n      Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\n      path = GenericController.MODEL_BASE_URL;\n      filename = GenericController.MODEL_FILENAME;\n    }\n    SceneLoader.ImportMesh(\"\", path, filename, scene, meshes => {\n      // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\n      this._loadedMeshInfo = this._processModel(scene, meshes);\n      if (!this._loadedMeshInfo) {\n        return;\n      }\n      this._defaultModel = this._loadedMeshInfo.rootNode;\n      this.attachToMesh(this._defaultModel);\n      if (meshLoaded) {\n        meshLoaded(this._defaultModel);\n      }\n    }, null, (scene, message) => {\n      Logger.Log(message);\n      Logger.Warn(\"Failed to retrieve controller model from the remote server: \" + path + filename);\n      if (!forceDefault) {\n        this.initControllerMesh(scene, meshLoaded, true);\n      }\n    });\n  }\n  /**\n   * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\n   * can be transformed by button presses and axes values, based on this._mapping.\n   *\n   * @param scene scene in which the meshes exist\n   * @param meshes list of meshes that make up the controller model to process\n   * @returns structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\n   */\n  _processModel(scene, meshes) {\n    let loadedMeshInfo = null;\n    // Create a new mesh to contain the glTF hierarchy\n    const parentMesh = new Mesh(this.id + \" \" + this.hand, scene);\n    // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\n    let childMesh = null;\n    for (let i = 0; i < meshes.length; i++) {\n      const mesh = meshes[i];\n      if (!mesh.parent) {\n        // Exclude controller meshes from picking results\n        mesh.isPickable = false;\n        // Handle root node, attach to the new parentMesh\n        childMesh = mesh;\n        break;\n      }\n    }\n    if (childMesh) {\n      childMesh.setParent(parentMesh);\n      // Create our mesh info. Note that this method will always return non-null.\n      loadedMeshInfo = this._createMeshInfo(parentMesh);\n    } else {\n      Logger.Warn(\"Could not find root node in model file.\");\n    }\n    return loadedMeshInfo;\n  }\n  _createMeshInfo(rootNode) {\n    const loadedMeshInfo = new LoadedMeshInfo();\n    let i;\n    loadedMeshInfo.rootNode = rootNode;\n    // Reset the caches\n    loadedMeshInfo.buttonMeshes = {};\n    loadedMeshInfo.axisMeshes = {};\n    // Button Meshes\n    for (i = 0; i < this._mapping.buttons.length; i++) {\n      const buttonMeshName = this._mapping.buttonMeshNames[this._mapping.buttons[i]];\n      if (!buttonMeshName) {\n        Logger.Log(\"Skipping unknown button at index: \" + i + \" with mapped name: \" + this._mapping.buttons[i]);\n        continue;\n      }\n      const buttonMesh = getChildByName(rootNode, buttonMeshName);\n      if (!buttonMesh) {\n        Logger.Warn(\"Missing button mesh with name: \" + buttonMeshName);\n        continue;\n      }\n      const buttonMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(buttonMesh, \"VALUE\"),\n        pressed: getImmediateChildByName(buttonMesh, \"PRESSED\"),\n        unpressed: getImmediateChildByName(buttonMesh, \"UNPRESSED\")\n      };\n      if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\n        loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\n        Logger.Warn(\"Missing button submesh under mesh with name: \" + buttonMeshName + \"(VALUE: \" + !!buttonMeshInfo.value + \", PRESSED: \" + !!buttonMeshInfo.pressed + \", UNPRESSED:\" + !!buttonMeshInfo.unpressed + \")\");\n      }\n    }\n    // Axis Meshes\n    for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\n      const axisMeshName = this._mapping.axisMeshNames[i];\n      if (!axisMeshName) {\n        Logger.Log(\"Skipping unknown axis at index: \" + i);\n        continue;\n      }\n      const axisMesh = getChildByName(rootNode, axisMeshName);\n      if (!axisMesh) {\n        Logger.Warn(\"Missing axis mesh with name: \" + axisMeshName);\n        continue;\n      }\n      const axisMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(axisMesh, \"VALUE\"),\n        min: getImmediateChildByName(axisMesh, \"MIN\"),\n        max: getImmediateChildByName(axisMesh, \"MAX\")\n      };\n      if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\n        loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\n        Logger.Warn(\"Missing axis submesh under mesh with name: \" + axisMeshName + \"(VALUE: \" + !!axisMeshInfo.value + \", MIN: \" + !!axisMeshInfo.min + \", MAX:\" + !!axisMeshInfo.max + \")\");\n      }\n    }\n    // Pointing Ray\n    loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\n    if (!loadedMeshInfo.pointingPoseNode) {\n      Logger.Warn(\"Missing pointing pose mesh with name: \" + this._mapping.pointingPoseMeshName);\n    } else {\n      this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\n    }\n    return loadedMeshInfo;\n    // Look through all children recursively. This will return null if no mesh exists with the given name.\n    function getChildByName(node, name) {\n      return node.getChildren(n => n.name === name, false)[0];\n    }\n    // Look through only immediate children. This will return null if no mesh exists with the given name.\n    function getImmediateChildByName(node, name) {\n      return node.getChildren(n => n.name == name, true)[0];\n    }\n  }\n  /**\n   * Gets the ray of the controller in the direction the controller is pointing\n   * @param length the length the resulting ray should be\n   * @returns a ray in the direction the controller is pointing\n   */\n  getForwardRay(length = 100) {\n    if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\n      return super.getForwardRay(length);\n    }\n    const m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\n    const origin = m.getTranslation();\n    const forward = new Vector3(0, 0, -1);\n    const forwardWorld = Vector3.TransformNormal(forward, m);\n    const direction = Vector3.Normalize(forwardWorld);\n    return new Ray(origin, direction, length);\n  }\n  /**\n   * Disposes of the controller\n   */\n  dispose() {\n    super.dispose();\n    this.onTrackpadChangedObservable.clear();\n    this.onTrackpadValuesChangedObservable.clear();\n  }\n}\n/**\n * The base url used to load the left and right controller models\n */\nWindowsMotionController.MODEL_BASE_URL = \"https://controllers.babylonjs.com/microsoft/\";\n/**\n * The name of the left controller model file\n */\nWindowsMotionController.MODEL_LEFT_FILENAME = \"left.glb\";\n/**\n * The name of the right controller model file\n */\nWindowsMotionController.MODEL_RIGHT_FILENAME = \"right.glb\";\n/**\n * The controller name prefix for this controller type\n */\nWindowsMotionController.GAMEPAD_ID_PREFIX = \"Spatial Controller (Spatial Interaction Source) \";\n/**\n * The controller id pattern for this controller type\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nWindowsMotionController.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\n/**\n * This class represents a new windows motion controller in XR.\n */\nexport class XRWindowsMotionController extends WindowsMotionController {\n  /**\n   * Construct a new XR-Based windows motion controller\n   *\n   * @param gamepadInfo the gamepad object from the browser\n   */\n  constructor(gamepadInfo) {\n    super(gamepadInfo);\n    /**\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\n     */\n    this._mapping = {\n      // Semantic button names\n      buttons: [\"trigger\", \"grip\", \"trackpad\", \"thumbstick\", \"menu\"],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        trigger: \"SELECT\",\n        menu: \"MENU\",\n        grip: \"GRASP\",\n        thumbstick: \"THUMBSTICK_PRESS\",\n        trackpad: \"TOUCHPAD_PRESS\"\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        trigger: \"onTriggerStateChangedObservable\",\n        menu: \"onSecondaryButtonStateChangedObservable\",\n        grip: \"onMainButtonStateChangedObservable\",\n        thumbstick: \"onThumbstickStateChangedObservable\",\n        trackpad: \"onTrackpadChangedObservable\"\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: [\"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\", \"THUMBSTICK_X\", \"THUMBSTICK_Y\"],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\n     * holds the thumbstick values (X,Y)\n     */\n    this.thumbstickValues = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Fired when the thumbstick on this controller is clicked\n     */\n    this.onThumbstickStateChangedObservable = new Observable();\n    /**\n     * Fired when the thumbstick on this controller is modified\n     */\n    this.onThumbstickValuesChangedObservable = new Observable();\n    /**\n     * Fired when the touchpad button on this controller is modified\n     */\n    this.onTrackpadChangedObservable = this.onPadStateChangedObservable;\n    /**\n     * Fired when the touchpad values on this controller are modified\n     */\n    this.onTrackpadValuesChangedObservable = this.onPadValuesChangedObservable;\n  }\n  /**\n   * Fired when the thumbstick button on this controller is modified\n   * here to prevent breaking changes\n   */\n  get onThumbstickButtonStateChangedObservable() {\n    return this.onThumbstickStateChangedObservable;\n  }\n  /**\n   * updating the thumbstick(!) and not the trackpad.\n   * This is named this way due to the difference between WebVR and XR and to avoid\n   * changing the parent class.\n   */\n  _updateTrackpad() {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][2];\n      this.trackpad.y = this.browserGamepad[\"axes\"][3];\n      this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  }\n  /**\n   * Disposes the class with joy\n   */\n  dispose() {\n    super.dispose();\n    this.onThumbstickStateChangedObservable.clear();\n    this.onThumbstickValuesChangedObservable.clear();\n  }\n}\nPoseEnabledControllerHelper._ControllerFactories.push({\n  canCreate: gamepadInfo => {\n    return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\n  },\n  create: gamepadInfo => {\n    return new WindowsMotionController(gamepadInfo);\n  }\n});","map":{"version":3,"mappings":"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","names":["Logger","Observable","Quaternion","Vector3","Mesh","Ray","SceneLoader","WebVRController","GenericController","PoseEnabledController","PoseEnabledControllerType","PoseEnabledControllerHelper","LoadedMeshInfo","constructor","WindowsMotionController","vrGamepad","buttons","buttonMeshNames","trigger","menu","grip","thumbstick","trackpad","buttonObservableNames","axisMeshNames","pointingPoseMeshName","POINTING_POSE","x","y","controllerType","WINDOWS","_loadedMeshInfo","onTriggerButtonStateChangedObservable","onTriggerStateChangedObservable","onMenuButtonStateChangedObservable","onSecondaryButtonStateChangedObservable","onGripButtonStateChangedObservable","onMainButtonStateChangedObservable","onThumbstickButtonStateChangedObservable","onPadStateChangedObservable","onTouchpadButtonStateChangedObservable","onTrackpadChangedObservable","onTouchpadValuesChangedObservable","onTrackpadValuesChangedObservable","_updateTrackpad","browserGamepad","axes","_mapping","indexOf","notifyObservers","update","axis","length","_lerpAxisTransform","_handleButtonChange","buttonIdx","state","buttonName","observable","_lerpButtonTransform","value","buttonValue","meshInfo","buttonMeshes","unpressed","rotationQuaternion","pressed","SlerpToRef","LerpToRef","position","axisValue","axisMeshes","min","max","lerpValue","initControllerMesh","scene","meshLoaded","forceDefault","path","filename","IsPluginForExtensionAvailable","device","id","match","GAMEPAD_ID_PATTERN","hand","MODEL_LEFT_FILENAME","MODEL_RIGHT_FILENAME","MODEL_BASE_URL","Warn","MODEL_FILENAME","ImportMesh","meshes","_processModel","_defaultModel","rootNode","attachToMesh","message","Log","loadedMeshInfo","parentMesh","childMesh","i","mesh","parent","isPickable","setParent","_createMeshInfo","buttonMeshName","buttonMesh","getChildByName","buttonMeshInfo","index","getImmediateChildByName","axisMeshName","axisMesh","axisMeshInfo","pointingPoseNode","_pointingPoseNode","node","name","getChildren","n","getForwardRay","m","getWorldMatrix","origin","getTranslation","forward","forwardWorld","TransformNormal","direction","Normalize","dispose","clear","XRWindowsMotionController","gamepadInfo","onPadValuesChangedObservable","onThumbstickStateChangedObservable","thumbstickValues","onThumbstickValuesChangedObservable","_ControllerFactories","push","canCreate","GAMEPAD_ID_PREFIX","create"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Gamepads/Controllers/windowsMotionController.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Node } from \"../../node\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { WebVRController } from \"./webVRController\";\r\nimport { GenericController } from \"./genericController\";\r\nimport type { ExtendedGamepadButton } from \"./poseEnabledController\";\r\nimport { PoseEnabledController, PoseEnabledControllerType, PoseEnabledControllerHelper } from \"./poseEnabledController\";\r\nimport type { StickValues } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\r\n */\r\nclass LoadedMeshInfo {\r\n    /**\r\n     * Root of the mesh\r\n     */\r\n    public rootNode: AbstractMesh;\r\n    /**\r\n     * Node of the mesh corresponding to the direction the ray should be cast from the controller\r\n     */\r\n    public pointingPoseNode: TransformNode;\r\n    /**\r\n     * Map of the button meshes contained in the controller\r\n     */\r\n    public buttonMeshes: { [id: string]: IButtonMeshInfo } = {};\r\n    /**\r\n     * Map of the axis meshes contained in the controller\r\n     */\r\n    public axisMeshes: { [id: number]: IAxisMeshInfo } = {};\r\n}\r\n\r\n/**\r\n * Defines the IMeshInfo object that describes information a webvr controller mesh\r\n */\r\ninterface IMeshInfo {\r\n    /**\r\n     * Index of the mesh inside the root mesh\r\n     */\r\n    index: number;\r\n    /**\r\n     * The mesh\r\n     */\r\n    value: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IButtonMeshInfo object that describes a button mesh\r\n */\r\ninterface IButtonMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be displayed when pressed\r\n     */\r\n    pressed: TransformNode;\r\n    /**\r\n     * The mesh that should be displayed when not pressed\r\n     */\r\n    unpressed: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IAxisMeshInfo object that describes an axis mesh\r\n */\r\ninterface IAxisMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be set when at its min\r\n     */\r\n    min: TransformNode;\r\n    /**\r\n     * The mesh that should be set when at its max\r\n     */\r\n    max: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the WindowsMotionController object that the state of the windows motion controller\r\n */\r\nexport class WindowsMotionController extends WebVRController {\r\n    /**\r\n     * The base url used to load the left and right controller models\r\n     */\r\n    public static MODEL_BASE_URL: string = \"https://controllers.babylonjs.com/microsoft/\";\r\n    /**\r\n     * The name of the left controller model file\r\n     */\r\n    public static MODEL_LEFT_FILENAME: string = \"left.glb\";\r\n    /**\r\n     * The name of the right controller model file\r\n     */\r\n    public static MODEL_RIGHT_FILENAME: string = \"right.glb\";\r\n\r\n    /**\r\n     * The controller name prefix for this controller type\r\n     */\r\n    public static readonly GAMEPAD_ID_PREFIX: string = \"Spatial Controller (Spatial Interaction Source) \";\r\n    /**\r\n     * The controller id pattern for this controller type\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private static readonly GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\r\n\r\n    private _loadedMeshInfo: Nullable<LoadedMeshInfo>;\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: [\"thumbstick\", \"trigger\", \"grip\", \"menu\", \"trackpad\"],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            trigger: \"SELECT\",\r\n            menu: \"MENU\",\r\n            grip: \"GRASP\",\r\n            thumbstick: \"THUMBSTICK_PRESS\",\r\n            trackpad: \"TOUCHPAD_PRESS\",\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            trigger: \"onTriggerStateChangedObservable\",\r\n            menu: \"onSecondaryButtonStateChangedObservable\",\r\n            grip: \"onMainButtonStateChangedObservable\",\r\n            thumbstick: \"onPadStateChangedObservable\",\r\n            trackpad: \"onTrackpadChangedObservable\",\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\"THUMBSTICK_X\", \"THUMBSTICK_Y\", \"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\"],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE,\r\n    };\r\n\r\n    /**\r\n     * Fired when the trackpad on this controller is clicked\r\n     */\r\n    public onTrackpadChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the trackpad on this controller is modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = new Observable<StickValues>();\r\n    /**\r\n     * The current x and y values of this controller's trackpad\r\n     */\r\n    public trackpad: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Creates a new WindowsMotionController from a gamepad\r\n     * @param vrGamepad the gamepad that the controller should be created from\r\n     */\r\n    constructor(vrGamepad: any) {\r\n        super(vrGamepad);\r\n        this.controllerType = PoseEnabledControllerType.WINDOWS;\r\n        this._loadedMeshInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Fired when the trigger on this controller is modified\r\n     */\r\n    public get onTriggerButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTriggerStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the menu button on this controller is modified\r\n     */\r\n    public get onMenuButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onSecondaryButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the grip button on this controller is modified\r\n     */\r\n    public get onGripButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onMainButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onPadStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public get onTouchpadButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTrackpadChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public get onTouchpadValuesChangedObservable(): Observable<StickValues> {\r\n        return this.onTrackpadValuesChangedObservable;\r\n    }\r\n\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_X\")];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf(\"TOUCHPAD_TOUCH_Y\")];\r\n            this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once per frame by the engine.\r\n     */\r\n    public update() {\r\n        super.update();\r\n        if (this.browserGamepad.axes) {\r\n            this._updateTrackpad();\r\n            // Only need to animate axes if there is a loaded mesh\r\n            if (this._loadedMeshInfo) {\r\n                for (let axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\r\n                    this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once for each button that changed state since the last frame\r\n     * @param buttonIdx Which button index changed\r\n     * @param state New state of the button\r\n     */\r\n    protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton) {\r\n        const buttonName = this._mapping.buttons[buttonIdx];\r\n        if (!buttonName) {\r\n            return;\r\n        }\r\n\r\n        // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\r\n        this._updateTrackpad();\r\n\r\n        // Only emit events for buttons that we know how to map from index to name\r\n        const observable = (<any>this)[(<any>this._mapping.buttonObservableNames)[buttonName]];\r\n        if (observable) {\r\n            observable.notifyObservers(state);\r\n        }\r\n\r\n        this._lerpButtonTransform(buttonName, state.value);\r\n    }\r\n\r\n    /**\r\n     * Moves the buttons on the controller mesh based on their current state\r\n     * @param buttonName the name of the button to move\r\n     * @param buttonValue the value of the button which determines the buttons new position\r\n     */\r\n    protected _lerpButtonTransform(buttonName: string, buttonValue: number) {\r\n        // If there is no loaded mesh, there is nothing to transform.\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        const meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\r\n\r\n        if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axis the index of the axis\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @internal\r\n     */\r\n    protected _lerpAxisTransform(axis: number, axisValue: number) {\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        const meshInfo = this._loadedMeshInfo.axisMeshes[axis];\r\n        if (!meshInfo) {\r\n            return;\r\n        }\r\n\r\n        if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        const lerpValue = axisValue * 0.5 + 0.5;\r\n        Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\r\n     * @param scene scene in which to add meshes\r\n     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\r\n     * @param forceDefault\r\n     */\r\n    public initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void, forceDefault = false) {\r\n        let path: string;\r\n        let filename: string;\r\n\r\n        // Checking if GLB loader is present\r\n        if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\r\n            // Determine the device specific folder based on the ID suffix\r\n            let device = \"default\";\r\n            if (this.id && !forceDefault) {\r\n                const match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\r\n                device = (match && match[0]) || device;\r\n            }\r\n\r\n            // Hand\r\n            if (this.hand === \"left\") {\r\n                filename = WindowsMotionController.MODEL_LEFT_FILENAME;\r\n            } else {\r\n                // Right is the default if no hand is specified\r\n                filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\r\n            }\r\n\r\n            path = WindowsMotionController.MODEL_BASE_URL + device + \"/\";\r\n        } else {\r\n            Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\r\n            path = GenericController.MODEL_BASE_URL;\r\n            filename = GenericController.MODEL_FILENAME;\r\n        }\r\n\r\n        SceneLoader.ImportMesh(\r\n            \"\",\r\n            path,\r\n            filename,\r\n            scene,\r\n            (meshes: AbstractMesh[]) => {\r\n                // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\r\n                this._loadedMeshInfo = this._processModel(scene, meshes);\r\n\r\n                if (!this._loadedMeshInfo) {\r\n                    return;\r\n                }\r\n\r\n                this._defaultModel = this._loadedMeshInfo.rootNode;\r\n                this.attachToMesh(this._defaultModel);\r\n\r\n                if (meshLoaded) {\r\n                    meshLoaded(this._defaultModel);\r\n                }\r\n            },\r\n            null,\r\n            (scene: Scene, message: string) => {\r\n                Logger.Log(message);\r\n                Logger.Warn(\"Failed to retrieve controller model from the remote server: \" + path + filename);\r\n                if (!forceDefault) {\r\n                    this.initControllerMesh(scene, meshLoaded, true);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\r\n     * can be transformed by button presses and axes values, based on this._mapping.\r\n     *\r\n     * @param scene scene in which the meshes exist\r\n     * @param meshes list of meshes that make up the controller model to process\r\n     * @returns structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\r\n     */\r\n    private _processModel(scene: Scene, meshes: AbstractMesh[]): Nullable<LoadedMeshInfo> {\r\n        let loadedMeshInfo = null;\r\n\r\n        // Create a new mesh to contain the glTF hierarchy\r\n        const parentMesh = new Mesh(this.id + \" \" + this.hand, scene);\r\n\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        let childMesh: Nullable<AbstractMesh> = null;\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n\r\n            if (!mesh.parent) {\r\n                // Exclude controller meshes from picking results\r\n                mesh.isPickable = false;\r\n\r\n                // Handle root node, attach to the new parentMesh\r\n                childMesh = mesh;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (childMesh) {\r\n            childMesh.setParent(parentMesh);\r\n\r\n            // Create our mesh info. Note that this method will always return non-null.\r\n            loadedMeshInfo = this._createMeshInfo(parentMesh);\r\n        } else {\r\n            Logger.Warn(\"Could not find root node in model file.\");\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n    }\r\n\r\n    private _createMeshInfo(rootNode: AbstractMesh): LoadedMeshInfo {\r\n        const loadedMeshInfo = new LoadedMeshInfo();\r\n        let i;\r\n        loadedMeshInfo.rootNode = rootNode;\r\n\r\n        // Reset the caches\r\n        loadedMeshInfo.buttonMeshes = {};\r\n        loadedMeshInfo.axisMeshes = {};\r\n\r\n        // Button Meshes\r\n        for (i = 0; i < this._mapping.buttons.length; i++) {\r\n            const buttonMeshName = (<any>this._mapping.buttonMeshNames)[this._mapping.buttons[i]];\r\n            if (!buttonMeshName) {\r\n                Logger.Log(\"Skipping unknown button at index: \" + i + \" with mapped name: \" + this._mapping.buttons[i]);\r\n                continue;\r\n            }\r\n\r\n            const buttonMesh = getChildByName(rootNode, buttonMeshName);\r\n            if (!buttonMesh) {\r\n                Logger.Warn(\"Missing button mesh with name: \" + buttonMeshName);\r\n                continue;\r\n            }\r\n\r\n            const buttonMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(buttonMesh, \"VALUE\"),\r\n                pressed: getImmediateChildByName(buttonMesh, \"PRESSED\"),\r\n                unpressed: getImmediateChildByName(buttonMesh, \"UNPRESSED\"),\r\n            };\r\n            if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\r\n                loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\r\n                Logger.Warn(\r\n                    \"Missing button submesh under mesh with name: \" +\r\n                        buttonMeshName +\r\n                        \"(VALUE: \" +\r\n                        !!buttonMeshInfo.value +\r\n                        \", PRESSED: \" +\r\n                        !!buttonMeshInfo.pressed +\r\n                        \", UNPRESSED:\" +\r\n                        !!buttonMeshInfo.unpressed +\r\n                        \")\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // Axis Meshes\r\n        for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\r\n            const axisMeshName = this._mapping.axisMeshNames[i];\r\n            if (!axisMeshName) {\r\n                Logger.Log(\"Skipping unknown axis at index: \" + i);\r\n                continue;\r\n            }\r\n\r\n            const axisMesh = getChildByName(rootNode, axisMeshName);\r\n            if (!axisMesh) {\r\n                Logger.Warn(\"Missing axis mesh with name: \" + axisMeshName);\r\n                continue;\r\n            }\r\n\r\n            const axisMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(axisMesh, \"VALUE\"),\r\n                min: getImmediateChildByName(axisMesh, \"MIN\"),\r\n                max: getImmediateChildByName(axisMesh, \"MAX\"),\r\n            };\r\n            if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\r\n                loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\r\n                Logger.Warn(\r\n                    \"Missing axis submesh under mesh with name: \" +\r\n                        axisMeshName +\r\n                        \"(VALUE: \" +\r\n                        !!axisMeshInfo.value +\r\n                        \", MIN: \" +\r\n                        !!axisMeshInfo.min +\r\n                        \", MAX:\" +\r\n                        !!axisMeshInfo.max +\r\n                        \")\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // Pointing Ray\r\n        loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\r\n        if (!loadedMeshInfo.pointingPoseNode) {\r\n            Logger.Warn(\"Missing pointing pose mesh with name: \" + this._mapping.pointingPoseMeshName);\r\n        } else {\r\n            this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n\r\n        // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n        function getChildByName(node: Node, name: string) {\r\n            return <TransformNode>node.getChildren((n) => n.name === name, false)[0];\r\n        }\r\n        // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n        function getImmediateChildByName(node: Node, name: string): TransformNode {\r\n            return <TransformNode>node.getChildren((n) => n.name == name, true)[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ray of the controller in the direction the controller is pointing\r\n     * @param length the length the resulting ray should be\r\n     * @returns a ray in the direction the controller is pointing\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\r\n            return super.getForwardRay(length);\r\n        }\r\n\r\n        const m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\r\n        const origin = m.getTranslation();\r\n\r\n        const forward = new Vector3(0, 0, -1);\r\n        const forwardWorld = Vector3.TransformNormal(forward, m);\r\n\r\n        const direction = Vector3.Normalize(forwardWorld);\r\n\r\n        return new Ray(origin, direction, length);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the controller\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onTrackpadChangedObservable.clear();\r\n        this.onTrackpadValuesChangedObservable.clear();\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a new windows motion controller in XR.\r\n */\r\nexport class XRWindowsMotionController extends WindowsMotionController {\r\n    /**\r\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\r\n     */\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: [\"trigger\", \"grip\", \"trackpad\", \"thumbstick\", \"menu\"],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            trigger: \"SELECT\",\r\n            menu: \"MENU\",\r\n            grip: \"GRASP\",\r\n            thumbstick: \"THUMBSTICK_PRESS\",\r\n            trackpad: \"TOUCHPAD_PRESS\",\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            trigger: \"onTriggerStateChangedObservable\",\r\n            menu: \"onSecondaryButtonStateChangedObservable\",\r\n            grip: \"onMainButtonStateChangedObservable\",\r\n            thumbstick: \"onThumbstickStateChangedObservable\",\r\n            trackpad: \"onTrackpadChangedObservable\",\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\", \"THUMBSTICK_X\", \"THUMBSTICK_Y\"],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE,\r\n    };\r\n\r\n    /**\r\n     * Construct a new XR-Based windows motion controller\r\n     *\r\n     * @param gamepadInfo the gamepad object from the browser\r\n     */\r\n    constructor(gamepadInfo: any) {\r\n        super(gamepadInfo);\r\n    }\r\n\r\n    /**\r\n     * holds the thumbstick values (X,Y)\r\n     */\r\n    public thumbstickValues: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Fired when the thumbstick on this controller is clicked\r\n     */\r\n    public onThumbstickStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the thumbstick on this controller is modified\r\n     */\r\n    public onThumbstickValuesChangedObservable = new Observable<StickValues>();\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public onTrackpadChangedObservable = this.onPadStateChangedObservable;\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = this.onPadValuesChangedObservable;\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     * here to prevent breaking changes\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onThumbstickStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * updating the thumbstick(!) and not the trackpad.\r\n     * This is named this way due to the difference between WebVR and XR and to avoid\r\n     * changing the parent class.\r\n     */\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][2];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][3];\r\n            this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the class with joy\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onThumbstickStateChangedObservable.clear();\r\n        this.onThumbstickValuesChangedObservable.clear();\r\n    }\r\n}\r\n\r\nPoseEnabledControllerHelper._ControllerFactories.push({\r\n    canCreate: (gamepadInfo) => {\r\n        return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\r\n    },\r\n    create: (gamepadInfo) => {\r\n        return new WindowsMotionController(gamepadInfo);\r\n    },\r\n});\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}