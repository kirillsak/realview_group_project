{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EffectWrapper } from \"../../Materials/effectRenderer.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Defines the base object used for fluid rendering.\n * It is based on a list of vertices (particles)\n */\nexport class FluidRenderingObject {\n  /**\n   * Instantiates a fluid rendering object\n   * @param scene The scene the object is part of\n   */\n  constructor(scene) {\n    /** Defines the priority of the object. Objects will be rendered in ascending order of priority */\n    this.priority = 0;\n    this._particleSize = 0.1;\n    /** Observable triggered when the size of the particle is changed */\n    this.onParticleSizeChanged = new Observable();\n    /** Defines the alpha value of a particle */\n    this.particleThicknessAlpha = 0.05;\n    this._useVelocity = false;\n    this._scene = scene;\n    this._engine = scene.getEngine();\n    this._effectsAreDirty = true;\n    this._depthEffectWrapper = null;\n    this._thicknessEffectWrapper = null;\n  }\n  /** Gets or sets the size of the particle */\n  get particleSize() {\n    return this._particleSize;\n  }\n  set particleSize(size) {\n    if (size === this._particleSize) {\n      return;\n    }\n    this._particleSize = size;\n    this.onParticleSizeChanged.notifyObservers(this);\n  }\n  /** Indicates if the object uses instancing or not */\n  get useInstancing() {\n    return !this.indexBuffer;\n  }\n  /** Indicates if velocity of particles should be used when rendering the object. The vertex buffer set must contain a \"velocity\" buffer for this to work! */\n  get useVelocity() {\n    return this._useVelocity;\n  }\n  set useVelocity(use) {\n    if (this._useVelocity === use || !this._hasVelocity()) {\n      return;\n    }\n    this._useVelocity = use;\n    this._effectsAreDirty = true;\n  }\n  _hasVelocity() {\n    var _a;\n    return !!((_a = this.vertexBuffers) === null || _a === void 0 ? void 0 : _a.velocity);\n  }\n  /**\n   * Gets the index buffer (or null if the object is using instancing)\n   */\n  get indexBuffer() {\n    return null;\n  }\n  /**\n   * Gets the name of the class\n   */\n  getClassName() {\n    return \"FluidRenderingObject\";\n  }\n  _createEffects() {\n    const uniformNames = [\"view\", \"projection\", \"particleRadius\", \"size\"];\n    const attributeNames = [\"position\", \"offset\"];\n    const defines = [];\n    this._effectsAreDirty = false;\n    if (this.useVelocity) {\n      attributeNames.push(\"velocity\");\n      defines.push(\"#define FLUIDRENDERING_VELOCITY\");\n    }\n    this._depthEffectWrapper = new EffectWrapper({\n      engine: this._engine,\n      useShaderStore: true,\n      vertexShader: \"fluidRenderingParticleDepth\",\n      fragmentShader: \"fluidRenderingParticleDepth\",\n      attributeNames,\n      uniformNames,\n      samplerNames: [],\n      defines\n    });\n    uniformNames.push(\"particleAlpha\");\n    this._thicknessEffectWrapper = new EffectWrapper({\n      engine: this._engine,\n      useShaderStore: true,\n      vertexShader: \"fluidRenderingParticleThickness\",\n      fragmentShader: \"fluidRenderingParticleThickness\",\n      attributeNames: [\"position\", \"offset\"],\n      uniformNames,\n      samplerNames: []\n    });\n  }\n  /**\n   * Indicates if the object is ready to be rendered\n   * @returns True if everything is ready for the object to be rendered, otherwise false\n   */\n  isReady() {\n    if (this._effectsAreDirty) {\n      this._createEffects();\n    }\n    if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {\n      return false;\n    }\n    const depthEffect = this._depthEffectWrapper._drawWrapper.effect;\n    const thicknessEffect = this._thicknessEffectWrapper._drawWrapper.effect;\n    return depthEffect.isReady() && thicknessEffect.isReady();\n  }\n  /**\n   * Render the depth texture for this object\n   */\n  renderDepthTexture() {\n    const numParticles = this.numParticles;\n    if (!this._depthEffectWrapper || numParticles === 0) {\n      return;\n    }\n    const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;\n    const depthEffect = depthDrawWrapper.effect;\n    this._engine.enableEffect(depthDrawWrapper);\n    this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, depthEffect);\n    depthEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n    depthEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n    depthEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n    depthEffect.setFloat(\"particleRadius\", this._particleSize / 2);\n    if (this.useInstancing) {\n      this._engine.drawArraysType(7, 0, 4, numParticles);\n    } else {\n      this._engine.drawElementsType(0, 0, numParticles);\n    }\n  }\n  /**\n   * Render the thickness texture for this object\n   */\n  renderThicknessTexture() {\n    const numParticles = this.numParticles;\n    if (!this._thicknessEffectWrapper || numParticles === 0) {\n      return;\n    }\n    const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;\n    const thicknessEffect = thicknessDrawWrapper.effect;\n    this._engine.setAlphaMode(6);\n    this._engine.setDepthWrite(false);\n    this._engine.enableEffect(thicknessDrawWrapper);\n    this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, thicknessEffect);\n    thicknessEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n    thicknessEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n    thicknessEffect.setFloat(\"particleAlpha\", this.particleThicknessAlpha);\n    thicknessEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n    if (this.useInstancing) {\n      this._engine.drawArraysType(7, 0, 4, numParticles);\n    } else {\n      this._engine.drawElementsType(0, 0, numParticles);\n    }\n    this._engine.setDepthWrite(true);\n    this._engine.setAlphaMode(0);\n  }\n  /**\n   * Render the diffuse texture for this object\n   */\n  renderDiffuseTexture() {\n    // do nothing by default\n  }\n  /**\n   * Releases the ressources used by the class\n   */\n  dispose() {\n    var _a, _b;\n    (_a = this._depthEffectWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this._thicknessEffectWrapper) === null || _b === void 0 ? void 0 : _b.dispose();\n  }\n}","map":{"version":3,"mappings":"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","names":["EffectWrapper","Observable","FluidRenderingObject","constructor","scene","_scene","_engine","getEngine","_effectsAreDirty","_depthEffectWrapper","_thicknessEffectWrapper","particleSize","_particleSize","size","onParticleSizeChanged","notifyObservers","useInstancing","indexBuffer","useVelocity","_useVelocity","use","_hasVelocity","vertexBuffers","velocity","getClassName","_createEffects","uniformNames","attributeNames","defines","push","engine","useShaderStore","vertexShader","fragmentShader","samplerNames","isReady","depthEffect","_drawWrapper","effect","thicknessEffect","renderDepthTexture","numParticles","depthDrawWrapper","enableEffect","bindBuffers","setMatrix","getViewMatrix","getProjectionMatrix","setFloat2","setFloat","drawArraysType","drawElementsType","renderThicknessTexture","thicknessDrawWrapper","setAlphaMode","setDepthWrite","particleThicknessAlpha","renderDiffuseTexture","dispose"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/fluidRenderer/fluidRenderingObject.ts"],"sourcesContent":["import type { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines the base object used for fluid rendering.\r\n * It is based on a list of vertices (particles)\r\n */\r\nexport abstract class FluidRenderingObject {\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _effectsAreDirty: boolean;\r\n    protected _depthEffectWrapper: Nullable<EffectWrapper>;\r\n    protected _thicknessEffectWrapper: Nullable<EffectWrapper>;\r\n\r\n    /** Defines the priority of the object. Objects will be rendered in ascending order of priority */\r\n    public priority = 0;\r\n\r\n    protected _particleSize = 0.1;\r\n\r\n    /** Observable triggered when the size of the particle is changed */\r\n    public onParticleSizeChanged = new Observable<FluidRenderingObject>();\r\n\r\n    /** Gets or sets the size of the particle */\r\n    public get particleSize() {\r\n        return this._particleSize;\r\n    }\r\n\r\n    public set particleSize(size: number) {\r\n        if (size === this._particleSize) {\r\n            return;\r\n        }\r\n\r\n        this._particleSize = size;\r\n        this.onParticleSizeChanged.notifyObservers(this);\r\n    }\r\n\r\n    /** Defines the alpha value of a particle */\r\n    public particleThicknessAlpha = 0.05;\r\n\r\n    /** Indicates if the object uses instancing or not */\r\n    public get useInstancing() {\r\n        return !this.indexBuffer;\r\n    }\r\n\r\n    private _useVelocity = false;\r\n\r\n    /** Indicates if velocity of particles should be used when rendering the object. The vertex buffer set must contain a \"velocity\" buffer for this to work! */\r\n    public get useVelocity() {\r\n        return this._useVelocity;\r\n    }\r\n\r\n    public set useVelocity(use: boolean) {\r\n        if (this._useVelocity === use || !this._hasVelocity()) {\r\n            return;\r\n        }\r\n\r\n        this._useVelocity = use;\r\n        this._effectsAreDirty = true;\r\n    }\r\n\r\n    private _hasVelocity() {\r\n        return !!this.vertexBuffers?.velocity;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers\r\n     */\r\n    public abstract get vertexBuffers(): { [key: string]: VertexBuffer };\r\n\r\n    /**\r\n     * Gets the index buffer (or null if the object is using instancing)\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the class\r\n     */\r\n    public getClassName(): string {\r\n        return \"FluidRenderingObject\";\r\n    }\r\n\r\n    /**\r\n     * Instantiates a fluid rendering object\r\n     * @param scene The scene the object is part of\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._effectsAreDirty = true;\r\n        this._depthEffectWrapper = null;\r\n        this._thicknessEffectWrapper = null;\r\n    }\r\n\r\n    protected _createEffects(): void {\r\n        const uniformNames = [\"view\", \"projection\", \"particleRadius\", \"size\"];\r\n        const attributeNames = [\"position\", \"offset\"];\r\n        const defines: string[] = [];\r\n\r\n        this._effectsAreDirty = false;\r\n\r\n        if (this.useVelocity) {\r\n            attributeNames.push(\"velocity\");\r\n            defines.push(\"#define FLUIDRENDERING_VELOCITY\");\r\n        }\r\n\r\n        this._depthEffectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidRenderingParticleDepth\",\r\n            fragmentShader: \"fluidRenderingParticleDepth\",\r\n            attributeNames,\r\n            uniformNames,\r\n            samplerNames: [],\r\n            defines,\r\n        });\r\n\r\n        uniformNames.push(\"particleAlpha\");\r\n\r\n        this._thicknessEffectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidRenderingParticleThickness\",\r\n            fragmentShader: \"fluidRenderingParticleThickness\",\r\n            attributeNames: [\"position\", \"offset\"],\r\n            uniformNames,\r\n            samplerNames: [],\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the object is ready to be rendered\r\n     * @returns True if everything is ready for the object to be rendered, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        if (this._effectsAreDirty) {\r\n            this._createEffects();\r\n        }\r\n\r\n        if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {\r\n            return false;\r\n        }\r\n\r\n        const depthEffect = this._depthEffectWrapper._drawWrapper.effect!;\r\n        const thicknessEffect = this._thicknessEffectWrapper._drawWrapper.effect!;\r\n\r\n        return depthEffect.isReady() && thicknessEffect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles (vertices) of this object\r\n     * @returns The number of particles\r\n     */\r\n    public abstract get numParticles(): number;\r\n\r\n    /**\r\n     * Render the depth texture for this object\r\n     */\r\n    public renderDepthTexture(): void {\r\n        const numParticles = this.numParticles;\r\n\r\n        if (!this._depthEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;\r\n        const depthEffect = depthDrawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(depthDrawWrapper);\r\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, depthEffect);\r\n\r\n        depthEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        depthEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n        depthEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\r\n        depthEffect.setFloat(\"particleRadius\", this._particleSize / 2);\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, numParticles);\r\n        } else {\r\n            this._engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, numParticles);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render the thickness texture for this object\r\n     */\r\n    public renderThicknessTexture(): void {\r\n        const numParticles = this.numParticles;\r\n\r\n        if (!this._thicknessEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;\r\n        const thicknessEffect = thicknessDrawWrapper.effect!;\r\n\r\n        this._engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        this._engine.enableEffect(thicknessDrawWrapper);\r\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, thicknessEffect);\r\n\r\n        thicknessEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        thicknessEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n        thicknessEffect.setFloat(\"particleAlpha\", this.particleThicknessAlpha);\r\n        thicknessEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, numParticles);\r\n        } else {\r\n            this._engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, numParticles);\r\n        }\r\n\r\n        this._engine.setDepthWrite(true);\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n    }\r\n\r\n    /**\r\n     * Render the diffuse texture for this object\r\n     */\r\n    public renderDiffuseTexture(): void {\r\n        // do nothing by default\r\n    }\r\n\r\n    /**\r\n     * Releases the ressources used by the class\r\n     */\r\n    public dispose(): void {\r\n        this._depthEffectWrapper?.dispose();\r\n        this._thicknessEffectWrapper?.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}