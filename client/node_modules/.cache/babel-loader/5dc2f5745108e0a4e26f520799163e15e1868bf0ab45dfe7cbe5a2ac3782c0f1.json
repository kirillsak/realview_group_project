{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { RemoveComments } from \"../../Misc/codeStringParsingTools.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragment.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nconst builtInName_vertex_index = \"gl_VertexID\";\nconst builtInName_instance_index = \"gl_InstanceID\";\nconst builtInName_position = \"gl_Position\";\nconst builtInName_position_frag = \"gl_FragCoord\";\nconst builtInName_front_facing = \"gl_FrontFacing\";\nconst builtInName_frag_depth = \"gl_FragDepth\";\nconst builtInName_FragColor = \"gl_FragColor\";\nconst leftOverVarName = \"uniforms\";\nconst internalsVarName = \"internals\";\nconst gpuTextureViewDimensionByWebGPUTextureFunction = {\n  texture_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_external: null\n};\n/** @internal */\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\n  constructor() {\n    super(...arguments);\n    this.shaderLanguage = ShaderLanguage.WGSL;\n    this.uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\n    this.textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\n    this.noPrecision = true;\n  }\n  _getArraySize(name, uniformType, preProcessors) {\n    let length = 0;\n    const endArray = uniformType.lastIndexOf(\">\");\n    if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\n      let startArray = endArray;\n      while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\n        startArray--;\n      }\n      const lengthInString = uniformType.substring(startArray + 1, endArray);\n      length = +lengthInString;\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n      while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\n        startArray--;\n      }\n      uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\n    }\n    return [name, uniformType, length];\n  }\n  initializeShaders(processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._attributesWGSL = [];\n    this._attributesDeclWGSL = [];\n    this._attributeNamesWGSL = [];\n    this._varyingsWGSL = [];\n    this._varyingsDeclWGSL = [];\n    this._varyingNamesWGSL = [];\n    this._stridedUniformArrays = [];\n  }\n  preProcessShaderCode(code) {\n    return `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\nyFactor_: f32,\\ntextureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n` + RemoveComments(code);\n  }\n  varyingProcessor(varying, isFragment, preProcessors) {\n    const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    const match = varyingRegex.exec(varying);\n    if (match !== null) {\n      const varyingType = match[2];\n      const name = match[1];\n      let location;\n      if (isFragment) {\n        location = this._webgpuProcessingContext.availableVaryings[name];\n        if (location === undefined) {\n          Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\n        }\n      } else {\n        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name] = location;\n        this._varyingsWGSL.push(`@location(${location}) ${name} : ${varyingType},`);\n        this._varyingsDeclWGSL.push(`var<private> ${name} : ${varyingType};`);\n        this._varyingNamesWGSL.push(name);\n      }\n      varying = \"\";\n    }\n    return varying;\n  }\n  attributeProcessor(attribute, preProcessors) {\n    const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    const match = attribRegex.exec(attribute);\n    if (match !== null) {\n      const attributeType = match[2];\n      const name = match[1];\n      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\n      this._webgpuProcessingContext.availableAttributes[name] = location;\n      this._webgpuProcessingContext.orderedAttributes[location] = name;\n      this._attributesWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\n      this._attributesDeclWGSL.push(`var<private> ${name} : ${attributeType};`);\n      this._attributeNamesWGSL.push(name);\n      attribute = \"\";\n    }\n    return attribute;\n  }\n  uniformProcessor(uniform, isFragment, preProcessors) {\n    const match = this.uniformRegexp.exec(uniform);\n    if (match !== null) {\n      const uniformType = match[2];\n      const name = match[1];\n      this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\n      uniform = \"\";\n    }\n    return uniform;\n  }\n  textureProcessor(texture, isFragment, preProcessors) {\n    const match = this.textureRegexp.exec(texture);\n    if (match !== null) {\n      const name = match[1]; // name of the variable\n      const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\n      const isArrayOfTexture = !!match[3];\n      const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\n      const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\n      const componentType = match[6]; // f32 or i32 or u32 or undefined\n      const storageTextureFormat = isStorageTexture ? componentType.substring(0, componentType.indexOf(\",\")).trim() : null;\n      let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\n      let textureInfo = this._webgpuProcessingContext.availableTextures[name];\n      if (!textureInfo) {\n        textureInfo = {\n          isTextureArray: arraySize > 0,\n          isStorageTexture,\n          textures: [],\n          sampleType: WebGPUConstants.TextureSampleType.Float\n        };\n        arraySize = arraySize || 1;\n        for (let i = 0; i < arraySize; ++i) {\n          textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n        }\n      } else {\n        arraySize = textureInfo.textures.length;\n      }\n      this._webgpuProcessingContext.availableTextures[name] = textureInfo;\n      const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\n      const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\n      const sampleType = isDepthTexture ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u32\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i32\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n      textureInfo.sampleType = sampleType;\n      if (textureDimension === undefined) {\n        throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\n      }\n      for (let i = 0; i < arraySize; ++i) {\n        const {\n          groupIndex,\n          bindingIndex\n        } = textureInfo.textures[i];\n        if (i === 0) {\n          texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\n        }\n        this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\n      }\n    }\n    return texture;\n  }\n  postProcessor(code) {\n    return code;\n  }\n  finalizeShaders(vertexCode, fragmentCode) {\n    const fragCoordCode = fragmentCode.indexOf(\"gl_FragCoord\") >= 0 ? `\n            if (internals.yFactor_ == 1.) {\n                gl_FragCoord.y = internals.textureOutputHeight_ - gl_FragCoord.y;\n            }\n        ` : \"\";\n    // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\n    vertexCode = this._processSamplers(vertexCode, true);\n    fragmentCode = this._processSamplers(fragmentCode, false);\n    // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\n    vertexCode = this._processCustomBuffers(vertexCode, true);\n    fragmentCode = this._processCustomBuffers(fragmentCode, false);\n    // Builds the leftover UBOs.\n    const leftOverUBO = this._buildLeftOverUBO();\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode;\n    // Vertex code\n    vertexCode = vertexCode.replace(/#define /g, \"//#define \");\n    vertexCode = this._processStridedUniformArrays(vertexCode);\n    const varyingsDecl = this._varyingsDeclWGSL.join(\"\\n\") + \"\\n\";\n    const vertexBuiltinDecl = `var<private> ${builtInName_vertex_index} : u32;\\nvar<private> ${builtInName_instance_index} : u32;\\nvar<private> ${builtInName_position} : vec4<f32>;\\n`;\n    const vertexAttributesDecl = this._attributesDeclWGSL.join(\"\\n\") + \"\\n\";\n    let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\n    if (this._attributesWGSL.length > 0) {\n      vertexInputs += this._attributesWGSL.join(\"\\n\");\n    }\n    vertexInputs += \"\\n};\\n\";\n    let vertexFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\n    if (this._varyingsWGSL.length > 0) {\n      vertexFragmentInputs += this._varyingsWGSL.join(\"\\n\");\n    }\n    vertexFragmentInputs += \"\\n};\\n\";\n    vertexCode = vertexBuiltinDecl + vertexInputs + vertexAttributesDecl + vertexFragmentInputs + varyingsDecl + vertexCode;\n    let vertexStartingCode = `  var output : FragmentInputs;\\n  ${builtInName_vertex_index} = input.vertexIndex;\\n  ${builtInName_instance_index} = input.instanceIndex;\\n`;\n    for (let i = 0; i < this._attributeNamesWGSL.length; ++i) {\n      const name = this._attributeNamesWGSL[i];\n      vertexStartingCode += `  ${name} = input.${name};\\n`;\n    }\n    let vertexEndingCode = `  output.position = ${builtInName_position};\\n  output.position.y = output.position.y * internals.yFactor_;\\n`;\n    for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {\n      const name = this._varyingNamesWGSL[i];\n      vertexEndingCode += `  output.${name} = ${name};\\n`;\n    }\n    vertexEndingCode += \"  return output;\";\n    vertexCode = this._injectStartingAndEndingCode(vertexCode, \"fn main\", vertexStartingCode, vertexEndingCode);\n    // fragment code\n    fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\n    fragmentCode = this._processStridedUniformArrays(fragmentCode);\n    fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\n    const fragmentBuiltinDecl = `var<private> ${builtInName_position_frag} : vec4<f32>;\\nvar<private> ${builtInName_front_facing} : bool;\\nvar<private> ${builtInName_FragColor} : vec4<f32>;\\nvar<private> ${builtInName_frag_depth} : f32;\\n`;\n    let fragmentFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\n    if (this._varyingsWGSL.length > 0) {\n      fragmentFragmentInputs += this._varyingsWGSL.join(\"\\n\");\n    }\n    fragmentFragmentInputs += \"\\n};\\n\";\n    let fragmentOutputs = \"struct FragmentOutputs {\\n  @location(0) color : vec4<f32>,\\n\";\n    let hasFragDepth = false;\n    let idx = 0;\n    while (!hasFragDepth) {\n      idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\n      if (idx < 0) {\n        break;\n      }\n      const saveIndex = idx;\n      hasFragDepth = true;\n      while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\n        if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\n          hasFragDepth = false;\n          break;\n        }\n        idx--;\n      }\n      idx = saveIndex + builtInName_frag_depth.length;\n    }\n    if (hasFragDepth) {\n      fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\n    }\n    fragmentOutputs += \"};\\n\";\n    fragmentCode = fragmentBuiltinDecl + fragmentFragmentInputs + varyingsDecl + fragmentOutputs + fragmentCode;\n    let fragmentStartingCode = `  var output : FragmentOutputs;\\n  ${builtInName_position_frag} = input.position;\\n  ${builtInName_front_facing} = input.frontFacing;\\n` + fragCoordCode;\n    for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {\n      const name = this._varyingNamesWGSL[i];\n      fragmentStartingCode += `  ${name} = input.${name};\\n`;\n    }\n    let fragmentEndingCode = `  output.color = ${builtInName_FragColor};\\n`;\n    if (hasFragDepth) {\n      fragmentEndingCode += `  output.fragDepth = ${builtInName_frag_depth};\\n`;\n    }\n    fragmentEndingCode += \"  return output;\";\n    fragmentCode = this._injectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\n    this._collectBindingNames();\n    this._preCreateBindGroupEntries();\n    return {\n      vertexCode,\n      fragmentCode\n    };\n  }\n  _generateLeftOverUBOCode(name, uniformBufferDescription) {\n    let stridedArrays = \"\";\n    let ubo = `struct ${name} {\\n`;\n    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\n      const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\n      const size = WebGPUShaderProcessor.UniformSizes[type];\n      if (leftOverUniform.length > 0) {\n        if (size <= 2) {\n          const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\n          stridedArrays += `struct ${stridedArrayType} {\n                        @size(16)\n                        el: ${type},\n                    }`;\n          this._stridedUniformArrays.push(leftOverUniform.name);\n          ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\n        } else {\n          ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\n        }\n      } else {\n        ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\n      }\n    }\n    ubo += \"};\\n\";\n    ubo = `${stridedArrays}\\n${ubo}`;\n    ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\n    return ubo;\n  }\n  _processSamplers(code, isVertex) {\n    const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const match = samplerRegexp.exec(code);\n      if (match === null) {\n        break;\n      }\n      const name = match[1]; // name of the variable\n      const samplerType = match[2]; // sampler or sampler_comparison\n      const textureName = name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name.length - WebGPUShaderProcessor.AutoSamplerSuffix.length ? name.substring(0, name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix)) : null;\n      const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n      if (textureName) {\n        const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\n        if (textureInfo) {\n          textureInfo.autoBindSampler = true;\n        }\n      }\n      let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\n      if (!samplerInfo) {\n        samplerInfo = {\n          binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n          type: samplerBindingType\n        };\n        this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\n      }\n      this._addSamplerBindingDescription(name, samplerInfo, isVertex);\n      const part1 = code.substring(0, match.index);\n      const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\n      const part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      samplerRegexp.lastIndex += insertPart.length;\n    }\n    return code;\n  }\n  _processCustomBuffers(code, isVertex) {\n    const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const match = instantiateBufferRegexp.exec(code);\n      if (match === null) {\n        break;\n      }\n      const type = match[1];\n      const decoration = match[3];\n      let name = match[4];\n      const structName = match[5];\n      let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\n      if (!bufferInfo) {\n        const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\n        let binding;\n        if (knownUBO) {\n          name = structName;\n          binding = knownUBO.binding;\n          if (binding.groupIndex === -1) {\n            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n          }\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n        bufferInfo = {\n          binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\n      }\n      this._addBufferBindingDescription(name, this._webgpuProcessingContext.availableBuffers[name], decoration === \"read_write\" ? WebGPUConstants.BufferBindingType.Storage : type === \"storage\" ? WebGPUConstants.BufferBindingType.ReadOnlyStorage : WebGPUConstants.BufferBindingType.Uniform, isVertex);\n      const groupIndex = bufferInfo.binding.groupIndex;\n      const bindingIndex = bufferInfo.binding.bindingIndex;\n      const part1 = code.substring(0, match.index);\n      const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\n      const part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      instantiateBufferRegexp.lastIndex += insertPart.length;\n    }\n    return code;\n  }\n  _processStridedUniformArrays(code) {\n    for (const uniformArrayName of this._stridedUniformArrays) {\n      code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\n    }\n    return code;\n  }\n}","map":{"version":3,"mappings":"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","names":["WebGPUShaderProcessingContext","WebGPUConstants","Logger","WebGPUShaderProcessor","RemoveComments","ShaderLanguage","builtInName_vertex_index","builtInName_instance_index","builtInName_position","builtInName_position_frag","builtInName_front_facing","builtInName_frag_depth","builtInName_FragColor","leftOverVarName","internalsVarName","gpuTextureViewDimensionByWebGPUTextureFunction","texture_1d","TextureViewDimension","E1d","texture_2d","E2d","texture_2d_array","E2dArray","texture_3d","E3d","texture_cube","Cube","texture_cube_array","CubeArray","texture_multisampled_2d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_external","WebGPUShaderProcessorWGSL","constructor","WGSL","_getArraySize","name","uniformType","preProcessors","length","endArray","lastIndexOf","indexOf","startArray","charAt","lengthInString","substring","isNaN","trim","initializeShaders","processingContext","_webgpuProcessingContext","_attributesWGSL","_attributesDeclWGSL","_attributeNamesWGSL","_varyingsWGSL","_varyingsDeclWGSL","_varyingNamesWGSL","_stridedUniformArrays","preProcessShaderCode","code","InternalsUBOName","varyingProcessor","varying","isFragment","varyingRegex","match","exec","varyingType","location","availableVaryings","undefined","Warn","getVaryingNextLocation","push","attributeProcessor","attribute","attribRegex","attributeType","getAttributeNextLocation","availableAttributes","orderedAttributes","uniformProcessor","uniform","uniformRegexp","_addUniformToLeftOverUBO","textureProcessor","texture","textureRegexp","type","isArrayOfTexture","textureFunc","isStorageTexture","componentType","storageTextureFormat","arraySize","textureInfo","availableTextures","isTextureArray","textures","sampleType","TextureSampleType","Float","i","getNextFreeUBOBinding","isDepthTexture","textureDimension","Depth","Uint","Sint","groupIndex","bindingIndex","_addTextureBindingDescription","postProcessor","finalizeShaders","vertexCode","fragmentCode","fragCoordCode","_processSamplers","_processCustomBuffers","leftOverUBO","_buildLeftOverUBO","replace","_processStridedUniformArrays","varyingsDecl","join","vertexBuiltinDecl","vertexAttributesDecl","vertexInputs","vertexFragmentInputs","vertexStartingCode","vertexEndingCode","_injectStartingAndEndingCode","fragmentBuiltinDecl","fragmentFragmentInputs","fragmentOutputs","hasFragDepth","idx","saveIndex","fragmentStartingCode","fragmentEndingCode","_collectBindingNames","_preCreateBindGroupEntries","_generateLeftOverUBOCode","uniformBufferDescription","stridedArrays","ubo","leftOverUniform","leftOverUniforms","size","UniformSizes","stridedArrayType","binding","isVertex","samplerRegexp","samplerType","textureName","AutoSamplerSuffix","samplerBindingType","SamplerBindingType","Comparison","Filtering","autoBindSampler","samplerInfo","availableSamplers","_addSamplerBindingDescription","part1","index","insertPart","part2","lastIndex","instantiateBufferRegexp","decoration","structName","bufferInfo","availableBuffers","knownUBO","KnownUBOs","_addBufferBindingDescription","BufferBindingType","Storage","ReadOnlyStorage","Uniform","uniformArrayName","RegExp"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuShaderProcessorsWGSL.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { RemoveComments } from \"../../Misc/codeStringParsingTools\";\r\n\r\nimport \"../../ShadersWGSL/ShadersInclude/bonesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bonesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragment\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal\";\r\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nconst builtInName_vertex_index = \"gl_VertexID\";\r\nconst builtInName_instance_index = \"gl_InstanceID\";\r\nconst builtInName_position = \"gl_Position\";\r\n\r\nconst builtInName_position_frag = \"gl_FragCoord\";\r\nconst builtInName_front_facing = \"gl_FrontFacing\";\r\nconst builtInName_frag_depth = \"gl_FragDepth\";\r\nconst builtInName_FragColor = \"gl_FragColor\";\r\n\r\nconst leftOverVarName = \"uniforms\";\r\nconst internalsVarName = \"internals\";\r\n\r\nconst gpuTextureViewDimensionByWebGPUTextureFunction: { [key: string]: Nullable<GPUTextureViewDimension> } = {\r\n    texture_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_external: null,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\r\n    protected _attributesWGSL: string[];\r\n    protected _attributesDeclWGSL: string[];\r\n    protected _attributeNamesWGSL: string[];\r\n    protected _varyingsWGSL: string[];\r\n    protected _varyingsDeclWGSL: string[];\r\n    protected _varyingNamesWGSL: string[];\r\n    protected _stridedUniformArrays: string[];\r\n\r\n    public shaderLanguage = ShaderLanguage.WGSL;\r\n    public uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\r\n    public textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\r\n    public noPrecision = true;\r\n\r\n    protected _getArraySize(name: string, uniformType: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n\r\n        const endArray = uniformType.lastIndexOf(\">\");\r\n        if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\r\n            let startArray = endArray;\r\n            while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\r\n                startArray--;\r\n            }\r\n            const lengthInString = uniformType.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\r\n                startArray--;\r\n            }\r\n            uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\r\n        }\r\n\r\n        return [name, uniformType, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._attributesWGSL = [];\r\n        this._attributesDeclWGSL = [];\r\n        this._attributeNamesWGSL = [];\r\n        this._varyingsWGSL = [];\r\n        this._varyingsDeclWGSL = [];\r\n        this._varyingNamesWGSL = [];\r\n        this._stridedUniformArrays = [];\r\n    }\r\n\r\n    public preProcessShaderCode(code: string): string {\r\n        return (\r\n            `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\nyFactor_: f32,\\ntextureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n` +\r\n            RemoveComments(code)\r\n        );\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = varyingRegex.exec(varying);\r\n        if (match !== null) {\r\n            const varyingType = match[2];\r\n            const name = match[1];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._varyingsWGSL.push(`@location(${location}) ${name} : ${varyingType},`);\r\n                this._varyingsDeclWGSL.push(`var<private> ${name} : ${varyingType};`);\r\n                this._varyingNamesWGSL.push(name);\r\n            }\r\n\r\n            varying = \"\";\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = attribRegex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[2];\r\n            const name = match[1];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            this._attributesWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\r\n            this._attributesDeclWGSL.push(`var<private> ${name} : ${attributeType};`);\r\n            this._attributeNamesWGSL.push(name);\r\n            attribute = \"\";\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.uniformRegexp.exec(uniform);\r\n        if (match !== null) {\r\n            const uniformType = match[2];\r\n            const name = match[1];\r\n\r\n            this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n\r\n            uniform = \"\";\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public textureProcessor(texture: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.textureRegexp.exec(texture);\r\n        if (match !== null) {\r\n            const name = match[1]; // name of the variable\r\n            const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\r\n            const isArrayOfTexture = !!match[3];\r\n            const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\r\n            const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\r\n            const componentType = match[6]; // f32 or i32 or u32 or undefined\r\n            const storageTextureFormat = isStorageTexture ? (componentType.substring(0, componentType.indexOf(\",\")).trim() as GPUTextureFormat) : null;\r\n\r\n            let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\r\n            let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n            if (!textureInfo) {\r\n                textureInfo = {\r\n                    isTextureArray: arraySize > 0,\r\n                    isStorageTexture,\r\n                    textures: [],\r\n                    sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                };\r\n                arraySize = arraySize || 1;\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                }\r\n            } else {\r\n                arraySize = textureInfo.textures.length;\r\n            }\r\n\r\n            this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n\r\n            const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\r\n            const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\r\n            const sampleType = isDepthTexture\r\n                ? WebGPUConstants.TextureSampleType.Depth\r\n                : componentType === \"u32\"\r\n                ? WebGPUConstants.TextureSampleType.Uint\r\n                : componentType === \"i32\"\r\n                ? WebGPUConstants.TextureSampleType.Sint\r\n                : WebGPUConstants.TextureSampleType.Float;\r\n\r\n            textureInfo.sampleType = sampleType;\r\n\r\n            if (textureDimension === undefined) {\r\n                throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\r\n            }\r\n\r\n            for (let i = 0; i < arraySize; ++i) {\r\n                const { groupIndex, bindingIndex } = textureInfo.textures[i];\r\n\r\n                if (i === 0) {\r\n                    texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\r\n                }\r\n\r\n                this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    public postProcessor(code: string) {\r\n        return code;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        const fragCoordCode =\r\n            fragmentCode.indexOf(\"gl_FragCoord\") >= 0\r\n                ? `\r\n            if (internals.yFactor_ == 1.) {\r\n                gl_FragCoord.y = internals.textureOutputHeight_ - gl_FragCoord.y;\r\n            }\r\n        `\r\n                : \"\";\r\n\r\n        // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\r\n        vertexCode = this._processSamplers(vertexCode, true);\r\n        fragmentCode = this._processSamplers(fragmentCode, false);\r\n\r\n        // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\r\n        vertexCode = this._processCustomBuffers(vertexCode, true);\r\n        fragmentCode = this._processCustomBuffers(fragmentCode, false);\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        // Vertex code\r\n        vertexCode = vertexCode.replace(/#define /g, \"//#define \");\r\n        vertexCode = this._processStridedUniformArrays(vertexCode);\r\n\r\n        const varyingsDecl = this._varyingsDeclWGSL.join(\"\\n\") + \"\\n\";\r\n\r\n        const vertexBuiltinDecl = `var<private> ${builtInName_vertex_index} : u32;\\nvar<private> ${builtInName_instance_index} : u32;\\nvar<private> ${builtInName_position} : vec4<f32>;\\n`;\r\n\r\n        const vertexAttributesDecl = this._attributesDeclWGSL.join(\"\\n\") + \"\\n\";\r\n\r\n        let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\r\n        if (this._attributesWGSL.length > 0) {\r\n            vertexInputs += this._attributesWGSL.join(\"\\n\");\r\n        }\r\n        vertexInputs += \"\\n};\\n\";\r\n\r\n        let vertexFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            vertexFragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        vertexFragmentInputs += \"\\n};\\n\";\r\n\r\n        vertexCode = vertexBuiltinDecl + vertexInputs + vertexAttributesDecl + vertexFragmentInputs + varyingsDecl + vertexCode;\r\n\r\n        let vertexStartingCode = `  var output : FragmentInputs;\\n  ${builtInName_vertex_index} = input.vertexIndex;\\n  ${builtInName_instance_index} = input.instanceIndex;\\n`;\r\n\r\n        for (let i = 0; i < this._attributeNamesWGSL.length; ++i) {\r\n            const name = this._attributeNamesWGSL[i];\r\n            vertexStartingCode += `  ${name} = input.${name};\\n`;\r\n        }\r\n\r\n        let vertexEndingCode = `  output.position = ${builtInName_position};\\n  output.position.y = output.position.y * internals.yFactor_;\\n`;\r\n\r\n        for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {\r\n            const name = this._varyingNamesWGSL[i];\r\n            vertexEndingCode += `  output.${name} = ${name};\\n`;\r\n        }\r\n\r\n        vertexEndingCode += \"  return output;\";\r\n\r\n        vertexCode = this._injectStartingAndEndingCode(vertexCode, \"fn main\", vertexStartingCode, vertexEndingCode);\r\n\r\n        // fragment code\r\n        fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\r\n        fragmentCode = this._processStridedUniformArrays(fragmentCode);\r\n        fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\r\n\r\n        const fragmentBuiltinDecl = `var<private> ${builtInName_position_frag} : vec4<f32>;\\nvar<private> ${builtInName_front_facing} : bool;\\nvar<private> ${builtInName_FragColor} : vec4<f32>;\\nvar<private> ${builtInName_frag_depth} : f32;\\n`;\r\n\r\n        let fragmentFragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            fragmentFragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        fragmentFragmentInputs += \"\\n};\\n\";\r\n\r\n        let fragmentOutputs = \"struct FragmentOutputs {\\n  @location(0) color : vec4<f32>,\\n\";\r\n\r\n        let hasFragDepth = false;\r\n        let idx = 0;\r\n        while (!hasFragDepth) {\r\n            idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\r\n            if (idx < 0) {\r\n                break;\r\n            }\r\n            const saveIndex = idx;\r\n            hasFragDepth = true;\r\n            while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\r\n                if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\r\n                    hasFragDepth = false;\r\n                    break;\r\n                }\r\n                idx--;\r\n            }\r\n            idx = saveIndex + builtInName_frag_depth.length;\r\n        }\r\n\r\n        if (hasFragDepth) {\r\n            fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\r\n        }\r\n\r\n        fragmentOutputs += \"};\\n\";\r\n\r\n        fragmentCode = fragmentBuiltinDecl + fragmentFragmentInputs + varyingsDecl + fragmentOutputs + fragmentCode;\r\n\r\n        let fragmentStartingCode =\r\n            `  var output : FragmentOutputs;\\n  ${builtInName_position_frag} = input.position;\\n  ${builtInName_front_facing} = input.frontFacing;\\n` + fragCoordCode;\r\n\r\n        for (let i = 0; i < this._varyingNamesWGSL.length; ++i) {\r\n            const name = this._varyingNamesWGSL[i];\r\n            fragmentStartingCode += `  ${name} = input.${name};\\n`;\r\n        }\r\n\r\n        let fragmentEndingCode = `  output.color = ${builtInName_FragColor};\\n`;\r\n\r\n        if (hasFragDepth) {\r\n            fragmentEndingCode += `  output.fragDepth = ${builtInName_frag_depth};\\n`;\r\n        }\r\n\r\n        fragmentEndingCode += \"  return output;\";\r\n\r\n        fragmentCode = this._injectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let stridedArrays = \"\";\r\n        let ubo = `struct ${name} {\\n`;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n\r\n            if (leftOverUniform.length > 0) {\r\n                if (size <= 2) {\r\n                    const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\r\n                    stridedArrays += `struct ${stridedArrayType} {\r\n                        @size(16)\r\n                        el: ${type},\r\n                    }`;\r\n                    this._stridedUniformArrays.push(leftOverUniform.name);\r\n\r\n                    ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\r\n                } else {\r\n                    ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\r\n                }\r\n            } else {\r\n                ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\";\r\n        ubo = `${stridedArrays}\\n${ubo}`;\r\n        ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\r\n\r\n        return ubo;\r\n    }\r\n\r\n    private _processSamplers(code: string, isVertex: boolean): string {\r\n        const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = samplerRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const name = match[1]; // name of the variable\r\n            const samplerType = match[2]; // sampler or sampler_comparison\r\n            const textureName =\r\n                name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name.length - WebGPUShaderProcessor.AutoSamplerSuffix.length\r\n                    ? name.substring(0, name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix))\r\n                    : null;\r\n            const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n            if (textureName) {\r\n                const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\r\n                if (textureInfo) {\r\n                    textureInfo.autoBindSampler = true;\r\n                }\r\n            }\r\n\r\n            let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\r\n            if (!samplerInfo) {\r\n                samplerInfo = {\r\n                    binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                    type: samplerBindingType,\r\n                };\r\n                this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\r\n            }\r\n\r\n            this._addSamplerBindingDescription(name, samplerInfo, isVertex);\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            samplerRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processCustomBuffers(code: string, isVertex: boolean): string {\r\n        const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = instantiateBufferRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const type = match[1];\r\n            const decoration = match[3];\r\n            let name = match[4];\r\n            const structName = match[5];\r\n\r\n            let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!bufferInfo) {\r\n                const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\r\n\r\n                let binding;\r\n                if (knownUBO) {\r\n                    name = structName;\r\n                    binding = knownUBO.binding;\r\n                    if (binding.groupIndex === -1) {\r\n                        binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                    }\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                bufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(\r\n                name,\r\n                this._webgpuProcessingContext.availableBuffers[name],\r\n                decoration === \"read_write\"\r\n                    ? WebGPUConstants.BufferBindingType.Storage\r\n                    : type === \"storage\"\r\n                    ? WebGPUConstants.BufferBindingType.ReadOnlyStorage\r\n                    : WebGPUConstants.BufferBindingType.Uniform,\r\n                isVertex\r\n            );\r\n\r\n            const groupIndex = bufferInfo.binding.groupIndex;\r\n            const bindingIndex = bufferInfo.binding.bindingIndex;\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            instantiateBufferRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processStridedUniformArrays(code: string): string {\r\n        for (const uniformArrayName of this._stridedUniformArrays) {\r\n            code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\r\n        }\r\n        return code;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}