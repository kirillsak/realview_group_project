{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Geometry } from \"../../Meshes/geometry.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { MultiMaterial } from \"../../Materials/multiMaterial.js\";\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture.js\";\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture.js\";\nimport { AnimationGroup } from \"../../Animations/animationGroup.js\";\nimport { Light } from \"../../Lights/light.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\nimport { AssetContainer } from \"../../assetContainer.js\";\nimport { ActionManager } from \"../../Actions/actionManager.js\";\nimport { Skeleton } from \"../../Bones/skeleton.js\";\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager.js\";\nimport { CannonJSPlugin } from \"../../Physics/v1/Plugins/cannonJSPlugin.js\";\nimport { OimoJSPlugin } from \"../../Physics/v1/Plugins/oimoJSPlugin.js\";\nimport { AmmoJSPlugin } from \"../../Physics/v1/Plugins/ammoJSPlugin.js\";\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention, no-var\nexport var _BabylonLoaderRegistered = true;\n/**\n * Helps setting up some configuration for the babylon file loader.\n */\nexport class BabylonFileLoaderConfiguration {}\n/**\n * The loader does not allow injecting custom physics engine into the plugins.\n * Unfortunately in ES6, we need to manually inject them into the plugin.\n * So you could set this variable to your engine import to make it work.\n */\nBabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine = undefined;\nlet tempIndexContainer = {};\nlet tempMaterialIndexContainer = {};\nconst parseMaterialByPredicate = (predicate, parsedData, scene, rootUrl) => {\n  if (!parsedData.materials) {\n    return null;\n  }\n  for (let index = 0, cache = parsedData.materials.length; index < cache; index++) {\n    const parsedMaterial = parsedData.materials[index];\n    if (predicate(parsedMaterial)) {\n      return {\n        parsedMaterial,\n        material: Material.Parse(parsedMaterial, scene, rootUrl)\n      };\n    }\n  }\n  return null;\n};\nconst isDescendantOf = (mesh, names, hierarchyIds) => {\n  for (const i in names) {\n    if (mesh.name === names[i]) {\n      hierarchyIds.push(mesh.id);\n      return true;\n    }\n  }\n  if (mesh.parentId !== undefined && hierarchyIds.indexOf(mesh.parentId) !== -1) {\n    hierarchyIds.push(mesh.id);\n    return true;\n  }\n  return false;\n};\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst logOperation = (operation, producer) => {\n  return operation + \" of \" + (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\");\n};\nconst loadDetailLevels = (scene, mesh) => {\n  const mastermesh = mesh;\n  // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\n  // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\n  if (mesh._waitingData.lods) {\n    if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\n      const lodmeshes = mesh._waitingData.lods.ids;\n      const wasenabled = mastermesh.isEnabled(false);\n      if (mesh._waitingData.lods.distances) {\n        const distances = mesh._waitingData.lods.distances;\n        if (distances.length >= lodmeshes.length) {\n          const culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\n          mastermesh.setEnabled(false);\n          for (let index = 0; index < lodmeshes.length; index++) {\n            const lodid = lodmeshes[index];\n            const lodmesh = scene.getMeshById(lodid);\n            if (lodmesh != null) {\n              mastermesh.addLODLevel(distances[index], lodmesh);\n            }\n          }\n          if (culling > 0) {\n            mastermesh.addLODLevel(culling, null);\n          }\n          if (wasenabled === true) {\n            mastermesh.setEnabled(true);\n          }\n        } else {\n          Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\n        }\n      }\n    }\n    mesh._waitingData.lods = null;\n  }\n};\nconst findParent = (parentId, parentInstanceIndex, scene) => {\n  if (typeof parentId !== \"number\") {\n    const parentEntry = scene.getLastEntryById(parentId);\n    if (parentEntry && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\n      const instance = parentEntry.instances[parseInt(parentInstanceIndex)];\n      return instance;\n    }\n    return parentEntry;\n  }\n  const parent = tempIndexContainer[parentId];\n  if (parent && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\n    const instance = parent.instances[parseInt(parentInstanceIndex)];\n    return instance;\n  }\n  return parent;\n};\nconst findMaterial = (materialId, scene) => {\n  if (typeof materialId !== \"number\") {\n    return scene.getLastMaterialById(materialId, true);\n  }\n  return tempMaterialIndexContainer[materialId];\n};\nconst loadAssetContainer = (scene, data, rootUrl, onError, addToScene = false) => {\n  const container = new AssetContainer(scene);\n  // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n  // when SceneLoader.debugLogging = true (default), or exception encountered.\n  // Everything stored in var log instead of writing separate lines to support only writing in exception,\n  // and avoid problems with multiple concurrent .babylon loads.\n  let log = \"importScene has failed JSON parse\";\n  try {\n    // eslint-disable-next-line no-var\n    var parsedData = JSON.parse(data);\n    log = \"\";\n    const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n    let index;\n    let cache;\n    // Environment texture\n    if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\n      // PBR needed for both HDR texture (gamma space) & a sky box\n      const isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\n      if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\n        const hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\n        const hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR, undefined, parsedData.environmentTexturePrefilterOnLoad);\n        if (parsedData.environmentTextureRotationY) {\n          hdrTexture.rotationY = parsedData.environmentTextureRotationY;\n        }\n        scene.environmentTexture = hdrTexture;\n      } else {\n        if (typeof parsedData.environmentTexture === \"object\") {\n          const environmentTexture = CubeTexture.Parse(parsedData.environmentTexture, scene, rootUrl);\n          scene.environmentTexture = environmentTexture;\n        } else if (parsedData.environmentTexture.endsWith(\".env\")) {\n          const compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);\n          if (parsedData.environmentTextureRotationY) {\n            compressedTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n          scene.environmentTexture = compressedTexture;\n        } else {\n          const cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);\n          if (parsedData.environmentTextureRotationY) {\n            cubeTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n          scene.environmentTexture = cubeTexture;\n        }\n      }\n      if (parsedData.createDefaultSkybox === true) {\n        const skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\n        const skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\n        scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\n      }\n      container.environmentTexture = scene.environmentTexture;\n    }\n    // Environment Intensity\n    if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\n      scene.environmentIntensity = parsedData.environmentIntensity;\n    }\n    // Lights\n    if (parsedData.lights !== undefined && parsedData.lights !== null) {\n      for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\n        const parsedLight = parsedData.lights[index];\n        const light = Light.Parse(parsedLight, scene);\n        if (light) {\n          tempIndexContainer[parsedLight.uniqueId] = light;\n          container.lights.push(light);\n          light._parentContainer = container;\n          log += index === 0 ? \"\\n\\tLights:\" : \"\";\n          log += \"\\n\\t\\t\" + light.toString(fullDetails);\n        }\n      }\n    }\n    // Reflection probes\n    if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\n      for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\n        const parsedReflectionProbe = parsedData.reflectionProbes[index];\n        const reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\n        if (reflectionProbe) {\n          container.reflectionProbes.push(reflectionProbe);\n          reflectionProbe._parentContainer = container;\n          log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\n          log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\n        }\n      }\n    }\n    // Animations\n    if (parsedData.animations !== undefined && parsedData.animations !== null) {\n      for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\n        const parsedAnimation = parsedData.animations[index];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          const animation = internalClass.Parse(parsedAnimation);\n          scene.animations.push(animation);\n          container.animations.push(animation);\n          log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\n          log += \"\\n\\t\\t\" + animation.toString(fullDetails);\n        }\n      }\n    }\n    // Materials\n    if (parsedData.materials !== undefined && parsedData.materials !== null) {\n      for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\n        const parsedMaterial = parsedData.materials[index];\n        const mat = Material.Parse(parsedMaterial, scene, rootUrl);\n        if (mat) {\n          tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;\n          container.materials.push(mat);\n          mat._parentContainer = container;\n          log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\n          log += \"\\n\\t\\t\" + mat.toString(fullDetails);\n          // Textures\n          const textures = mat.getActiveTextures();\n          textures.forEach(t => {\n            if (container.textures.indexOf(t) == -1) {\n              container.textures.push(t);\n              t._parentContainer = container;\n            }\n          });\n        }\n      }\n    }\n    if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n      for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\n        const parsedMultiMaterial = parsedData.multiMaterials[index];\n        const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n        container.multiMaterials.push(mmat);\n        mmat._parentContainer = container;\n        log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\n        log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\n        // Textures\n        const textures = mmat.getActiveTextures();\n        textures.forEach(t => {\n          if (container.textures.indexOf(t) == -1) {\n            container.textures.push(t);\n            t._parentContainer = container;\n          }\n        });\n      }\n    }\n    // Morph targets\n    if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n      for (const managerData of parsedData.morphTargetManagers) {\n        const manager = MorphTargetManager.Parse(managerData, scene);\n        container.morphTargetManagers.push(manager);\n        manager._parentContainer = container;\n      }\n    }\n    // Skeletons\n    if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n      for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\n        const parsedSkeleton = parsedData.skeletons[index];\n        const skeleton = Skeleton.Parse(parsedSkeleton, scene);\n        container.skeletons.push(skeleton);\n        skeleton._parentContainer = container;\n        log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\n        log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\n      }\n    }\n    // Geometries\n    const geometries = parsedData.geometries;\n    if (geometries !== undefined && geometries !== null) {\n      const addedGeometry = new Array();\n      // VertexData\n      const vertexData = geometries.vertexData;\n      if (vertexData !== undefined && vertexData !== null) {\n        for (index = 0, cache = vertexData.length; index < cache; index++) {\n          const parsedVertexData = vertexData[index];\n          addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\n        }\n      }\n      addedGeometry.forEach(g => {\n        if (g) {\n          container.geometries.push(g);\n          g._parentContainer = container;\n        }\n      });\n    }\n    // Transform nodes\n    if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n      for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n        const parsedTransformNode = parsedData.transformNodes[index];\n        const node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\n        tempIndexContainer[parsedTransformNode.uniqueId] = node;\n        container.transformNodes.push(node);\n        node._parentContainer = container;\n      }\n    }\n    // Meshes\n    if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n      for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n        const parsedMesh = parsedData.meshes[index];\n        const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n        tempIndexContainer[parsedMesh.uniqueId] = mesh;\n        container.meshes.push(mesh);\n        mesh._parentContainer = container;\n        if (mesh.hasInstances) {\n          for (const instance of mesh.instances) {\n            container.meshes.push(instance);\n            instance._parentContainer = container;\n          }\n        }\n        log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\n        log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\n      }\n    }\n    // Cameras\n    if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\n      for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\n        const parsedCamera = parsedData.cameras[index];\n        const camera = Camera.Parse(parsedCamera, scene);\n        tempIndexContainer[parsedCamera.uniqueId] = camera;\n        container.cameras.push(camera);\n        camera._parentContainer = container;\n        log += index === 0 ? \"\\n\\tCameras:\" : \"\";\n        log += \"\\n\\t\\t\" + camera.toString(fullDetails);\n      }\n    }\n    // Postprocesses\n    if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\n      for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\n        const parsedPostProcess = parsedData.postProcesses[index];\n        const postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\n        if (postProcess) {\n          container.postProcesses.push(postProcess);\n          postProcess._parentContainer = container;\n          log += index === 0 ? \"\\nPostprocesses:\" : \"\";\n          log += \"\\n\\t\\t\" + postProcess.toString();\n        }\n      }\n    }\n    // Animation Groups\n    if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\n      for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\n        const parsedAnimationGroup = parsedData.animationGroups[index];\n        const animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\n        container.animationGroups.push(animationGroup);\n        animationGroup._parentContainer = container;\n        log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\n        log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\n      }\n    }\n    // Browsing all the graph to connect the dots\n    for (index = 0, cache = scene.cameras.length; index < cache; index++) {\n      const camera = scene.cameras[index];\n      if (camera._waitingParentId !== null) {\n        camera.parent = findParent(camera._waitingParentId, camera._waitingParentInstanceIndex, scene);\n        camera._waitingParentId = null;\n        camera._waitingParentInstanceIndex = null;\n      }\n    }\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      const light = scene.lights[index];\n      if (light && light._waitingParentId !== null) {\n        light.parent = findParent(light._waitingParentId, light._waitingParentInstanceIndex, scene);\n        light._waitingParentId = null;\n        light._waitingParentInstanceIndex = null;\n      }\n    }\n    // Connect parents & children and parse actions and lods\n    for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n      const transformNode = scene.transformNodes[index];\n      if (transformNode._waitingParentId !== null) {\n        transformNode.parent = findParent(transformNode._waitingParentId, transformNode._waitingParentInstanceIndex, scene);\n        transformNode._waitingParentId = null;\n        transformNode._waitingParentInstanceIndex = null;\n      }\n    }\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      const mesh = scene.meshes[index];\n      if (mesh._waitingParentId !== null) {\n        mesh.parent = findParent(mesh._waitingParentId, mesh._waitingParentInstanceIndex, scene);\n        mesh._waitingParentId = null;\n        mesh._waitingParentInstanceIndex = null;\n      }\n      if (mesh._waitingData.lods) {\n        loadDetailLevels(scene, mesh);\n      }\n    }\n    // link multimats with materials\n    scene.multiMaterials.forEach(multimat => {\n      multimat._waitingSubMaterialsUniqueIds.forEach(subMaterial => {\n        multimat.subMaterials.push(findMaterial(subMaterial, scene));\n      });\n      multimat._waitingSubMaterialsUniqueIds = [];\n    });\n    // link meshes with materials\n    scene.meshes.forEach(mesh => {\n      if (mesh._waitingMaterialId !== null) {\n        mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n        mesh._waitingMaterialId = null;\n      }\n    });\n    // link skeleton transform nodes\n    for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n      const skeleton = scene.skeletons[index];\n      if (skeleton._hasWaitingData) {\n        if (skeleton.bones != null) {\n          skeleton.bones.forEach(bone => {\n            if (bone._waitingTransformNodeId) {\n              const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n              if (linkTransformNode) {\n                bone.linkTransformNode(linkTransformNode);\n              }\n              bone._waitingTransformNodeId = null;\n            }\n          });\n        }\n        skeleton._hasWaitingData = null;\n      }\n    }\n    // freeze world matrix application\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      const currentMesh = scene.meshes[index];\n      if (currentMesh._waitingData.freezeWorldMatrix) {\n        currentMesh.freezeWorldMatrix();\n        currentMesh._waitingData.freezeWorldMatrix = null;\n      } else {\n        currentMesh.computeWorldMatrix(true);\n      }\n    }\n    // Lights exclusions / inclusions\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      const light = scene.lights[index];\n      // Excluded check\n      if (light._excludedMeshesIds.length > 0) {\n        for (let excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\n          const excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);\n          if (excludedMesh) {\n            light.excludedMeshes.push(excludedMesh);\n          }\n        }\n        light._excludedMeshesIds = [];\n      }\n      // Included check\n      if (light._includedOnlyMeshesIds.length > 0) {\n        for (let includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\n          const includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);\n          if (includedOnlyMesh) {\n            light.includedOnlyMeshes.push(includedOnlyMesh);\n          }\n        }\n        light._includedOnlyMeshesIds = [];\n      }\n    }\n    scene.geometries.forEach(g => {\n      g._loadedUniqueId = \"\";\n    });\n    AbstractScene.Parse(parsedData, scene, container, rootUrl);\n    // Actions (scene) Done last as it can access other objects.\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      const mesh = scene.meshes[index];\n      if (mesh._waitingData.actions) {\n        ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\n        mesh._waitingData.actions = null;\n      }\n    }\n    if (parsedData.actions !== undefined && parsedData.actions !== null) {\n      ActionManager.Parse(parsedData.actions, null, scene);\n    }\n  } catch (err) {\n    const msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\n    if (onError) {\n      onError(msg, err);\n    } else {\n      Logger.Log(msg);\n      throw err;\n    }\n  } finally {\n    tempIndexContainer = {};\n    tempMaterialIndexContainer = {};\n    if (!addToScene) {\n      container.removeAllFromScene();\n    }\n    if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n      Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n    }\n  }\n  return container;\n};\nSceneLoader.RegisterPlugin({\n  name: \"babylon.js\",\n  extensions: \".babylon\",\n  canDirectLoad: data => {\n    if (data.indexOf(\"babylon\") !== -1) {\n      // We consider that the producer string is filled\n      return true;\n    }\n    return false;\n  },\n  importMesh: (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) => {\n    var _a;\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    let log = \"importMesh has failed JSON parse\";\n    try {\n      // eslint-disable-next-line no-var\n      var parsedData = JSON.parse(data);\n      log = \"\";\n      const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n      if (!meshesNames) {\n        meshesNames = null;\n      } else if (!Array.isArray(meshesNames)) {\n        meshesNames = [meshesNames];\n      }\n      const hierarchyIds = new Array();\n      const parsedIdToNodeMap = new Map();\n      // Transform nodes (the overall idea is to load all of them as this is super fast and then get rid of the ones we don't need)\n      const loadedTransformNodes = [];\n      if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n        for (let index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n          const parsedJSONTransformNode = parsedData.transformNodes[index];\n          const parsedTransformNode = TransformNode.Parse(parsedJSONTransformNode, scene, rootUrl);\n          loadedTransformNodes.push(parsedTransformNode);\n          parsedIdToNodeMap.set(parsedTransformNode._waitingParsedUniqueId, parsedTransformNode);\n          parsedTransformNode._waitingParsedUniqueId = null;\n        }\n      }\n      if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n        const loadedSkeletonsIds = [];\n        const loadedMaterialsIds = [];\n        const loadedMaterialsUniqueIds = [];\n        const loadedMorphTargetsIds = [];\n        for (let index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n          const parsedMesh = parsedData.meshes[index];\n          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\n            if (meshesNames !== null) {\n              // Remove found mesh name from list.\n              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\n            }\n            //Geometry?\n            if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\n              //does the file contain geometries?\n              if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\n                //find the correct geometry and add it to the scene\n                let found = false;\n                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach(geometryType => {\n                  if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\n                    return;\n                  } else {\n                    parsedData.geometries[geometryType].forEach(parsedGeometryData => {\n                      if (parsedGeometryData.id === parsedMesh.geometryId) {\n                        switch (geometryType) {\n                          case \"vertexData\":\n                            Geometry.Parse(parsedGeometryData, scene, rootUrl);\n                            break;\n                        }\n                        found = true;\n                      }\n                    });\n                  }\n                });\n                if (found === false) {\n                  Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\n                }\n              }\n            }\n            // Material ?\n            if (parsedMesh.materialUniqueId || parsedMesh.materialId) {\n              // if we have a unique ID, look up and store in loadedMaterialsUniqueIds, else use loadedMaterialsIds\n              const materialArray = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;\n              let materialFound = materialArray.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;\n              if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n                // Loads a submaterial of a multimaterial\n                const loadSubMaterial = (subMatId, predicate) => {\n                  materialArray.push(subMatId);\n                  const mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);\n                  if (mat && mat.material) {\n                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                    log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\n                  }\n                };\n                for (let multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\n                  const parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\n                  if (parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMultiMaterial.id === parsedMesh.materialId) {\n                    if (parsedMultiMaterial.materialsUniqueIds) {\n                      // if the materials inside the multimat are stored by unique id\n                      parsedMultiMaterial.materialsUniqueIds.forEach(subMatId => loadSubMaterial(subMatId, parsedMaterial => parsedMaterial.uniqueId === subMatId));\n                    } else {\n                      // if the mats are stored by id instead\n                      parsedMultiMaterial.materials.forEach(subMatId => loadSubMaterial(subMatId, parsedMaterial => parsedMaterial.id === subMatId));\n                    }\n                    materialArray.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);\n                    const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n                    tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n                    if (mmat) {\n                      materialFound = true;\n                      log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\n                    }\n                    break;\n                  }\n                }\n              }\n              if (materialFound === false) {\n                materialArray.push(parsedMesh.materialUniqueId || parsedMesh.materialId);\n                const mat = parseMaterialByPredicate(parsedMaterial => parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMaterial.id === parsedMesh.materialId, parsedData, scene, rootUrl);\n                if (!mat || !mat.material) {\n                  Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\n                } else {\n                  tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                  log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\n                }\n              }\n            }\n            // Skeleton ?\n            if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n              const skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\n              if (!skeletonAlreadyLoaded) {\n                for (let skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\n                  const parsedSkeleton = parsedData.skeletons[skeletonIndex];\n                  if (parsedSkeleton.id === parsedMesh.skeletonId) {\n                    const skeleton = Skeleton.Parse(parsedSkeleton, scene);\n                    skeletons.push(skeleton);\n                    loadedSkeletonsIds.push(parsedSkeleton.id);\n                    log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\n                  }\n                }\n              }\n            }\n            // Morph targets ?\n            if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n              const morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;\n              if (!morphTargetAlreadyLoaded) {\n                for (let morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {\n                  const parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];\n                  if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {\n                    const morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);\n                    loadedMorphTargetsIds.push(morphTarget.uniqueId);\n                    log += \"\\nMorph target \" + morphTarget.toString();\n                  }\n                }\n              }\n            }\n            const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n            meshes.push(mesh);\n            parsedIdToNodeMap.set(mesh._waitingParsedUniqueId, mesh);\n            mesh._waitingParsedUniqueId = null;\n            log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\n          }\n        }\n        // link multimats with materials\n        scene.multiMaterials.forEach(multimat => {\n          multimat._waitingSubMaterialsUniqueIds.forEach(subMaterial => {\n            multimat.subMaterials.push(findMaterial(subMaterial, scene));\n          });\n          multimat._waitingSubMaterialsUniqueIds = [];\n        });\n        // link meshes with materials\n        scene.meshes.forEach(mesh => {\n          if (mesh._waitingMaterialId !== null) {\n            mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n            mesh._waitingMaterialId = null;\n          }\n        });\n        // Connecting parents and lods\n        for (let index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n          const transformNode = scene.transformNodes[index];\n          if (transformNode._waitingParentId !== null) {\n            let parent = parsedIdToNodeMap.get(parseInt(transformNode._waitingParentId)) || null;\n            if (parent === null) {\n              parent = scene.getLastEntryById(transformNode._waitingParentId);\n            }\n            let parentNode = parent;\n            if (transformNode._waitingParentInstanceIndex) {\n              parentNode = parent.instances[parseInt(transformNode._waitingParentInstanceIndex)];\n              transformNode._waitingParentInstanceIndex = null;\n            }\n            transformNode.parent = parentNode;\n            transformNode._waitingParentId = null;\n          }\n        }\n        let currentMesh;\n        for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n          if (currentMesh._waitingParentId) {\n            let parent = parsedIdToNodeMap.get(parseInt(currentMesh._waitingParentId)) || null;\n            if (parent === null) {\n              parent = scene.getLastEntryById(currentMesh._waitingParentId);\n            }\n            let parentNode = parent;\n            if (currentMesh._waitingParentInstanceIndex) {\n              parentNode = parent.instances[parseInt(currentMesh._waitingParentInstanceIndex)];\n              currentMesh._waitingParentInstanceIndex = null;\n            }\n            currentMesh.parent = parentNode;\n            if (((_a = currentMesh.parent) === null || _a === void 0 ? void 0 : _a.getClassName()) === \"TransformNode\") {\n              const loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent);\n              if (loadedTransformNodeIndex > -1) {\n                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);\n              }\n            }\n            currentMesh._waitingParentId = null;\n          }\n          if (currentMesh._waitingData.lods) {\n            loadDetailLevels(scene, currentMesh);\n          }\n        }\n        // Remove unused transform nodes\n        for (const transformNode of loadedTransformNodes) {\n          transformNode.dispose();\n        }\n        // link skeleton transform nodes\n        for (let index = 0, cache = scene.skeletons.length; index < cache; index++) {\n          const skeleton = scene.skeletons[index];\n          if (skeleton._hasWaitingData) {\n            if (skeleton.bones != null) {\n              skeleton.bones.forEach(bone => {\n                if (bone._waitingTransformNodeId) {\n                  const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n                  if (linkTransformNode) {\n                    bone.linkTransformNode(linkTransformNode);\n                  }\n                  bone._waitingTransformNodeId = null;\n                }\n              });\n            }\n            skeleton._hasWaitingData = null;\n          }\n        }\n        // freeze and compute world matrix application\n        for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n          if (currentMesh._waitingData.freezeWorldMatrix) {\n            currentMesh.freezeWorldMatrix();\n            currentMesh._waitingData.freezeWorldMatrix = null;\n          } else {\n            currentMesh.computeWorldMatrix(true);\n          }\n        }\n      }\n      // Particles\n      if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n        const parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n        if (parser) {\n          for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n            const parsedParticleSystem = parsedData.particleSystems[index];\n            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\n              particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\n            }\n          }\n        }\n      }\n      return true;\n    } catch (err) {\n      const msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n    return false;\n  },\n  load: (scene, data, rootUrl, onError) => {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    let log = \"importScene has failed JSON parse\";\n    try {\n      // eslint-disable-next-line no-var\n      var parsedData = JSON.parse(data);\n      log = \"\";\n      // Scene\n      if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\n        scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\n      }\n      if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\n        scene.autoClear = parsedData.autoClear;\n      }\n      if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\n        scene.clearColor = Color4.FromArray(parsedData.clearColor);\n      }\n      if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\n        scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\n      }\n      if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\n        scene.gravity = Vector3.FromArray(parsedData.gravity);\n      }\n      if (parsedData.useRightHandedSystem !== undefined) {\n        scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;\n      }\n      // Fog\n      if (parsedData.fogMode && parsedData.fogMode !== 0) {\n        scene.fogMode = parsedData.fogMode;\n        scene.fogColor = Color3.FromArray(parsedData.fogColor);\n        scene.fogStart = parsedData.fogStart;\n        scene.fogEnd = parsedData.fogEnd;\n        scene.fogDensity = parsedData.fogDensity;\n        log += \"\\tFog mode for scene:  \";\n        switch (scene.fogMode) {\n          // getters not compiling, so using hardcoded\n          case 1:\n            log += \"exp\\n\";\n            break;\n          case 2:\n            log += \"exp2\\n\";\n            break;\n          case 3:\n            log += \"linear\\n\";\n            break;\n        }\n      }\n      //Physics\n      if (parsedData.physicsEnabled) {\n        let physicsPlugin;\n        if (parsedData.physicsEngine === \"cannon\" || parsedData.physicsEngine === CannonJSPlugin.name) {\n          physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"oimo\" || parsedData.physicsEngine === OimoJSPlugin.name) {\n          physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"ammo\" || parsedData.physicsEngine === AmmoJSPlugin.name) {\n          physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\n        }\n        log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\n        //else - default engine, which is currently oimo\n        const physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\n        scene.enablePhysics(physicsGravity, physicsPlugin);\n      }\n      // Metadata\n      if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\n        scene.metadata = parsedData.metadata;\n      }\n      //collisions, if defined. otherwise, default is true\n      if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\n        scene.collisionsEnabled = parsedData.collisionsEnabled;\n      }\n      const container = loadAssetContainer(scene, data, rootUrl, onError, true);\n      if (!container) {\n        return false;\n      }\n      if (parsedData.autoAnimate) {\n        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\n      }\n      if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\n        scene.setActiveCameraById(parsedData.activeCameraID);\n      }\n      // Finish\n      return true;\n    } catch (err) {\n      const msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n    return false;\n  },\n  loadAssetContainer: (scene, data, rootUrl, onError) => {\n    const container = loadAssetContainer(scene, data, rootUrl, onError);\n    return container;\n  }\n});","map":{"version":3,"mappings":"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","names":["Logger","Camera","Vector3","Color3","Color4","Mesh","Geometry","TransformNode","Material","MultiMaterial","CubeTexture","HDRCubeTexture","AnimationGroup","Light","SceneComponentConstants","SceneLoader","AbstractScene","AssetContainer","ActionManager","Skeleton","MorphTargetManager","CannonJSPlugin","OimoJSPlugin","AmmoJSPlugin","ReflectionProbe","GetClass","Tools","PostProcess","_BabylonLoaderRegistered","BabylonFileLoaderConfiguration","undefined","tempIndexContainer","tempMaterialIndexContainer","parseMaterialByPredicate","predicate","parsedData","scene","rootUrl","materials","index","cache","length","parsedMaterial","material","Parse","isDescendantOf","mesh","names","hierarchyIds","i","name","push","id","parentId","indexOf","logOperation","operation","producer","file","version","exporter_version","loadDetailLevels","mastermesh","_waitingData","lods","ids","lodmeshes","wasenabled","isEnabled","distances","culling","setEnabled","lodid","lodmesh","getMeshById","addLODLevel","Warn","findParent","parentInstanceIndex","parentEntry","getLastEntryById","instance","instances","parseInt","parent","findMaterial","materialId","getLastMaterialById","loadAssetContainer","data","onError","addToScene","container","log","JSON","parse","fullDetails","loggingLevel","DETAILED_LOGGING","environmentTexture","isPBR","environmentTextureType","hdrSize","environmentTextureSize","hdrTexture","match","environmentTexturePrefilterOnLoad","environmentTextureRotationY","rotationY","endsWith","compressedTexture","environmentTextureForcedExtension","cubeTexture","CreateFromPrefilteredData","createDefaultSkybox","skyboxScale","activeCamera","maxZ","minZ","skyboxBlurLevel","environmentIntensity","lights","parsedLight","light","uniqueId","_parentContainer","toString","reflectionProbes","parsedReflectionProbe","reflectionProbe","animations","parsedAnimation","internalClass","animation","mat","textures","getActiveTextures","forEach","t","multiMaterials","parsedMultiMaterial","mmat","ParseMultiMaterial","morphTargetManagers","managerData","manager","skeletons","parsedSkeleton","skeleton","geometries","addedGeometry","Array","vertexData","parsedVertexData","g","transformNodes","parsedTransformNode","node","meshes","parsedMesh","hasInstances","cameras","parsedCamera","camera","postProcesses","parsedPostProcess","postProcess","animationGroups","parsedAnimationGroup","animationGroup","_waitingParentId","_waitingParentInstanceIndex","transformNode","multimat","_waitingSubMaterialsUniqueIds","subMaterial","subMaterials","_waitingMaterialId","_hasWaitingData","bones","bone","_waitingTransformNodeId","linkTransformNode","currentMesh","freezeWorldMatrix","computeWorldMatrix","_excludedMeshesIds","excludedIndex","excludedMesh","excludedMeshes","_includedOnlyMeshesIds","includedOnlyIndex","includedOnlyMesh","includedOnlyMeshes","_loadedUniqueId","actions","err","msg","Log","removeAllFromScene","NO_LOGGING","MINIMAL_LOGGING","RegisterPlugin","extensions","canDirectLoad","importMesh","meshesNames","particleSystems","isArray","parsedIdToNodeMap","Map","loadedTransformNodes","parsedJSONTransformNode","set","_waitingParsedUniqueId","loadedSkeletonsIds","loadedMaterialsIds","loadedMaterialsUniqueIds","loadedMorphTargetsIds","geometryId","found","geometryType","parsedGeometryData","materialUniqueId","materialArray","materialFound","loadSubMaterial","subMatId","multimatIndex","multimatCache","materialsUniqueIds","skeletonId","skeletonAlreadyLoaded","skeletonIndex","skeletonCache","morphTargetManagerId","morphTargetAlreadyLoaded","morphTargetIndex","morphTargetCache","parsedMorphTarget","morphTarget","get","parentNode","getClassName","loadedTransformNodeIndex","splice","dispose","parser","GetIndividualParser","NAME_PARTICLESYSTEM","parsedParticleSystem","emitterId","load","useDelayedTextureLoading","ForceFullSceneLoadingForIncremental","autoClear","clearColor","FromArray","ambientColor","gravity","useRightHandedSystem","fogMode","fogColor","fogStart","fogEnd","fogDensity","physicsEnabled","physicsPlugin","physicsEngine","LoaderInjectedPhysicsEngine","physicsGravity","enablePhysics","metadata","collisionsEnabled","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","activeCameraID","setActiveCameraById"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Loading/Plugins/babylonFileLoader.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Geometry } from \"../../Meshes/geometry\";\r\nimport type { Node } from \"../../node\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { MultiMaterial } from \"../../Materials/multiMaterial\";\r\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture\";\r\nimport { AnimationGroup } from \"../../Animations/animationGroup\";\r\nimport { Light } from \"../../Lights/light\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\nimport { AssetContainer } from \"../../assetContainer\";\r\nimport { ActionManager } from \"../../Actions/actionManager\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { Skeleton } from \"../../Bones/skeleton\";\r\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager\";\r\nimport { CannonJSPlugin } from \"../../Physics/v1/Plugins/cannonJSPlugin\";\r\nimport { OimoJSPlugin } from \"../../Physics/v1/Plugins/oimoJSPlugin\";\r\nimport { AmmoJSPlugin } from \"../../Physics/v1/Plugins/ammoJSPlugin\";\r\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention, no-var\r\nexport var _BabylonLoaderRegistered = true;\r\n\r\n/**\r\n * Helps setting up some configuration for the babylon file loader.\r\n */\r\nexport class BabylonFileLoaderConfiguration {\r\n    /**\r\n     * The loader does not allow injecting custom physics engine into the plugins.\r\n     * Unfortunately in ES6, we need to manually inject them into the plugin.\r\n     * So you could set this variable to your engine import to make it work.\r\n     */\r\n    public static LoaderInjectedPhysicsEngine: any = undefined;\r\n}\r\n\r\nlet tempIndexContainer: { [key: string]: Node } = {};\r\nlet tempMaterialIndexContainer: { [key: string]: Material } = {};\r\n\r\nconst parseMaterialByPredicate = (predicate: (parsedMaterial: any) => boolean, parsedData: any, scene: Scene, rootUrl: string) => {\r\n    if (!parsedData.materials) {\r\n        return null;\r\n    }\r\n\r\n    for (let index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n        const parsedMaterial = parsedData.materials[index];\r\n        if (predicate(parsedMaterial)) {\r\n            return { parsedMaterial, material: Material.Parse(parsedMaterial, scene, rootUrl) };\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nconst isDescendantOf = (mesh: any, names: Array<any>, hierarchyIds: Array<number>) => {\r\n    for (const i in names) {\r\n        if (mesh.name === names[i]) {\r\n            hierarchyIds.push(mesh.id);\r\n            return true;\r\n        }\r\n    }\r\n    if (mesh.parentId !== undefined && hierarchyIds.indexOf(mesh.parentId) !== -1) {\r\n        hierarchyIds.push(mesh.id);\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst logOperation = (operation: string, producer: { file: string; name: string; version: string; exporter_version: string }) => {\r\n    return (\r\n        operation +\r\n        \" of \" +\r\n        (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\")\r\n    );\r\n};\r\n\r\nconst loadDetailLevels = (scene: Scene, mesh: AbstractMesh) => {\r\n    const mastermesh: Mesh = mesh as Mesh;\r\n\r\n    // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\r\n    // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\r\n    if (mesh._waitingData.lods) {\r\n        if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\r\n            const lodmeshes: string[] = mesh._waitingData.lods.ids;\r\n            const wasenabled: boolean = mastermesh.isEnabled(false);\r\n            if (mesh._waitingData.lods.distances) {\r\n                const distances: number[] = mesh._waitingData.lods.distances;\r\n                if (distances.length >= lodmeshes.length) {\r\n                    const culling: number = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\r\n                    mastermesh.setEnabled(false);\r\n                    for (let index = 0; index < lodmeshes.length; index++) {\r\n                        const lodid: string = lodmeshes[index];\r\n                        const lodmesh: Mesh = scene.getMeshById(lodid) as Mesh;\r\n                        if (lodmesh != null) {\r\n                            mastermesh.addLODLevel(distances[index], lodmesh);\r\n                        }\r\n                    }\r\n                    if (culling > 0) {\r\n                        mastermesh.addLODLevel(culling, null);\r\n                    }\r\n                    if (wasenabled === true) {\r\n                        mastermesh.setEnabled(true);\r\n                    }\r\n                } else {\r\n                    Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n        mesh._waitingData.lods = null;\r\n    }\r\n};\r\n\r\nconst findParent = (parentId: any, parentInstanceIndex: any, scene: Scene) => {\r\n    if (typeof parentId !== \"number\") {\r\n        const parentEntry = scene.getLastEntryById(parentId);\r\n        if (parentEntry && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\r\n            const instance = (parentEntry as Mesh).instances[parseInt(parentInstanceIndex)];\r\n            return instance;\r\n        }\r\n        return parentEntry;\r\n    }\r\n\r\n    const parent = tempIndexContainer[parentId];\r\n    if (parent && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\r\n        const instance = (parent as Mesh).instances[parseInt(parentInstanceIndex)];\r\n        return instance;\r\n    }\r\n\r\n    return parent;\r\n};\r\n\r\nconst findMaterial = (materialId: any, scene: Scene) => {\r\n    if (typeof materialId !== \"number\") {\r\n        return scene.getLastMaterialById(materialId, true);\r\n    }\r\n\r\n    return tempMaterialIndexContainer[materialId];\r\n};\r\n\r\nconst loadAssetContainer = (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void, addToScene = false): AssetContainer => {\r\n    const container = new AssetContainer(scene);\r\n\r\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n    // and avoid problems with multiple concurrent .babylon loads.\r\n    let log = \"importScene has failed JSON parse\";\r\n    try {\r\n        // eslint-disable-next-line no-var\r\n        var parsedData = JSON.parse(data);\r\n        log = \"\";\r\n        const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n\r\n        let index: number;\r\n        let cache: number;\r\n\r\n        // Environment texture\r\n        if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\r\n            // PBR needed for both HDR texture (gamma space) & a sky box\r\n            const isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\r\n            if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\r\n                const hdrSize: number = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\r\n                const hdrTexture = new HDRCubeTexture(\r\n                    (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                    scene,\r\n                    hdrSize,\r\n                    true,\r\n                    !isPBR,\r\n                    undefined,\r\n                    parsedData.environmentTexturePrefilterOnLoad\r\n                );\r\n                if (parsedData.environmentTextureRotationY) {\r\n                    hdrTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                }\r\n                scene.environmentTexture = hdrTexture;\r\n            } else {\r\n                if (typeof parsedData.environmentTexture === \"object\") {\r\n                    const environmentTexture = CubeTexture.Parse(parsedData.environmentTexture, scene, rootUrl);\r\n                    scene.environmentTexture = environmentTexture;\r\n                } else if ((parsedData.environmentTexture as string).endsWith(\".env\")) {\r\n                    const compressedTexture = new CubeTexture(\r\n                        (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                        scene,\r\n                        parsedData.environmentTextureForcedExtension\r\n                    );\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        compressedTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = compressedTexture;\r\n                } else {\r\n                    const cubeTexture = CubeTexture.CreateFromPrefilteredData(\r\n                        (parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture,\r\n                        scene,\r\n                        parsedData.environmentTextureForcedExtension\r\n                    );\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        cubeTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = cubeTexture;\r\n                }\r\n            }\r\n            if (parsedData.createDefaultSkybox === true) {\r\n                const skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\r\n                const skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\r\n                scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\r\n            }\r\n            container.environmentTexture = scene.environmentTexture;\r\n        }\r\n\r\n        // Environment Intensity\r\n        if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\r\n            scene.environmentIntensity = parsedData.environmentIntensity;\r\n        }\r\n\r\n        // Lights\r\n        if (parsedData.lights !== undefined && parsedData.lights !== null) {\r\n            for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\r\n                const parsedLight = parsedData.lights[index];\r\n                const light = Light.Parse(parsedLight, scene);\r\n                if (light) {\r\n                    tempIndexContainer[parsedLight.uniqueId] = light;\r\n                    container.lights.push(light);\r\n                    light._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tLights:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + light.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\r\n            for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\r\n                const parsedReflectionProbe = parsedData.reflectionProbes[index];\r\n                const reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\r\n                if (reflectionProbe) {\r\n                    container.reflectionProbes.push(reflectionProbe);\r\n                    reflectionProbe._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (parsedData.animations !== undefined && parsedData.animations !== null) {\r\n            for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\r\n                const parsedAnimation = parsedData.animations[index];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    const animation = internalClass.Parse(parsedAnimation);\r\n                    scene.animations.push(animation);\r\n                    container.animations.push(animation);\r\n                    log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + animation.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        if (parsedData.materials !== undefined && parsedData.materials !== null) {\r\n            for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n                const parsedMaterial = parsedData.materials[index];\r\n                const mat = Material.Parse(parsedMaterial, scene, rootUrl);\r\n                if (mat) {\r\n                    tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;\r\n                    container.materials.push(mat);\r\n                    mat._parentContainer = container;\r\n                    log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + mat.toString(fullDetails);\r\n\r\n                    // Textures\r\n                    const textures = mat.getActiveTextures();\r\n                    textures.forEach((t) => {\r\n                        if (container.textures.indexOf(t) == -1) {\r\n                            container.textures.push(t);\r\n                            t._parentContainer = container;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n            for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\r\n                const parsedMultiMaterial = parsedData.multiMaterials[index];\r\n                const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\r\n                container.multiMaterials.push(mmat);\r\n                mmat._parentContainer = container;\r\n\r\n                log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\r\n                log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\r\n\r\n                // Textures\r\n                const textures = mmat.getActiveTextures();\r\n                textures.forEach((t) => {\r\n                    if (container.textures.indexOf(t) == -1) {\r\n                        container.textures.push(t);\r\n                        t._parentContainer = container;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Morph targets\r\n        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n            for (const managerData of parsedData.morphTargetManagers) {\r\n                const manager = MorphTargetManager.Parse(managerData, scene);\r\n                container.morphTargetManagers.push(manager);\r\n                manager._parentContainer = container;\r\n            }\r\n        }\r\n\r\n        // Skeletons\r\n        if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n            for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\r\n                const parsedSkeleton = parsedData.skeletons[index];\r\n                const skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                container.skeletons.push(skeleton);\r\n                skeleton._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\r\n                log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        const geometries = parsedData.geometries;\r\n        if (geometries !== undefined && geometries !== null) {\r\n            const addedGeometry = new Array<Nullable<Geometry>>();\r\n\r\n            // VertexData\r\n            const vertexData = geometries.vertexData;\r\n            if (vertexData !== undefined && vertexData !== null) {\r\n                for (index = 0, cache = vertexData.length; index < cache; index++) {\r\n                    const parsedVertexData = vertexData[index];\r\n                    addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\r\n                }\r\n            }\r\n\r\n            addedGeometry.forEach((g) => {\r\n                if (g) {\r\n                    container.geometries.push(g);\r\n                    g._parentContainer = container;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Transform nodes\r\n        if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\r\n            for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\r\n                const parsedTransformNode = parsedData.transformNodes[index];\r\n                const node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\r\n                tempIndexContainer[parsedTransformNode.uniqueId] = node;\r\n                container.transformNodes.push(node);\r\n                node._parentContainer = container;\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n            for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                const parsedMesh = parsedData.meshes[index];\r\n                const mesh = <AbstractMesh>Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                tempIndexContainer[parsedMesh.uniqueId] = mesh;\r\n                container.meshes.push(mesh);\r\n                mesh._parentContainer = container;\r\n                if (mesh.hasInstances) {\r\n                    for (const instance of (mesh as Mesh).instances) {\r\n                        container.meshes.push(instance);\r\n                        instance._parentContainer = container;\r\n                    }\r\n                }\r\n                log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\r\n                log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\r\n            for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\r\n                const parsedCamera = parsedData.cameras[index];\r\n                const camera = Camera.Parse(parsedCamera, scene);\r\n                tempIndexContainer[parsedCamera.uniqueId] = camera;\r\n                container.cameras.push(camera);\r\n                camera._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tCameras:\" : \"\";\r\n                log += \"\\n\\t\\t\" + camera.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Postprocesses\r\n        if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\r\n            for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\r\n                const parsedPostProcess = parsedData.postProcesses[index];\r\n                const postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\r\n                if (postProcess) {\r\n                    container.postProcesses.push(postProcess);\r\n                    postProcess._parentContainer = container;\r\n                    log += index === 0 ? \"\\nPostprocesses:\" : \"\";\r\n                    log += \"\\n\\t\\t\" + postProcess.toString();\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animation Groups\r\n        if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\r\n            for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\r\n                const parsedAnimationGroup = parsedData.animationGroups[index];\r\n                const animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\r\n                container.animationGroups.push(animationGroup);\r\n                animationGroup._parentContainer = container;\r\n                log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\r\n                log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Browsing all the graph to connect the dots\r\n        for (index = 0, cache = scene.cameras.length; index < cache; index++) {\r\n            const camera = scene.cameras[index];\r\n            if (camera._waitingParentId !== null) {\r\n                camera.parent = findParent(camera._waitingParentId, camera._waitingParentInstanceIndex, scene);\r\n                camera._waitingParentId = null;\r\n                camera._waitingParentInstanceIndex = null;\r\n            }\r\n        }\r\n\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            const light = scene.lights[index];\r\n            if (light && light._waitingParentId !== null) {\r\n                light.parent = findParent(light._waitingParentId, light._waitingParentInstanceIndex, scene);\r\n                light._waitingParentId = null;\r\n                light._waitingParentInstanceIndex = null;\r\n            }\r\n        }\r\n\r\n        // Connect parents & children and parse actions and lods\r\n        for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\r\n            const transformNode = scene.transformNodes[index];\r\n            if (transformNode._waitingParentId !== null) {\r\n                transformNode.parent = findParent(transformNode._waitingParentId, transformNode._waitingParentInstanceIndex, scene);\r\n                transformNode._waitingParentId = null;\r\n                transformNode._waitingParentInstanceIndex = null;\r\n            }\r\n        }\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const mesh = scene.meshes[index];\r\n            if (mesh._waitingParentId !== null) {\r\n                mesh.parent = findParent(mesh._waitingParentId, mesh._waitingParentInstanceIndex, scene);\r\n                mesh._waitingParentId = null;\r\n                mesh._waitingParentInstanceIndex = null;\r\n            }\r\n            if (mesh._waitingData.lods) {\r\n                loadDetailLevels(scene, mesh);\r\n            }\r\n        }\r\n\r\n        // link multimats with materials\r\n        scene.multiMaterials.forEach((multimat) => {\r\n            multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\r\n                multimat.subMaterials.push(findMaterial(subMaterial, scene));\r\n            });\r\n            multimat._waitingSubMaterialsUniqueIds = [];\r\n        });\r\n\r\n        // link meshes with materials\r\n        scene.meshes.forEach((mesh) => {\r\n            if (mesh._waitingMaterialId !== null) {\r\n                mesh.material = findMaterial(mesh._waitingMaterialId, scene);\r\n                mesh._waitingMaterialId = null;\r\n            }\r\n        });\r\n\r\n        // link skeleton transform nodes\r\n        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (skeleton._hasWaitingData) {\r\n                if (skeleton.bones != null) {\r\n                    skeleton.bones.forEach((bone) => {\r\n                        if (bone._waitingTransformNodeId) {\r\n                            const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId) as TransformNode;\r\n                            if (linkTransformNode) {\r\n                                bone.linkTransformNode(linkTransformNode);\r\n                            }\r\n                            bone._waitingTransformNodeId = null;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                skeleton._hasWaitingData = null;\r\n            }\r\n        }\r\n\r\n        // freeze world matrix application\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const currentMesh = scene.meshes[index];\r\n            if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                currentMesh.freezeWorldMatrix();\r\n                currentMesh._waitingData.freezeWorldMatrix = null;\r\n            } else {\r\n                currentMesh.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        // Lights exclusions / inclusions\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            const light = scene.lights[index];\r\n            // Excluded check\r\n            if (light._excludedMeshesIds.length > 0) {\r\n                for (let excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\r\n                    const excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);\r\n\r\n                    if (excludedMesh) {\r\n                        light.excludedMeshes.push(excludedMesh);\r\n                    }\r\n                }\r\n\r\n                light._excludedMeshesIds = [];\r\n            }\r\n\r\n            // Included check\r\n            if (light._includedOnlyMeshesIds.length > 0) {\r\n                for (let includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\r\n                    const includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);\r\n\r\n                    if (includedOnlyMesh) {\r\n                        light.includedOnlyMeshes.push(includedOnlyMesh);\r\n                    }\r\n                }\r\n\r\n                light._includedOnlyMeshesIds = [];\r\n            }\r\n        }\r\n\r\n        scene.geometries.forEach((g) => {\r\n            g._loadedUniqueId = \"\";\r\n        });\r\n\r\n        AbstractScene.Parse(parsedData, scene, container, rootUrl);\r\n\r\n        // Actions (scene) Done last as it can access other objects.\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            const mesh = scene.meshes[index];\r\n            if (mesh._waitingData.actions) {\r\n                ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\r\n                mesh._waitingData.actions = null;\r\n            }\r\n        }\r\n        if (parsedData.actions !== undefined && parsedData.actions !== null) {\r\n            ActionManager.Parse(parsedData.actions, null, scene);\r\n        }\r\n    } catch (err) {\r\n        const msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n        if (onError) {\r\n            onError(msg, err);\r\n        } else {\r\n            Logger.Log(msg);\r\n            throw err;\r\n        }\r\n    } finally {\r\n        tempIndexContainer = {};\r\n        tempMaterialIndexContainer = {};\r\n\r\n        if (!addToScene) {\r\n            container.removeAllFromScene();\r\n        }\r\n        if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n            Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n        }\r\n    }\r\n\r\n    return container;\r\n};\r\n\r\nSceneLoader.RegisterPlugin({\r\n    name: \"babylon.js\",\r\n    extensions: \".babylon\",\r\n    canDirectLoad: (data: string) => {\r\n        if (data.indexOf(\"babylon\") !== -1) {\r\n            // We consider that the producer string is filled\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n    importMesh: (\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        let log = \"importMesh has failed JSON parse\";\r\n        try {\r\n            // eslint-disable-next-line no-var\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n            const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n            if (!meshesNames) {\r\n                meshesNames = null;\r\n            } else if (!Array.isArray(meshesNames)) {\r\n                meshesNames = [meshesNames];\r\n            }\r\n\r\n            const hierarchyIds = new Array<number>();\r\n            const parsedIdToNodeMap = new Map<number, Node>();\r\n\r\n            // Transform nodes (the overall idea is to load all of them as this is super fast and then get rid of the ones we don't need)\r\n            const loadedTransformNodes = [];\r\n            if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\r\n                for (let index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\r\n                    const parsedJSONTransformNode = parsedData.transformNodes[index];\r\n                    const parsedTransformNode = TransformNode.Parse(parsedJSONTransformNode, scene, rootUrl);\r\n                    loadedTransformNodes.push(parsedTransformNode);\r\n                    parsedIdToNodeMap.set(parsedTransformNode._waitingParsedUniqueId!, parsedTransformNode);\r\n                    parsedTransformNode._waitingParsedUniqueId = null;\r\n                }\r\n            }\r\n            if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n                const loadedSkeletonsIds = [];\r\n                const loadedMaterialsIds: string[] = [];\r\n                const loadedMaterialsUniqueIds: string[] = [];\r\n                const loadedMorphTargetsIds = [];\r\n                for (let index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                    const parsedMesh = parsedData.meshes[index];\r\n\r\n                    if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\r\n                        if (meshesNames !== null) {\r\n                            // Remove found mesh name from list.\r\n                            delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\r\n                        }\r\n\r\n                        //Geometry?\r\n                        if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\r\n                            //does the file contain geometries?\r\n                            if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\r\n                                //find the correct geometry and add it to the scene\r\n                                let found: boolean = false;\r\n                                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach((geometryType: string) => {\r\n                                    if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\r\n                                        return;\r\n                                    } else {\r\n                                        parsedData.geometries[geometryType].forEach((parsedGeometryData: any) => {\r\n                                            if (parsedGeometryData.id === parsedMesh.geometryId) {\r\n                                                switch (geometryType) {\r\n                                                    case \"vertexData\":\r\n                                                        Geometry.Parse(parsedGeometryData, scene, rootUrl);\r\n                                                        break;\r\n                                                }\r\n                                                found = true;\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                });\r\n                                if (found === false) {\r\n                                    Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Material ?\r\n                        if (parsedMesh.materialUniqueId || parsedMesh.materialId) {\r\n                            // if we have a unique ID, look up and store in loadedMaterialsUniqueIds, else use loadedMaterialsIds\r\n                            const materialArray = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;\r\n                            let materialFound = materialArray.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;\r\n                            if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n                                // Loads a submaterial of a multimaterial\r\n                                const loadSubMaterial = (subMatId: string, predicate: (parsedMaterial: any) => boolean) => {\r\n                                    materialArray.push(subMatId);\r\n                                    const mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);\r\n                                    if (mat && mat.material) {\r\n                                        tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\r\n                                        log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\r\n                                    }\r\n                                };\r\n                                for (let multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\r\n                                    const parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\r\n                                    if (\r\n                                        (parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId) ||\r\n                                        parsedMultiMaterial.id === parsedMesh.materialId\r\n                                    ) {\r\n                                        if (parsedMultiMaterial.materialsUniqueIds) {\r\n                                            // if the materials inside the multimat are stored by unique id\r\n                                            parsedMultiMaterial.materialsUniqueIds.forEach((subMatId: string) =>\r\n                                                loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.uniqueId === subMatId)\r\n                                            );\r\n                                        } else {\r\n                                            // if the mats are stored by id instead\r\n                                            parsedMultiMaterial.materials.forEach((subMatId: string) =>\r\n                                                loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.id === subMatId)\r\n                                            );\r\n                                        }\r\n                                        materialArray.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);\r\n                                        const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                                        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\r\n                                        if (mmat) {\r\n                                            materialFound = true;\r\n                                            log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (materialFound === false) {\r\n                                materialArray.push(parsedMesh.materialUniqueId || parsedMesh.materialId);\r\n                                const mat = parseMaterialByPredicate(\r\n                                    (parsedMaterial) =>\r\n                                        (parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId) || parsedMaterial.id === parsedMesh.materialId,\r\n                                    parsedData,\r\n                                    scene,\r\n                                    rootUrl\r\n                                );\r\n                                if (!mat || !mat.material) {\r\n                                    Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\r\n                                } else {\r\n                                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\r\n                                    log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Skeleton ?\r\n                        if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n                            const skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\r\n                            if (!skeletonAlreadyLoaded) {\r\n                                for (let skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\r\n                                    const parsedSkeleton = parsedData.skeletons[skeletonIndex];\r\n                                    if (parsedSkeleton.id === parsedMesh.skeletonId) {\r\n                                        const skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                                        skeletons.push(skeleton);\r\n                                        loadedSkeletonsIds.push(parsedSkeleton.id);\r\n                                        log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Morph targets ?\r\n                        if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n                            const morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;\r\n                            if (!morphTargetAlreadyLoaded) {\r\n                                for (let morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {\r\n                                    const parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];\r\n                                    if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {\r\n                                        const morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);\r\n                                        loadedMorphTargetsIds.push(morphTarget.uniqueId);\r\n                                        log += \"\\nMorph target \" + morphTarget.toString();\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                        meshes.push(mesh);\r\n                        parsedIdToNodeMap.set(mesh._waitingParsedUniqueId!, mesh);\r\n                        mesh._waitingParsedUniqueId = null;\r\n                        log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\r\n                    }\r\n                }\r\n\r\n                // link multimats with materials\r\n                scene.multiMaterials.forEach((multimat) => {\r\n                    multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\r\n                        multimat.subMaterials.push(findMaterial(subMaterial, scene));\r\n                    });\r\n                    multimat._waitingSubMaterialsUniqueIds = [];\r\n                });\r\n\r\n                // link meshes with materials\r\n                scene.meshes.forEach((mesh) => {\r\n                    if (mesh._waitingMaterialId !== null) {\r\n                        mesh.material = findMaterial(mesh._waitingMaterialId, scene);\r\n                        mesh._waitingMaterialId = null;\r\n                    }\r\n                });\r\n\r\n                // Connecting parents and lods\r\n                for (let index = 0, cache = scene.transformNodes.length; index < cache; index++) {\r\n                    const transformNode = scene.transformNodes[index];\r\n                    if (transformNode._waitingParentId !== null) {\r\n                        let parent = parsedIdToNodeMap.get(parseInt(transformNode._waitingParentId)) || null;\r\n                        if (parent === null) {\r\n                            parent = scene.getLastEntryById(transformNode._waitingParentId);\r\n                        }\r\n                        let parentNode = parent;\r\n                        if (transformNode._waitingParentInstanceIndex) {\r\n                            parentNode = (parent as Mesh).instances[parseInt(transformNode._waitingParentInstanceIndex)];\r\n                            transformNode._waitingParentInstanceIndex = null;\r\n                        }\r\n                        transformNode.parent = parentNode;\r\n                        transformNode._waitingParentId = null;\r\n                    }\r\n                }\r\n                let currentMesh: AbstractMesh;\r\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingParentId) {\r\n                        let parent = parsedIdToNodeMap.get(parseInt(currentMesh._waitingParentId)) || null;\r\n                        if (parent === null) {\r\n                            parent = scene.getLastEntryById(currentMesh._waitingParentId);\r\n                        }\r\n                        let parentNode = parent;\r\n                        if (currentMesh._waitingParentInstanceIndex) {\r\n                            parentNode = (parent as Mesh).instances[parseInt(currentMesh._waitingParentInstanceIndex)];\r\n                            currentMesh._waitingParentInstanceIndex = null;\r\n                        }\r\n                        currentMesh.parent = parentNode;\r\n                        if (currentMesh.parent?.getClassName() === \"TransformNode\") {\r\n                            const loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent as TransformNode);\r\n                            if (loadedTransformNodeIndex > -1) {\r\n                                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);\r\n                            }\r\n                        }\r\n                        currentMesh._waitingParentId = null;\r\n                    }\r\n                    if (currentMesh._waitingData.lods) {\r\n                        loadDetailLevels(scene, currentMesh);\r\n                    }\r\n                }\r\n\r\n                // Remove unused transform nodes\r\n                for (const transformNode of loadedTransformNodes) {\r\n                    transformNode.dispose();\r\n                }\r\n\r\n                // link skeleton transform nodes\r\n                for (let index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n                    const skeleton = scene.skeletons[index];\r\n                    if (skeleton._hasWaitingData) {\r\n                        if (skeleton.bones != null) {\r\n                            skeleton.bones.forEach((bone) => {\r\n                                if (bone._waitingTransformNodeId) {\r\n                                    const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId) as TransformNode;\r\n                                    if (linkTransformNode) {\r\n                                        bone.linkTransformNode(linkTransformNode);\r\n                                    }\r\n                                    bone._waitingTransformNodeId = null;\r\n                                }\r\n                            });\r\n                        }\r\n\r\n                        skeleton._hasWaitingData = null;\r\n                    }\r\n                }\r\n\r\n                // freeze and compute world matrix application\r\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                        currentMesh.freezeWorldMatrix();\r\n                        currentMesh._waitingData.freezeWorldMatrix = null;\r\n                    } else {\r\n                        currentMesh.computeWorldMatrix(true);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Particles\r\n            if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n                const parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n                if (parser) {\r\n                    for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n                        const parsedParticleSystem = parsedData.particleSystems[index];\r\n                        if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\r\n                            particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        } catch (err) {\r\n            const msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    load: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        let log = \"importScene has failed JSON parse\";\r\n        try {\r\n            // eslint-disable-next-line no-var\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n\r\n            // Scene\r\n            if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\r\n                scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\r\n            }\r\n            if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\r\n                scene.autoClear = parsedData.autoClear;\r\n            }\r\n            if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\r\n                scene.clearColor = Color4.FromArray(parsedData.clearColor);\r\n            }\r\n            if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\r\n                scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\r\n            }\r\n            if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\r\n                scene.gravity = Vector3.FromArray(parsedData.gravity);\r\n            }\r\n\r\n            if (parsedData.useRightHandedSystem !== undefined) {\r\n                scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;\r\n            }\r\n\r\n            // Fog\r\n            if (parsedData.fogMode && parsedData.fogMode !== 0) {\r\n                scene.fogMode = parsedData.fogMode;\r\n                scene.fogColor = Color3.FromArray(parsedData.fogColor);\r\n                scene.fogStart = parsedData.fogStart;\r\n                scene.fogEnd = parsedData.fogEnd;\r\n                scene.fogDensity = parsedData.fogDensity;\r\n                log += \"\\tFog mode for scene:  \";\r\n                switch (scene.fogMode) {\r\n                    // getters not compiling, so using hardcoded\r\n                    case 1:\r\n                        log += \"exp\\n\";\r\n                        break;\r\n                    case 2:\r\n                        log += \"exp2\\n\";\r\n                        break;\r\n                    case 3:\r\n                        log += \"linear\\n\";\r\n                        break;\r\n                }\r\n            }\r\n\r\n            //Physics\r\n            if (parsedData.physicsEnabled) {\r\n                let physicsPlugin;\r\n                if (parsedData.physicsEngine === \"cannon\" || parsedData.physicsEngine === CannonJSPlugin.name) {\r\n                    physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"oimo\" || parsedData.physicsEngine === OimoJSPlugin.name) {\r\n                    physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"ammo\" || parsedData.physicsEngine === AmmoJSPlugin.name) {\r\n                    physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\r\n                }\r\n                log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\r\n                //else - default engine, which is currently oimo\r\n                const physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\r\n                scene.enablePhysics(physicsGravity, physicsPlugin);\r\n            }\r\n\r\n            // Metadata\r\n            if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\r\n                scene.metadata = parsedData.metadata;\r\n            }\r\n\r\n            //collisions, if defined. otherwise, default is true\r\n            if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\r\n                scene.collisionsEnabled = parsedData.collisionsEnabled;\r\n            }\r\n\r\n            const container = loadAssetContainer(scene, data, rootUrl, onError, true);\r\n            if (!container) {\r\n                return false;\r\n            }\r\n\r\n            if (parsedData.autoAnimate) {\r\n                scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\r\n            }\r\n\r\n            if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\r\n                scene.setActiveCameraById(parsedData.activeCameraID);\r\n            }\r\n\r\n            // Finish\r\n            return true;\r\n        } catch (err) {\r\n            const msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    loadAssetContainer: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer => {\r\n        const container = loadAssetContainer(scene, data, rootUrl, onError);\r\n        return container;\r\n    },\r\n});\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}