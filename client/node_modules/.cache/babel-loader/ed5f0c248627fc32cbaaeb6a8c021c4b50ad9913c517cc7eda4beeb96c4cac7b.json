{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * This is a movement feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\n  /**\n   * constructs a new movement controller system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options configuration object for this feature\n   */\n  constructor(_xrSessionManager, options) {\n    var _a, _b, _c, _d, _e, _f;\n    super(_xrSessionManager);\n    this._controllers = {};\n    this._currentRegistrationConfigurations = [];\n    // forward direction for movement, which may differ from viewer pose.\n    this._movementDirection = null;\n    // unused\n    this._tmpRotationMatrix = Matrix.Identity();\n    this._tmpTranslationDirection = new Vector3();\n    this._tmpMovementTranslation = new Vector3();\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        registeredComponents: []\n      };\n      const controllerData = this._controllers[xrController.uniqueId];\n      // movement controller only available to gamepad-enabled input sources.\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        const initController = () => {\n          if (xrController.motionController) {\n            for (const registration of this._currentRegistrationConfigurations) {\n              let component = null;\n              if (registration.allowedComponentTypes) {\n                for (const componentType of registration.allowedComponentTypes) {\n                  const componentOfType = xrController.motionController.getComponentOfType(componentType);\n                  if (componentOfType !== null) {\n                    component = componentOfType;\n                    break;\n                  }\n                }\n              }\n              if (registration.mainComponentOnly) {\n                const mainComponent = xrController.motionController.getMainComponent();\n                if (mainComponent === null) {\n                  continue;\n                }\n                component = mainComponent;\n              }\n              if (typeof registration.componentSelectionPredicate === \"function\") {\n                // if does not match we do want to ignore a previously found component\n                component = registration.componentSelectionPredicate(xrController);\n              }\n              if (component && registration.forceHandedness) {\n                if (xrController.inputSource.handedness !== registration.forceHandedness) {\n                  continue; // do not register\n                }\n              }\n\n              if (component === null) {\n                continue; // do not register\n              }\n\n              const registeredComponent = {\n                registrationConfiguration: registration,\n                component\n              };\n              controllerData.registeredComponents.push(registeredComponent);\n              if (\"axisChangedHandler\" in registration) {\n                registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add(axesData => {\n                  registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\n                });\n              }\n              if (\"buttonChangedhandler\" in registration) {\n                registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\n                  if (component.changes.pressed) {\n                    registration.buttonChangedhandler(component.changes.pressed, this._movementState, this._featureContext, this._xrInput);\n                  }\n                });\n              }\n            }\n          }\n        };\n        if (xrController.motionController) {\n          initController();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(() => {\n            initController();\n          });\n        }\n      }\n    };\n    if (!options || options.xrInput === undefined) {\n      Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\n      return;\n    }\n    if (Array.isArray(options.customRegistrationConfigurations)) {\n      this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\n    } else {\n      this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\n    }\n    // synchronized from feature setter properties\n    this._featureContext = {\n      movementEnabled: options.movementEnabled || true,\n      movementOrientationFollowsViewerPose: (_a = options.movementOrientationFollowsViewerPose) !== null && _a !== void 0 ? _a : true,\n      movementSpeed: (_b = options.movementSpeed) !== null && _b !== void 0 ? _b : 1,\n      movementThreshold: (_c = options.movementThreshold) !== null && _c !== void 0 ? _c : 0.25,\n      rotationEnabled: (_d = options.rotationEnabled) !== null && _d !== void 0 ? _d : true,\n      rotationSpeed: (_e = options.rotationSpeed) !== null && _e !== void 0 ? _e : 1.0,\n      rotationThreshold: (_f = options.rotationThreshold) !== null && _f !== void 0 ? _f : 0.25\n    };\n    this._movementState = {\n      moveX: 0,\n      moveY: 0,\n      rotateX: 0,\n      rotateY: 0\n    };\n    this._xrInput = options.xrInput;\n  }\n  /**\n   * Current movement direction.  Will be null before XR Frames have been processed.\n   */\n  get movementDirection() {\n    return this._movementDirection;\n  }\n  /**\n   * Is movement enabled\n   */\n  get movementEnabled() {\n    return this._featureContext.movementEnabled;\n  }\n  /**\n   * Sets whether movement is enabled or not\n   * @param enabled is movement enabled\n   */\n  set movementEnabled(enabled) {\n    this._featureContext.movementEnabled = enabled;\n  }\n  /**\n   * If movement follows viewer pose\n   */\n  get movementOrientationFollowsViewerPose() {\n    return this._featureContext.movementOrientationFollowsViewerPose;\n  }\n  /**\n   * Sets whether movement follows viewer pose\n   * @param followsPose is movement should follow viewer pose\n   */\n  set movementOrientationFollowsViewerPose(followsPose) {\n    this._featureContext.movementOrientationFollowsViewerPose = followsPose;\n  }\n  /**\n   * Gets movement speed\n   */\n  get movementSpeed() {\n    return this._featureContext.movementSpeed;\n  }\n  /**\n   * Sets movement speed\n   * @param movementSpeed movement speed\n   */\n  set movementSpeed(movementSpeed) {\n    this._featureContext.movementSpeed = movementSpeed;\n  }\n  /**\n   * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n   */\n  get movementThreshold() {\n    return this._featureContext.movementThreshold;\n  }\n  /**\n   * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n   * @param movementThreshold new threshold\n   */\n  set movementThreshold(movementThreshold) {\n    this._featureContext.movementThreshold = movementThreshold;\n  }\n  /**\n   * Is rotation enabled\n   */\n  get rotationEnabled() {\n    return this._featureContext.rotationEnabled;\n  }\n  /**\n   * Sets whether rotation is enabled or not\n   * @param enabled is rotation enabled\n   */\n  set rotationEnabled(enabled) {\n    this._featureContext.rotationEnabled = enabled;\n  }\n  /**\n   * Gets rotation speed factor\n   */\n  get rotationSpeed() {\n    return this._featureContext.rotationSpeed;\n  }\n  /**\n   * Sets rotation speed factor (1.0 is default)\n   * @param rotationSpeed new rotation speed factor\n   */\n  set rotationSpeed(rotationSpeed) {\n    this._featureContext.rotationSpeed = rotationSpeed;\n  }\n  /**\n   * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n   */\n  get rotationThreshold() {\n    return this._featureContext.rotationThreshold;\n  }\n  /**\n   * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n   * @param threshold new threshold\n   */\n  set rotationThreshold(threshold) {\n    this._featureContext.rotationThreshold = threshold;\n  }\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    this._controllers = {};\n    return true;\n  }\n  /**\n   * Occurs on every XR frame.\n   * @param _xrFrame\n   */\n  _onXRFrame(_xrFrame) {\n    if (!this.attach) {\n      return;\n    }\n    if (this._movementDirection === null) {\n      this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.clone();\n    }\n    if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\n      // smooth rotation\n      const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\n      const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n      if (this._featureContext.movementOrientationFollowsViewerPose === true) {\n        this._xrInput.xrCamera.cameraRotation.y += rotationY;\n        this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.multiply(Quaternion.RotationYawPitchRoll(rotationY, 0, 0));\n      } else {\n        // movement orientation direction does not affect camera.  We use rotation speed multiplier\n        // otherwise need to implement inertia and constraints for same feel as TargetCamera.\n        this._movementDirection.multiplyInPlace(Quaternion.RotationYawPitchRoll(rotationY * 3.0, 0, 0));\n      }\n    } else if (this._featureContext.movementOrientationFollowsViewerPose === true) {\n      this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\n    }\n    if ((this._movementState.moveX !== 0 || this._movementState.moveY !== 0) && this._featureContext.movementEnabled) {\n      Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\n      this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n      // move according to forward direction based on camera speed\n      Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\n      this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\n      this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\n    }\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    for (const registeredComponent of controllerData.registeredComponents) {\n      if (registeredComponent.onAxisChangedObserver) {\n        registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\n      }\n      if (registeredComponent.onButtonChangedObserver) {\n        registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\n      }\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n}\n/**\n * The module's name\n */\nWebXRControllerMovement.Name = WebXRFeatureName.MOVEMENT;\n/**\n * Standard controller configurations.\n */\nWebXRControllerMovement.REGISTRATIONS = {\n  default: [{\n    allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n    forceHandedness: \"left\",\n    axisChangedHandler: (axes, movementState, featureContext) => {\n      movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\n      movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\n    }\n  }, {\n    allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n    forceHandedness: \"right\",\n    axisChangedHandler: (axes, movementState, featureContext) => {\n      movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\n      movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\n    }\n  }]\n};\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerMovement.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerMovement.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerMovement(xrSessionManager, options);\n}, WebXRControllerMovement.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","WebXRControllerComponent","Matrix","Quaternion","Vector3","WebXRAbstractFeature","Tools","WebXRControllerMovement","constructor","_xrSessionManager","options","Identity","xrController","_controllers","uniqueId","registeredComponents","controllerData","inputSource","targetRayMode","gamepad","initController","motionController","registration","_currentRegistrationConfigurations","component","allowedComponentTypes","componentType","componentOfType","getComponentOfType","mainComponentOnly","mainComponent","getMainComponent","componentSelectionPredicate","forceHandedness","handedness","registeredComponent","registrationConfiguration","push","onAxisChangedObserver","onAxisValueChangedObservable","add","axesData","axisChangedHandler","_movementState","_featureContext","_xrInput","onButtonChangedObserver","onButtonStateChangedObservable","changes","pressed","buttonChangedhandler","onMotionControllerInitObservable","addOnce","xrInput","undefined","Error","Array","isArray","customRegistrationConfigurations","REGISTRATIONS","default","movementEnabled","movementOrientationFollowsViewerPose","movementSpeed","movementThreshold","rotationEnabled","rotationSpeed","rotationThreshold","moveX","moveY","rotateX","rotateY","movementDirection","_movementDirection","enabled","followsPose","threshold","attach","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","detach","Object","keys","controllerId","_onXRFrame","_xrFrame","xrCamera","rotationQuaternion","clone","deltaMillis","scene","getEngine","getDeltaTime","rotationY","useRightHandedSystem","cameraRotation","y","multiply","RotationYawPitchRoll","multiplyInPlace","copyFrom","FromQuaternionToRef","_tmpRotationMatrix","_tmpTranslationDirection","set","TransformCoordinatesToRef","_tmpMovementTranslation","scaleInPlace","_computeLocalCameraSpeed","cameraDirection","addInPlace","xrControllerUniqueId","remove","MOVEMENT","THUMBSTICK_TYPE","TOUCHPAD_TYPE","axes","movementState","featureContext","Math","abs","x","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRControllerMovement.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue, IWebXRMotionControllerComponentChangesValues } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { MotionControllerComponentType } from \"../motionController/webXRAbstractMotionController\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * The options container for the controller movement module\r\n */\r\nexport interface IWebXRControllerMovementOptions {\r\n    /**\r\n     * Override default behaviour and provide your own movement controls\r\n     */\r\n    customRegistrationConfigurations?: WebXRControllerMovementRegistrationConfiguration[];\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    movementEnabled?: boolean;\r\n    /**\r\n     * Camera direction follows view pose and movement by default will move independently of the viewer's pose.\r\n     */\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    movementSpeed?: number;\r\n    /**\r\n     * Minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    movementThreshold?: number;\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    rotationEnabled?: boolean;\r\n    /**\r\n     * Minimum threshold the controller's thumstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    rotationThreshold?: number;\r\n    /**\r\n     * Movement speed factor (default is 1.0)\r\n     */\r\n    rotationSpeed?: number;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Feature context is used in handlers and on each XR frame to control the camera movement/direction.\r\n */\r\nexport type WebXRControllerMovementFeatureContext = {\r\n    movementEnabled: boolean;\r\n    movementOrientationFollowsViewerPose: boolean;\r\n    movementSpeed: number;\r\n    movementThreshold: number;\r\n    rotationEnabled: boolean;\r\n    rotationSpeed: number;\r\n    rotationThreshold: number;\r\n};\r\n\r\n/**\r\n * Current state of Movements shared across components and handlers.\r\n */\r\nexport type WebXRControllerMovementState = {\r\n    moveX: number;\r\n    moveY: number;\r\n    rotateX: number;\r\n    rotateY: number;\r\n};\r\n\r\n/**\r\n * Button of Axis Handler must be specified.\r\n */\r\nexport type WebXRControllerMovementRegistrationConfiguration = {\r\n    /**\r\n     * handlers are filtered to these types only\r\n     */\r\n    allowedComponentTypes?: MotionControllerComponentType[];\r\n    /**\r\n     * For registering movement to specific hand only.  Useful if your app has a \"main hand\" and \"off hand\" for determining the functionality of a controller.\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n    /**\r\n     * For main component only (useful for buttons and may not trigger axis changes).\r\n     */\r\n    mainComponentOnly?: boolean;\r\n    /**\r\n     * Additional predicate to apply to controllers to restrict a handler being added.\r\n     */\r\n    componentSelectionPredicate?: (xrController: WebXRInputSource) => Nullable<WebXRControllerComponent>;\r\n} & (\r\n    | {\r\n          /**\r\n           * Called when axis changes occur.\r\n           */\r\n          axisChangedHandler: (\r\n              axes: IWebXRMotionControllerAxesValue,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n    | {\r\n          /**\r\n           * Called when the button state changes.\r\n           */\r\n          buttonChangedhandler: (\r\n              pressed: IWebXRMotionControllerComponentChangesValues<boolean>,\r\n              movementState: WebXRControllerMovementState,\r\n              featureContext: WebXRControllerMovementFeatureContext,\r\n              xrInput: WebXRInput\r\n          ) => void;\r\n      }\r\n);\r\n\r\ntype RegisteredComponent = {\r\n    registrationConfiguration: WebXRControllerMovementRegistrationConfiguration;\r\n    component: WebXRControllerComponent;\r\n    onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n};\r\n\r\n/**\r\n * This is a movement feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            registeredComponents: RegisteredComponent[];\r\n        };\r\n    } = {};\r\n\r\n    private _currentRegistrationConfigurations: WebXRControllerMovementRegistrationConfiguration[] = [];\r\n    // Feature configuration is syncronized - this is passed to all handlers (reduce GC pressure).\r\n    private _featureContext: WebXRControllerMovementFeatureContext;\r\n    // forward direction for movement, which may differ from viewer pose.\r\n    private _movementDirection: Nullable<Quaternion> = null;\r\n    private _movementState: WebXRControllerMovementState;\r\n    private _xrInput: WebXRInput;\r\n\r\n    // unused\r\n    private _tmpRotationMatrix: Matrix = Matrix.Identity();\r\n    private _tmpTranslationDirection: Vector3 = new Vector3();\r\n    private _tmpMovementTranslation: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.MOVEMENT;\r\n\r\n    /**\r\n     * Standard controller configurations.\r\n     */\r\n    public static readonly REGISTRATIONS: { [key: string]: WebXRControllerMovementRegistrationConfiguration[] } = {\r\n        default: [\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"left\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\r\n                    movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n            {\r\n                allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\r\n                forceHandedness: \"right\",\r\n                axisChangedHandler: (axes: IWebXRMotionControllerAxesValue, movementState: WebXRControllerMovementState, featureContext: WebXRControllerMovementFeatureContext) => {\r\n                    movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\r\n                    movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\r\n                },\r\n            },\r\n        ],\r\n    };\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Current movement direction.  Will be null before XR Frames have been processed.\r\n     */\r\n    public get movementDirection(): Nullable<Quaternion> {\r\n        return this._movementDirection;\r\n    }\r\n\r\n    /**\r\n     * Is movement enabled\r\n     */\r\n    public get movementEnabled(): boolean {\r\n        return this._featureContext.movementEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement is enabled or not\r\n     * @param enabled is movement enabled\r\n     */\r\n    public set movementEnabled(enabled: boolean) {\r\n        this._featureContext.movementEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * If movement follows viewer pose\r\n     */\r\n    public get movementOrientationFollowsViewerPose(): boolean {\r\n        return this._featureContext.movementOrientationFollowsViewerPose;\r\n    }\r\n\r\n    /**\r\n     * Sets whether movement follows viewer pose\r\n     * @param followsPose is movement should follow viewer pose\r\n     */\r\n    public set movementOrientationFollowsViewerPose(followsPose: boolean) {\r\n        this._featureContext.movementOrientationFollowsViewerPose = followsPose;\r\n    }\r\n\r\n    /**\r\n     * Gets movement speed\r\n     */\r\n    public get movementSpeed(): number {\r\n        return this._featureContext.movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets movement speed\r\n     * @param movementSpeed movement speed\r\n     */\r\n    public set movementSpeed(movementSpeed: number) {\r\n        this._featureContext.movementSpeed = movementSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     */\r\n    public get movementThreshold(): number {\r\n        return this._featureContext.movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\r\n     * @param movementThreshold new threshold\r\n     */\r\n    public set movementThreshold(movementThreshold: number) {\r\n        this._featureContext.movementThreshold = movementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Is rotation enabled\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._featureContext.rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._featureContext.rotationEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * Gets rotation speed factor\r\n     */\r\n    public get rotationSpeed(): number {\r\n        return this._featureContext.rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets rotation speed factor (1.0 is default)\r\n     * @param rotationSpeed new rotation speed factor\r\n     */\r\n    public set rotationSpeed(rotationSpeed: number) {\r\n        this._featureContext.rotationSpeed = rotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     */\r\n    public get rotationThreshold(): number {\r\n        return this._featureContext.rotationThreshold;\r\n    }\r\n\r\n    /**\r\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\r\n     * @param threshold new threshold\r\n     */\r\n    public set rotationThreshold(threshold: number) {\r\n        this._featureContext.rotationThreshold = threshold;\r\n    }\r\n    /**\r\n     * constructs a new movement controller system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, options: IWebXRControllerMovementOptions) {\r\n        super(_xrSessionManager);\r\n\r\n        if (!options || options.xrInput === undefined) {\r\n            Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(options.customRegistrationConfigurations)) {\r\n            this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\r\n        } else {\r\n            this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\r\n        }\r\n\r\n        // synchronized from feature setter properties\r\n        this._featureContext = {\r\n            movementEnabled: options.movementEnabled || true,\r\n            movementOrientationFollowsViewerPose: options.movementOrientationFollowsViewerPose ?? true,\r\n            movementSpeed: options.movementSpeed ?? 1,\r\n            movementThreshold: options.movementThreshold ?? 0.25,\r\n            rotationEnabled: options.rotationEnabled ?? true,\r\n            rotationSpeed: options.rotationSpeed ?? 1.0,\r\n            rotationThreshold: options.rotationThreshold ?? 0.25,\r\n        };\r\n\r\n        this._movementState = {\r\n            moveX: 0,\r\n            moveY: 0,\r\n            rotateX: 0,\r\n            rotateY: 0,\r\n        };\r\n\r\n        this._xrInput = options.xrInput;\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, (controller: WebXRInputSource) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Occurs on every XR frame.\r\n     * @param _xrFrame\r\n     */\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!this.attach) {\r\n            return;\r\n        }\r\n\r\n        if (this._movementDirection === null) {\r\n            this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.clone();\r\n        }\r\n\r\n        if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\r\n            // smooth rotation\r\n            const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\r\n            const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n\r\n            if (this._featureContext.movementOrientationFollowsViewerPose === true) {\r\n                this._xrInput.xrCamera.cameraRotation.y += rotationY;\r\n                this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.multiply(Quaternion.RotationYawPitchRoll(rotationY, 0, 0));\r\n            } else {\r\n                // movement orientation direction does not affect camera.  We use rotation speed multiplier\r\n                // otherwise need to implement inertia and constraints for same feel as TargetCamera.\r\n                this._movementDirection.multiplyInPlace(Quaternion.RotationYawPitchRoll(rotationY * 3.0, 0, 0));\r\n            }\r\n        } else if (this._featureContext.movementOrientationFollowsViewerPose === true) {\r\n            this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\r\n        }\r\n\r\n        if ((this._movementState.moveX !== 0 || this._movementState.moveY !== 0) && this._featureContext.movementEnabled) {\r\n            Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\r\n            this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n            // move according to forward direction based on camera speed\r\n            Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\r\n            this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\r\n\r\n            this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            registeredComponents: [],\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n\r\n        // movement controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initController = () => {\r\n                if (xrController.motionController) {\r\n                    for (const registration of this._currentRegistrationConfigurations) {\r\n                        let component: Nullable<WebXRControllerComponent> = null;\r\n\r\n                        if (registration.allowedComponentTypes) {\r\n                            for (const componentType of registration.allowedComponentTypes) {\r\n                                const componentOfType = xrController.motionController.getComponentOfType(componentType);\r\n                                if (componentOfType !== null) {\r\n                                    component = componentOfType;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (registration.mainComponentOnly) {\r\n                            const mainComponent = xrController.motionController.getMainComponent();\r\n                            if (mainComponent === null) {\r\n                                continue;\r\n                            }\r\n                            component = mainComponent;\r\n                        }\r\n\r\n                        if (typeof registration.componentSelectionPredicate === \"function\") {\r\n                            // if does not match we do want to ignore a previously found component\r\n                            component = registration.componentSelectionPredicate(xrController);\r\n                        }\r\n\r\n                        if (component && registration.forceHandedness) {\r\n                            if (xrController.inputSource.handedness !== registration.forceHandedness) {\r\n                                continue; // do not register\r\n                            }\r\n                        }\r\n\r\n                        if (component === null) {\r\n                            continue; // do not register\r\n                        }\r\n\r\n                        const registeredComponent: RegisteredComponent = {\r\n                            registrationConfiguration: registration,\r\n                            component,\r\n                        };\r\n                        controllerData.registeredComponents.push(registeredComponent);\r\n\r\n                        if (\"axisChangedHandler\" in registration) {\r\n                            registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add((axesData) => {\r\n                                registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\r\n                            });\r\n                        }\r\n\r\n                        if (\"buttonChangedhandler\" in registration) {\r\n                            registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\r\n                                if (component!.changes.pressed) {\r\n                                    registration.buttonChangedhandler(component!.changes.pressed, this._movementState, this._featureContext, this._xrInput);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (xrController.motionController) {\r\n                initController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initController();\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n\r\n        for (const registeredComponent of controllerData.registeredComponents) {\r\n            if (registeredComponent.onAxisChangedObserver) {\r\n                registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\r\n            }\r\n            if (registeredComponent.onButtonChangedObserver) {\r\n                registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\r\n            }\r\n        }\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerMovement.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerMovement(xrSessionManager, options);\r\n    },\r\n    WebXRControllerMovement.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}