{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"fluidRenderingRenderPixelShader\";\nconst shader = `#define IOR 1.333\n#define ETA 1.0/IOR\n#define F0 0.02\nuniform sampler2D textureSampler;\nuniform sampler2D depthSampler;\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nuniform sampler2D diffuseSampler;\n#else\nuniform vec3 diffuseColor;\n#endif\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\nuniform float thickness;\nuniform sampler2D bgDepthSampler;\n#else\nuniform float minimumThickness;\nuniform sampler2D thicknessSampler;\n#endif\n#ifdef FLUIDRENDERING_ENVIRONMENT\nuniform samplerCube reflectionSampler;\n#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nuniform sampler2D debugSampler;\n#endif\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 invProjectionMatrix;\nuniform vec2 texelSize;\nuniform vec3 dirLight;\nuniform float cameraFar;\nuniform float density;\nuniform float refractionStrength;\nuniform float fresnelClamp;\nuniform float specularPower;\nvarying vec2 vUV;\nvec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {\nvec4 ndc;\nndc.xy=texCoord*2.0-1.0;\nndc.z=projectionMatrix[2].z+projectionMatrix[3].z/depth;\nndc.w=1.0;\nvec4 eyePos=invProjectionMatrix*ndc;\neyePos.xyz/=eyePos.w;\nreturn eyePos.xyz;\n}\nvec3 getViewPosFromTexCoord(vec2 texCoord) {\nfloat depth=textureLod(depthSampler,texCoord,0.).x;\nreturn computeViewPosFromUVDepth(texCoord,depth);\n}\nvoid main(void) {\nvec2 texCoord=vUV;\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nvec4 color=texture2D(debugSampler,texCoord);\n#ifdef FLUIDRENDERING_DEBUG_DEPTH\nglFragColor=vec4(color.rgb/vec3(2.0),1.);\nif (color.r>0.999 && color.g>0.999) {\nglFragColor=texture2D(textureSampler,texCoord);\n}\n#else\nglFragColor=vec4(color.rgb,1.);\nif (color.r<0.001 && color.g<0.001 && color.b<0.001) {\nglFragColor=texture2D(textureSampler,texCoord);\n}\n#endif\nreturn;\n#endif\nvec2 depthVel=textureLod(depthSampler,texCoord,0.).rg;\nfloat depth=depthVel.r;\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\nfloat thickness=texture2D(thicknessSampler,texCoord).x;\n#else\nfloat bgDepth=texture2D(bgDepthSampler,texCoord).x;\nfloat depthNonLinear=projectionMatrix[2].z+projectionMatrix[3].z/depth;\ndepthNonLinear=depthNonLinear*0.5+0.5;\n#endif\nvec3 backColor=texture2D(textureSampler,texCoord).rgb;\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\nif (depth>=cameraFar || depth<=0. || thickness<=minimumThickness) {\n#else\nif (depth>=cameraFar || depth<=0. || bgDepth<=depthNonLinear) {\n#endif\nglFragColor=vec4(backColor,1.);\nreturn;\n}\nvec3 viewPos=computeViewPosFromUVDepth(texCoord,depth);\nvec3 ddx=getViewPosFromTexCoord(texCoord+vec2(texelSize.x,0.))-viewPos;\nvec3 ddy=getViewPosFromTexCoord(texCoord+vec2(0.,texelSize.y))-viewPos;\nvec3 ddx2=viewPos-getViewPosFromTexCoord(texCoord+vec2(-texelSize.x,0.));\nif (abs(ddx.z)>abs(ddx2.z)) {\nddx=ddx2;\n}\nvec3 ddy2=viewPos-getViewPosFromTexCoord(texCoord+vec2(0.,-texelSize.y));\nif (abs(ddy.z)>abs(ddy2.z)) {\nddy=ddy2;\n}\nvec3 normal=normalize(cross(ddy,ddx));\n#ifndef WEBGPU\nif(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) || isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {\nnormal=vec3(0.,0.,-1.);\n}\n#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\nglFragColor=vec4(normal*0.5+0.5,1.0);\nreturn;\n#endif\nvec3 rayDir=normalize(viewPos); \n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nvec3 diffuseColor=texture2D(diffuseSampler,texCoord).rgb;\n#endif\nvec3 lightDir=normalize(vec3(viewMatrix*vec4(-dirLight,0.)));\nvec3 H =normalize(lightDir-rayDir);\nfloat specular=pow(max(0.0,dot(H,normal)),specularPower);\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\nfloat diffuse =max(0.0,dot(lightDir,normal))*1.0;\nglFragColor=vec4(vec3(0.1) /*ambient*/+vec3(0.42,0.50,1.00)*diffuse+vec3(0,0,0.2)+specular,1.);\nreturn;\n#endif\nvec3 refractionDir=refract(rayDir,normal,ETA);\nvec3 transmitted=(texture2D(textureSampler,vec2(texCoord+refractionDir.xy*thickness*refractionStrength)).rgb);\nvec3 transmittance=exp(-density*thickness*(1.0-diffuseColor)); \nvec3 refractionColor=transmitted*transmittance;\n#ifdef FLUIDRENDERING_ENVIRONMENT\nvec3 reflectionDir=reflect(rayDir,normal);\nvec3 reflectionColor=(textureCube(reflectionSampler,reflectionDir).rgb);\nfloat fresnel=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,fresnelClamp);\nvec3 finalColor=mix(refractionColor,reflectionColor,fresnel)+specular;\n#else\nvec3 finalColor=refractionColor+specular;\n#endif\n#ifdef FLUIDRENDERING_VELOCITY\nfloat velocity=depthVel.g;\nfinalColor=mix(finalColor,vec3(1.0),smoothstep(0.3,1.0,velocity/6.0));\n#endif\nglFragColor=vec4(finalColor,1.);\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingRenderPixelShader = {\n  name,\n  shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,2BAAyB;AAErD,MAAMC,IAAI,GAAG,iCAAiC;AAC9C,MAAMC,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqId;AACD;AACAF,WAAW,CAACG,YAAY,CAACF,IAAI,CAAC,GAAGC,MAAM;AACvC;AACA,OAAO,MAAME,+BAA+B,GAAG;EAAEH,IAAI;EAAEC;AAAM,CAAE","names":["ShaderStore","name","shader","ShadersStore","fluidRenderingRenderPixelShader"],"sourceRoot":"","sources":["../../../../lts/core/generated/Shaders/fluidRenderingRender.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingRenderPixelShader\";\nconst shader = `#define IOR 1.333\n#define ETA 1.0/IOR\n#define F0 0.02\nuniform sampler2D textureSampler;\runiform sampler2D depthSampler;\r#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nuniform sampler2D diffuseSampler;\r#else\nuniform vec3 diffuseColor;\r#endif\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\nuniform float thickness;\runiform sampler2D bgDepthSampler;\r#else\nuniform float minimumThickness;\runiform sampler2D thicknessSampler;\r#endif\n#ifdef FLUIDRENDERING_ENVIRONMENT\nuniform samplerCube reflectionSampler;\r#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nuniform sampler2D debugSampler;\r#endif\nuniform mat4 viewMatrix;\runiform mat4 projectionMatrix;\runiform mat4 invProjectionMatrix;\runiform vec2 texelSize;\runiform vec3 dirLight;\runiform float cameraFar;\runiform float density;\runiform float refractionStrength;\runiform float fresnelClamp;\runiform float specularPower;\rvarying vec2 vUV;\rvec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {\rvec4 ndc;\rndc.xy=texCoord*2.0-1.0;\rndc.z=projectionMatrix[2].z+projectionMatrix[3].z/depth;\rndc.w=1.0;\rvec4 eyePos=invProjectionMatrix*ndc;\reyePos.xyz/=eyePos.w;\rreturn eyePos.xyz;\r}\rvec3 getViewPosFromTexCoord(vec2 texCoord) {\rfloat depth=textureLod(depthSampler,texCoord,0.).x;\rreturn computeViewPosFromUVDepth(texCoord,depth);\r}\rvoid main(void) {\rvec2 texCoord=vUV;\r#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nvec4 color=texture2D(debugSampler,texCoord);\r#ifdef FLUIDRENDERING_DEBUG_DEPTH\nglFragColor=vec4(color.rgb/vec3(2.0),1.);\rif (color.r>0.999 && color.g>0.999) {\rglFragColor=texture2D(textureSampler,texCoord);\r}\r#else\nglFragColor=vec4(color.rgb,1.);\rif (color.r<0.001 && color.g<0.001 && color.b<0.001) {\rglFragColor=texture2D(textureSampler,texCoord);\r}\r#endif\nreturn;\r#endif\nvec2 depthVel=textureLod(depthSampler,texCoord,0.).rg;\rfloat depth=depthVel.r;\r#ifndef FLUIDRENDERING_FIXED_THICKNESS\nfloat thickness=texture2D(thicknessSampler,texCoord).x;\r#else\nfloat bgDepth=texture2D(bgDepthSampler,texCoord).x;\rfloat depthNonLinear=projectionMatrix[2].z+projectionMatrix[3].z/depth;\rdepthNonLinear=depthNonLinear*0.5+0.5;\r#endif\nvec3 backColor=texture2D(textureSampler,texCoord).rgb;\r#ifndef FLUIDRENDERING_FIXED_THICKNESS\nif (depth>=cameraFar || depth<=0. || thickness<=minimumThickness) {\r#else\nif (depth>=cameraFar || depth<=0. || bgDepth<=depthNonLinear) {\r#endif\nglFragColor=vec4(backColor,1.);\rreturn;\r}\rvec3 viewPos=computeViewPosFromUVDepth(texCoord,depth);\rvec3 ddx=getViewPosFromTexCoord(texCoord+vec2(texelSize.x,0.))-viewPos;\rvec3 ddy=getViewPosFromTexCoord(texCoord+vec2(0.,texelSize.y))-viewPos;\rvec3 ddx2=viewPos-getViewPosFromTexCoord(texCoord+vec2(-texelSize.x,0.));\rif (abs(ddx.z)>abs(ddx2.z)) {\rddx=ddx2;\r}\rvec3 ddy2=viewPos-getViewPosFromTexCoord(texCoord+vec2(0.,-texelSize.y));\rif (abs(ddy.z)>abs(ddy2.z)) {\rddy=ddy2;\r}\rvec3 normal=normalize(cross(ddy,ddx));\r#ifndef WEBGPU\nif(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) || isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {\rnormal=vec3(0.,0.,-1.);\r}\r#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\nglFragColor=vec4(normal*0.5+0.5,1.0);\rreturn;\r#endif\nvec3 rayDir=normalize(viewPos); \r#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nvec3 diffuseColor=texture2D(diffuseSampler,texCoord).rgb;\r#endif\nvec3 lightDir=normalize(vec3(viewMatrix*vec4(-dirLight,0.)));\rvec3 H =normalize(lightDir-rayDir);\rfloat specular=pow(max(0.0,dot(H,normal)),specularPower);\r#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\nfloat diffuse =max(0.0,dot(lightDir,normal))*1.0;\rglFragColor=vec4(vec3(0.1) /*ambient*/+vec3(0.42,0.50,1.00)*diffuse+vec3(0,0,0.2)+specular,1.);\rreturn;\r#endif\nvec3 refractionDir=refract(rayDir,normal,ETA);\rvec3 transmitted=(texture2D(textureSampler,vec2(texCoord+refractionDir.xy*thickness*refractionStrength)).rgb);\rvec3 transmittance=exp(-density*thickness*(1.0-diffuseColor)); \rvec3 refractionColor=transmitted*transmittance;\r#ifdef FLUIDRENDERING_ENVIRONMENT\nvec3 reflectionDir=reflect(rayDir,normal);\rvec3 reflectionColor=(textureCube(reflectionSampler,reflectionDir).rgb);\rfloat fresnel=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,fresnelClamp);\rvec3 finalColor=mix(refractionColor,reflectionColor,fresnel)+specular;\r#else\nvec3 finalColor=refractionColor+specular;\r#endif\n#ifdef FLUIDRENDERING_VELOCITY\nfloat velocity=depthVel.g;\rfinalColor=mix(finalColor,vec3(1.0),smoothstep(0.3,1.0,velocity/6.0));\r#endif\nglFragColor=vec4(finalColor,1.);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingRenderPixelShader = { name, shader };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}